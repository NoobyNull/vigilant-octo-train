#include "gcode_export.h"

#include <cmath>
#include <cstdio>
#include <fstream>
#include <sstream>

namespace dw {
namespace carve {

namespace {

// Format float with minimal trailing zeros (e.g., 5.0 not 5.000000)
std::string fmt(f32 v)
{
    char buf[32];
    std::snprintf(buf, sizeof(buf), "%.3f", static_cast<double>(v));
    // Trim trailing zeros after decimal
    std::string s(buf);
    auto dot = s.find('.');
    if (dot != std::string::npos) {
        auto last = s.find_last_not_of('0');
        if (last == dot) {
            s.erase(dot + 2);  // Keep at least one decimal
        } else {
            s.erase(last + 1);
        }
    }
    return s;
}

void writeHeader(std::ostringstream& out,
                 const std::string& modelName,
                 const std::string& toolName,
                 const ToolpathConfig& config)
{
    out << "(Direct Carve - generated by Digital Workshop)\n";
    out << "(Model: " << modelName << ")\n";
    out << "(Tool: " << toolName << ")\n";
    out << "(Feed: " << fmt(config.feedRateMmMin)
        << " mm/min, Plunge: " << fmt(config.plungeRateMmMin) << " mm/min)\n";
    out << "(Safe Z: " << fmt(config.safeZMm) << " mm)\n";
}

void writePreamble(std::ostringstream& out)
{
    out << "G90 G21 (absolute, metric)\n";
}

void writeToolpath(std::ostringstream& out,
                   const Toolpath& path,
                   const ToolpathConfig& config,
                   const std::string& passLabel,
                   bool& feedDeclared)
{
    if (path.points.empty()) return;

    out << "(" << passLabel << " - " << path.lineCount << " lines, ~"
        << fmt(path.estimatedTimeSec / 60.0f) << " min)\n";

    for (const auto& pt : path.points) {
        if (pt.rapid) {
            out << "G0"
                << " X" << fmt(pt.position.x)
                << " Y" << fmt(pt.position.y)
                << " Z" << fmt(pt.position.z)
                << "\n";
        } else {
            out << "G1"
                << " X" << fmt(pt.position.x)
                << " Y" << fmt(pt.position.y)
                << " Z" << fmt(pt.position.z);
            if (!feedDeclared) {
                out << " F" << fmt(config.feedRateMmMin);
                feedDeclared = true;
            }
            out << "\n";
        }
    }
}

void writeFooter(std::ostringstream& out, f32 safeZ)
{
    out << "G0 Z" << fmt(safeZ) << "\n";
    out << "M5\n";
    out << "M30\n";
}

} // anonymous namespace

std::string generateGcode(const MultiPassToolpath& toolpath,
                          const ToolpathConfig& config,
                          const std::string& modelName,
                          const std::string& toolName)
{
    std::ostringstream out;

    writeHeader(out, modelName, toolName, config);
    writePreamble(out);

    // Safe Z retract before starting
    out << "G0 Z" << fmt(config.safeZMm) << "\n";

    bool feedDeclared = false;

    // Clearing pass first (if present)
    if (!toolpath.clearing.points.empty()) {
        writeToolpath(out, toolpath.clearing, config, "Clearing pass", feedDeclared);
    }

    // Finishing pass
    if (!toolpath.finishing.points.empty()) {
        writeToolpath(out, toolpath.finishing, config, "Finishing pass", feedDeclared);
    }

    writeFooter(out, config.safeZMm);

    return out.str();
}

bool exportGcode(const std::string& path,
                 const MultiPassToolpath& toolpath,
                 const ToolpathConfig& config,
                 const std::string& modelName,
                 const std::string& toolName)
{
    std::string gcode = generateGcode(toolpath, config, modelName, toolName);

    std::ofstream file(path, std::ios::out | std::ios::trunc);
    if (!file.is_open()) return false;

    file << gcode;
    return file.good();
}

} // namespace carve
} // namespace dw
