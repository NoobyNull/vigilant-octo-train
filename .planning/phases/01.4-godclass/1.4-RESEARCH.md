# Phase 1.4: Application God Class Decomposition - Research

**Researched:** 2026-02-08
**Domain:** C++ Application Architecture Refactoring - God Class Decomposition
**Confidence:** HIGH

## Summary

Application.cpp currently contains 1,071 lines implementing multiple distinct responsibilities: SDL/OpenGL/ImGui initialization, UI panel lifecycle, file I/O orchestration, menu handling, keyboard shortcuts, config hot-reload, workspace state persistence, and event processing. This is a classic god class anti-pattern requiring systematic decomposition into focused managers.

The refactoring strategy is to extract three focused managers (UIManager, FileIOManager, and ConfigManager) while keeping Application as a thin coordinator (~300 lines). The existing EventBus (Phase 1.1) and MainThreadQueue (Phase 1.3) provide the infrastructure for decoupled communication between managers. Critical risks include initialization ordering dependencies (15 subsystems with complex dependencies), state management during extraction, and the subtle callback web connecting panels to Application methods.

An existing `src/ui/ui_manager.h` (75 lines) already handles ImGui frame setup and menu rendering but does NOT manage panel lifecycle, visibility state, or dialog orchestration - meaning we need to EXTEND it rather than create a duplicate. The decomposition must proceed incrementally: extract one manager, verify behavior unchanged, commit, then proceed to the next.

**Primary recommendation:** Extract managers incrementally in order (UI → FileIO → Config), extend existing UIManager rather than creating duplicate, use dependency injection for all cross-manager dependencies, and leverage EventBus for all cross-manager communication to prevent coupling.

## Standard Stack

### Core (Already In Use)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SDL2 | 2.x | Window/event management | Industry standard for cross-platform windowing |
| ImGui | 1.89+ | Immediate mode UI | De facto standard for C++ tool UIs, already integrated |
| OpenGL | 3.3 Core | 3D rendering | Stable, widely supported graphics API |
| SQLite3 | 3.x | Database | Embedded database, already in use |
| C++17 | - | Language standard | Project's current standard |

### Supporting (For Refactoring)
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| std::unique_ptr | C++11+ | Manager ownership | Owning managers in Application |
| std::function | C++11+ | Callbacks | Replacing direct method calls |
| std::weak_ptr | C++11+ | EventBus subscriptions | Already used in EventBus design |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual DI | Boost.DI or similar | Manual DI is simpler for 3-4 managers, framework adds complexity |
| EventBus | Direct manager references | EventBus decouples managers, prevents circular dependencies |
| Incremental extraction | Big-bang rewrite | Incremental allows testing at each step, lower risk |

**Installation:** No new dependencies required - refactoring uses existing stack.

## Architecture Patterns

### Current Structure (Before Refactoring)
```
src/app/
├── application.h         # 142 lines - 15 manager members, 7 panels, 2 dialogs
├── application.cpp       # 1,071 lines - EVERYTHING lives here
└── workspace.h/.cpp      # Focus management (keep separate)

src/ui/
└── ui_manager.h/.cpp     # 75 lines - ImGui frame/menu only (NOT panel lifecycle)
```

### Target Structure (After Refactoring)
```
src/app/
├── application.h/.cpp           # ~300 lines - thin coordinator
└── workspace.h/.cpp            # unchanged

src/managers/
├── ui_manager.h/.cpp           # Extended from src/ui/ui_manager.*
├── file_io_manager.h/.cpp      # File operations orchestration
└── config_manager.h/.cpp       # Config hot-reload & workspace state

src/ui/
└── ui_manager.* REMOVED        # Consolidated into src/managers/ui_manager.*
```

### Pattern 1: Manager Extraction with Dependency Injection

**What:** Extract cohesive responsibilities into manager classes, inject dependencies via constructor.

**When to use:** When a class exceeds 800 lines or has more than 5 distinct responsibilities.

**Example from analysis:**
```cpp
// Current: Application owns everything
class Application {
    std::unique_ptr<Database> m_database;
    std::unique_ptr<LibraryManager> m_libraryManager;
    std::unique_ptr<ProjectManager> m_projectManager;
    std::unique_ptr<Workspace> m_workspace;
    std::unique_ptr<EventBus> m_eventBus;
    std::unique_ptr<ViewportPanel> m_viewportPanel;
    // ... 10 more members

    void onImportModel();      // 18 lines
    void onExportModel();      // 24 lines
    void onNewProject();       // 5 lines
    void onOpenProject();      // 37 lines
    void onSaveProject();      // 29 lines
    // ... 20 more methods
};

// Target: Application delegates to managers
class Application {
    std::unique_ptr<UIManager> m_uiManager;
    std::unique_ptr<FileIOManager> m_fileIOManager;
    std::unique_ptr<ConfigManager> m_configManager;
    std::unique_ptr<Database> m_database;
    std::unique_ptr<EventBus> m_eventBus;
    // Core systems only

    void init() {
        // Initialize in correct order
        m_eventBus = std::make_unique<EventBus>();
        m_database = std::make_unique<Database>();
        // ... core systems

        // Inject dependencies into managers
        m_uiManager = std::make_unique<UIManager>(
            m_eventBus.get(),
            m_libraryManager.get(),
            m_projectManager.get(),
            m_workspace.get()
        );

        m_fileIOManager = std::make_unique<FileIOManager>(
            m_eventBus.get(),
            m_database.get(),
            m_libraryManager.get(),
            m_projectManager.get()
        );
    }
};

// UIManager: Owns panels, handles lifecycle
class UIManager {
public:
    UIManager(EventBus* eventBus,
              LibraryManager* library,
              ProjectManager* project,
              Workspace* workspace);

    void init(SDL_Window* window, void* glContext);
    void beginFrame();
    void renderMenuBar();
    void renderPanels();
    void endFrame();
    void shutdown();

private:
    // Owns all panels
    std::unique_ptr<ViewportPanel> m_viewportPanel;
    std::unique_ptr<LibraryPanel> m_libraryPanel;
    // ... other panels

    // Visibility state
    bool m_showViewport = true;
    bool m_showLibrary = true;
    // ... other visibility flags
};

// FileIOManager: Orchestrates file operations
class FileIOManager {
public:
    FileIOManager(EventBus* eventBus,
                  Database* database,
                  LibraryManager* library,
                  ProjectManager* project);

    void importModel();
    void exportModel(MeshPtr mesh);
    void newProject();
    void openProject();
    void saveProject();
    void onFilesDropped(const std::vector<std::string>& paths);

private:
    EventBus* m_eventBus;
    Database* m_database;
    LibraryManager* m_libraryManager;
    ProjectManager* m_projectManager;
    std::unique_ptr<FileDialog> m_fileDialog;
};
```

### Pattern 2: EventBus for Cross-Manager Communication

**What:** Use EventBus to decouple managers - no manager holds direct references to other managers.

**When to use:** When managers need to react to events from other managers without tight coupling.

**Example from existing EventBus.h:**
```cpp
// EventBus is already implemented (Phase 1.1)
// Source: src/core/events/event_bus.h

// Define event types
struct ModelImportedEvent {
    int64_t modelId;
    std::string name;
};

struct ProjectChangedEvent {
    int64_t projectId;
};

// FileIOManager publishes events
void FileIOManager::onImportComplete(int64_t modelId) {
    ModelImportedEvent event{modelId, "model.stl"};
    m_eventBus->publish(event);
}

// UIManager subscribes to events
void UIManager::init() {
    m_subscription = m_eventBus->subscribe<ModelImportedEvent>(
        [this](const ModelImportedEvent& event) {
            // Refresh library panel
            if (m_libraryPanel) {
                m_libraryPanel->refresh();
            }
        }
    );
}
```

### Pattern 3: Two-Phase Initialization for Complex Dependencies

**What:** Separate construction (allocate memory, store dependencies) from initialization (requires other systems ready).

**When to use:** When managers have circular dependencies or require other managers to be constructed first.

**Example based on research:**
```cpp
// Phase 1: Construct all managers (store raw pointers, don't use them)
m_database = std::make_unique<Database>();
m_eventBus = std::make_unique<EventBus>();
m_libraryManager = std::make_unique<LibraryManager>(*m_database);
m_uiManager = std::make_unique<UIManager>(m_eventBus.get(),
                                           m_libraryManager.get());

// Phase 2: Initialize managers (now safe to use dependencies)
if (!m_database->open(paths::getDatabasePath())) {
    return false;
}
m_libraryManager->init(); // Can now query database
m_uiManager->init(m_window, m_glContext); // Can now create panels
```

### Pattern 4: Incremental Extraction (Strangler Fig)

**What:** Extract one manager at a time, verify behavior unchanged, then proceed to next.

**When to use:** Large refactorings where big-bang approach is too risky.

**Steps:**
1. Extract UIManager methods and members
2. Update Application to delegate to UIManager
3. Compile, run tests, verify no behavioral changes
4. Commit
5. Extract FileIOManager methods and members
6. Update Application to delegate to FileIOManager
7. Compile, run tests, verify no behavioral changes
8. Commit
9. Extract ConfigManager methods and members
10. Final verification

### Anti-Patterns to Avoid

- **Manager Coupling:** Don't let managers hold direct references to other managers - use EventBus for cross-manager communication to prevent circular dependencies
- **Premature Consolidation:** Don't merge existing `src/ui/ui_manager.h` logic into Application during extraction - extend it instead
- **Big-Bang Refactoring:** Don't extract all managers simultaneously - extract one, verify, commit, repeat
- **Leaking Abstractions:** Don't expose manager internals (panels, dialogs) to Application - managers own their subsystems completely
- **State Duplication:** Don't duplicate visibility flags, config state, or other state between Application and managers - single source of truth
- **Initialization Race Conditions:** Don't initialize managers before their dependencies are ready - use two-phase init or careful ordering

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Dependency injection | Custom DI container for 3-4 managers | Manual constructor injection | Manual DI is sufficient at this scale; frameworks add complexity for marginal benefit |
| Event system | Custom pub/sub | Existing EventBus (Phase 1.1) | Already implemented, tested, and designed for this use case |
| Thread-safe queuing | Custom queue | Existing MainThreadQueue (Phase 1.3) | Already handles worker-to-main-thread communication safely |
| Static init ordering | Custom lifetime manager | std::unique_ptr + careful ordering | C++ destructors in reverse order handles cleanup; manual init order is explicit and debuggable |

**Key insight:** The infrastructure for decomposition (EventBus, MainThreadQueue) already exists from Phases 1.1 and 1.3. The challenge is not building new systems but systematically moving responsibilities from Application into managers while maintaining all existing behavior.

## Common Pitfalls

### Pitfall 1: Initialization Order Violations

**What goes wrong:** Manager A depends on Manager B, but B is initialized after A, causing null pointer dereference or uninitialized state access.

**Why it happens:** Application.cpp has 15 subsystems with subtle ordering dependencies (e.g., LibraryManager needs Database open, panels need LibraryManager/ProjectManager references).

**How to avoid:**
- Document dependency graph explicitly
- Initialize in dependency order: Core systems (EventBus, Database) → Business logic managers (LibraryManager, ProjectManager) → UI managers (UIManager with panels)
- Use two-phase initialization when necessary (construct all, then init all)
- Add debug assertions to catch out-of-order initialization

**Warning signs:**
- Segfaults during startup
- Null pointer dereferences in manager constructors
- Test failures that pass individually but fail when run together

### Pitfall 2: Callback Web Preservation Errors

**What goes wrong:** Application.cpp sets up 13 callbacks between panels and Application methods (e.g., `m_libraryPanel->setOnModelOpened([this](int64_t id) { onModelSelected(id); })`). During extraction, these callbacks break if not carefully migrated.

**Why it happens:** Callbacks capture `this` pointer to Application, but after extraction, the callback target moves to a manager.

**How to avoid:**
- Identify all callbacks first (grep for `setOn`, `[this]`, `std::function`)
- Migrate callbacks to use EventBus instead of direct method calls
- Or migrate callback targets to manager methods
- Test each callback path after migration (import, export, model selection, etc.)

**Warning signs:**
- Panels don't respond to user actions
- Model selection doesn't update viewport/properties
- Import doesn't trigger library refresh
- Project save button does nothing

### Pitfall 3: Visibility State Duplication

**What goes wrong:** Application currently stores panel visibility flags (`m_showViewport`, `m_showLibrary`, etc.) and manages them in menu bar, keyboard shortcuts, and workspace state save/restore. If UIManager also stores these flags, state can desync.

**Why it happens:** Multiple ownership of the same logical state during refactoring.

**How to avoid:**
- Move visibility flags to UIManager completely (single source of truth)
- Application reads visibility state from UIManager, doesn't store it
- Config save/restore goes through UIManager accessors
- Menu bar toggles call UIManager methods

**Warning signs:**
- Panel visibility checkbox doesn't match actual visibility
- Restart loses panel visibility state
- Keyboard shortcuts don't toggle panels
- Start page visibility flag desyncs

### Pitfall 4: Config Hot-Reload Complexity

**What goes wrong:** Application.cpp implements config file watching and applies theme, render settings, and UI scale changes at runtime. During extraction, the config watching logic and application logic get separated incorrectly.

**Why it happens:** Config watching (ConfigWatcher), config loading (Config singleton), and config application (theme, render settings) are currently intertwined.

**How to avoid:**
- Extract ConfigManager to own ConfigWatcher and coordinate config reloads
- ConfigManager publishes ConfigChangedEvent via EventBus
- UIManager subscribes to ConfigChangedEvent, applies theme changes
- ViewportPanel subscribes to ConfigChangedEvent, applies render settings
- Application subscribes for UI scale changes (triggers restart popup)

**Warning signs:**
- Theme changes don't apply live
- Config file edits don't trigger reload
- Render settings changes require restart
- Restart popup appears incorrectly

### Pitfall 5: Shutdown Order Violations

**What goes wrong:** Application.cpp shutdown() destroys subsystems in specific order (lines 1031-1078). If extraction changes destruction order, ImGui/OpenGL cleanup can fail or crash.

**Why it happens:** C++ destroys unique_ptr members in reverse declaration order, which may not match required destruction order.

**How to avoid:**
- Preserve destruction order: Dialogs/ConfigWatcher → Panels → Core systems → ImportQueue (joins worker) → EventBus (last)
- Use explicit shutdown() methods instead of relying on destructor order
- UIManager::shutdown() destroys panels before returning
- Application::shutdown() calls manager shutdowns in correct order

**Warning signs:**
- Segfaults during exit
- "ImGui context already destroyed" errors
- OpenGL errors during cleanup
- Worker thread still running after main exits

### Pitfall 6: Existing UIManager Overlap

**What goes wrong:** Confusion between existing `src/ui/ui_manager.h` (ImGui frame/menu/docking) and the new UIManager that needs to manage panel lifecycle.

**Why it happens:** Two concepts with same name, unclear which to extend vs replace.

**How to avoid:**
- EXTEND existing `src/ui/ui_manager.h` with panel lifecycle methods
- Move it to `src/managers/ui_manager.h` (consolidate location)
- Keep existing ImGui frame/menu methods
- Add panel ownership, visibility management, lifecycle methods
- Delete `src/ui/ui_manager.*` after consolidation

**Warning signs:**
- Two UIManager classes in codebase
- Linker errors (duplicate symbols)
- Ambiguous references to UIManager
- Panel creation logic in both Application and UIManager

## Code Examples

### Example 1: Current Application Method Categorization

Based on complete analysis of application.cpp (1,071 lines):

```cpp
// LIFECYCLE (keep in Application) - 400 lines
bool init();                                    // Lines 58-300
int run();                                      // Lines 302-317
void processEvents();                           // Lines 327-352
void update();                                  // Lines 354-361
void render();                                  // Lines 363-430
void quit();                                    // Lines 319-321
void shutdown();                                // Lines 1031-1078
auto eventBus() -> EventBus&;                  // Lines 323-325

// UI MANAGEMENT (extract to UIManager) - ~350 lines
void renderMenuBar();                           // Lines 432-493
void renderPanels();                            // Lines 495-533
void handleKeyboardShortcuts();                 // Lines 764-796
void renderImportProgress();                    // Lines 798-841
void showAboutDialog();                         // Lines 760-762
void renderRestartPopup();                      // Lines 943-968
void setupDefaultDockLayout(ImGuiID id);       // Lines 970-997

// FILE I/O ORCHESTRATION (extract to FileIOManager) - ~250 lines
void onImportModel();                           // Lines 535-553
void onExportModel();                           // Lines 555-579
void onNewProject();                            // Lines 581-585
void onOpenProject();                           // Lines 587-624
void onSaveProject();                           // Lines 626-654
void onFilesDropped(const vector<string>&);    // Lines 675-694
void processCompletedImports();                 // Lines 696-728
void onOpenRecentProject(const Path&);         // Lines 730-758

// CONFIG/WORKSPACE (extract to ConfigManager) - ~100 lines
void onConfigFileChanged();                     // Lines 843-847
void applyConfig();                             // Lines 849-884
void spawnSettingsApp();                        // Lines 886-916
void relaunchApp();                             // Lines 918-941
void saveWorkspaceState();                      // Lines 999-1029

// BUSINESS LOGIC (keep in Application or use EventBus)
void onModelSelected(int64_t modelId);         // Lines 656-673
```

### Example 2: UIManager Interface (Extended from src/ui/ui_manager.h)

```cpp
// src/managers/ui_manager.h
#pragma once

#include <memory>
#include <functional>
#include "../core/types.h"

struct SDL_Window;
union SDL_Event;
struct ImGuiID;

namespace dw {

class EventBus;
class LibraryManager;
class ProjectManager;
class Workspace;
class ViewportPanel;
class LibraryPanel;
class PropertiesPanel;
class ProjectPanel;
class GCodePanel;
class CutOptimizerPanel;
class StartPage;
class FileDialog;
class LightingDialog;

// UIManager - handles all UI concerns: panels, dialogs, layout, visibility
// Extended from original src/ui/ui_manager.h with panel lifecycle
class UIManager {
public:
    UIManager(EventBus* eventBus,
              LibraryManager* library,
              ProjectManager* project,
              Workspace* workspace);
    ~UIManager();

    // Initialization
    bool init(SDL_Window* window, void* glContext);
    void shutdown();

    // Frame lifecycle (from original ui_manager.h)
    void beginFrame();
    void endFrame();
    void processEvent(const SDL_Event& event);

    // Rendering
    void renderMenuBar(std::function<void()> onImport,
                      std::function<void()> onExport,
                      std::function<void()> onNewProject,
                      std::function<void()> onOpenProject,
                      std::function<void()> onSaveProject,
                      std::function<void()> onQuit);
    void renderPanels();
    void renderAboutDialog();
    void renderRestartPopup();

    // Panel visibility
    bool showViewport() const { return m_showViewport; }
    void setShowViewport(bool show) { m_showViewport = show; }
    bool showLibrary() const { return m_showLibrary; }
    void setShowLibrary(bool show) { m_showLibrary = show; }
    // ... other visibility getters/setters

    // Docking layout
    void setupDefaultDockLayout(ImGuiID dockspaceId);

    // Restart popup (for UI scale changes)
    void showRestartPopup() { m_showRestartPopup = true; }

    // Access to specific panels (for Application to wire callbacks)
    ViewportPanel* viewportPanel() { return m_viewportPanel.get(); }
    LibraryPanel* libraryPanel() { return m_libraryPanel.get(); }
    PropertiesPanel* propertiesPanel() { return m_propertiesPanel.get(); }
    ProjectPanel* projectPanel() { return m_projectPanel.get(); }
    StartPage* startPage() { return m_startPage.get(); }
    FileDialog* fileDialog() { return m_fileDialog.get(); }

private:
    SDL_Window* m_window = nullptr;
    EventBus* m_eventBus;
    LibraryManager* m_libraryManager;
    ProjectManager* m_projectManager;
    Workspace* m_workspace;

    // Panels (owned)
    std::unique_ptr<ViewportPanel> m_viewportPanel;
    std::unique_ptr<LibraryPanel> m_libraryPanel;
    std::unique_ptr<PropertiesPanel> m_propertiesPanel;
    std::unique_ptr<ProjectPanel> m_projectPanel;
    std::unique_ptr<GCodePanel> m_gcodePanel;
    std::unique_ptr<CutOptimizerPanel> m_cutOptimizerPanel;
    std::unique_ptr<StartPage> m_startPage;

    // Dialogs (owned)
    std::unique_ptr<FileDialog> m_fileDialog;
    std::unique_ptr<LightingDialog> m_lightingDialog;

    // Visibility state (single source of truth)
    bool m_showViewport = true;
    bool m_showLibrary = true;
    bool m_showProperties = true;
    bool m_showProject = true;
    bool m_showGCode = false;
    bool m_showCutOptimizer = false;
    bool m_showStartPage = true;

    // Popup state
    bool m_showRestartPopup = false;
    bool m_firstFrame = true;
};

} // namespace dw
```

### Example 3: FileIOManager Interface

```cpp
// src/managers/file_io_manager.h
#pragma once

#include <memory>
#include <vector>
#include <string>
#include "../core/types.h"

namespace dw {

class EventBus;
class Database;
class LibraryManager;
class ProjectManager;
class ImportQueue;
class FileDialog;
class Workspace;

// FileIOManager - orchestrates all file I/O operations
class FileIOManager {
public:
    FileIOManager(EventBus* eventBus,
                  Database* database,
                  LibraryManager* library,
                  ProjectManager* project,
                  ImportQueue* importQueue,
                  Workspace* workspace,
                  FileDialog* fileDialog);

    ~FileIOManager();

    // Import/Export
    void importModel();
    void exportModel();  // Gets mesh from workspace
    void onFilesDropped(const std::vector<std::string>& paths);
    void processCompletedImports();  // Called from Application::update()

    // Project operations
    void newProject();
    void openProject();
    void openRecentProject(const Path& path);
    void saveProject();

private:
    EventBus* m_eventBus;
    Database* m_database;
    LibraryManager* m_libraryManager;
    ProjectManager* m_projectManager;
    ImportQueue* m_importQueue;
    Workspace* m_workspace;
    FileDialog* m_fileDialog;  // Borrowed from UIManager
};

} // namespace dw
```

### Example 4: Refactored Application.cpp Structure (~300 lines)

```cpp
// src/app/application.cpp - AFTER refactoring
#include "application.h"

// Manager includes
#include "../managers/ui_manager.h"
#include "../managers/file_io_manager.h"
#include "../managers/config_manager.h"

// Core includes
#include "core/events/event_bus.h"
#include "core/database/database.h"
// ... other core includes

namespace dw {

Application::Application() = default;

Application::~Application() {
    shutdown();
}

bool Application::init() {
    if (m_initialized) return true;

    // Phase 1: Create core systems (no dependencies)
    paths::ensureDirectoriesExist();
    Config::instance().load();
    log::setLevel(static_cast<log::Level>(Config::instance().getLogLevel()));

    // SDL/OpenGL initialization (~60 lines - unchanged)
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) != 0) {
        std::fprintf(stderr, "SDL_Init failed: %s\n", SDL_GetError());
        return false;
    }
    // ... SDL/OpenGL setup (lines 73-157 from original)

    // Phase 2: Create core systems with dependencies
    m_eventBus = std::make_unique<EventBus>();
    m_database = std::make_unique<Database>();
    if (!m_database->open(paths::getDatabasePath())) {
        return false;
    }
    m_libraryManager = std::make_unique<LibraryManager>(*m_database);
    m_projectManager = std::make_unique<ProjectManager>(*m_database);
    m_workspace = std::make_unique<Workspace>();
    m_thumbnailGenerator = std::make_unique<ThumbnailGenerator>();
    m_importQueue = std::make_unique<ImportQueue>(*m_database);

    // Phase 3: Create managers (inject dependencies)
    m_uiManager = std::make_unique<UIManager>(
        m_eventBus.get(),
        m_libraryManager.get(),
        m_projectManager.get(),
        m_workspace.get()
    );

    m_fileIOManager = std::make_unique<FileIOManager>(
        m_eventBus.get(),
        m_database.get(),
        m_libraryManager.get(),
        m_projectManager.get(),
        m_importQueue.get(),
        m_workspace.get(),
        m_uiManager->fileDialog()  // Borrow file dialog from UI
    );

    m_configManager = std::make_unique<ConfigManager>(
        m_eventBus.get(),
        m_uiManager.get()
    );

    // Phase 4: Initialize managers (can now use dependencies safely)
    if (!m_uiManager->init(m_window, m_glContext)) {
        return false;
    }
    m_configManager->init();

    // Wire up cross-manager callbacks via Application
    wireCallbacks();

    m_initialized = true;
    return true;
}

void Application::wireCallbacks() {
    // UIManager menu bar needs file operation callbacks
    m_uiManager->setMenuCallbacks(
        [this]() { m_fileIOManager->importModel(); },
        [this]() { m_fileIOManager->exportModel(); },
        [this]() { m_fileIOManager->newProject(); },
        [this]() { m_fileIOManager->openProject(); },
        [this]() { m_fileIOManager->saveProject(); },
        [this]() { quit(); }
    );

    // Panel callbacks (selection, etc.) wire through Application
    m_uiManager->libraryPanel()->setOnModelOpened(
        [this](int64_t id) { onModelSelected(id); }
    );
    // ... other callbacks
}

int Application::run() {
    if (!m_initialized) return 1;

    m_running = true;
    while (m_running) {
        processEvents();
        update();
        render();
    }

    return 0;
}

void Application::processEvents() {
    std::vector<std::string> droppedFiles;
    SDL_Event event;

    while (SDL_PollEvent(&event) != 0) {
        m_uiManager->processEvent(event);

        if (event.type == SDL_QUIT) {
            quit();
        }
        if (event.type == SDL_DROPFILE && event.drop.file != nullptr) {
            droppedFiles.emplace_back(event.drop.file);
            SDL_free(event.drop.file);
        }
    }

    if (!droppedFiles.empty()) {
        m_fileIOManager->onFilesDropped(droppedFiles);
    }
}

void Application::update() {
    m_fileIOManager->processCompletedImports();
    m_configManager->poll();
}

void Application::render() {
    m_uiManager->beginFrame();

    // Create dockspace
    ImGuiID dockspaceId = ImGui::DockSpaceOverViewport(0, ImGui::GetMainViewport());
    if (m_firstFrame) {
        m_firstFrame = false;
        if (ImGui::DockBuilderGetNode(dockspaceId) == nullptr ||
            ImGui::DockBuilderGetNode(dockspaceId)->IsLeafNode()) {
            m_uiManager->setupDefaultDockLayout(dockspaceId);
        }
    }

    m_uiManager->renderMenuBar();
    m_uiManager->renderPanels();

    m_uiManager->endFrame();

    // Swap window
    SDL_GL_SwapWindow(m_window);
}

void Application::onModelSelected(int64_t modelId) {
    // Business logic: load mesh, update workspace, update panels
    // This is the kind of orchestration Application still handles
    if (!m_libraryManager) return;

    auto mesh = m_libraryManager->loadMesh(modelId);
    if (!mesh) return;

    m_workspace->setFocusedMesh(mesh);
    m_uiManager->viewportPanel()->setMesh(mesh);

    auto record = m_libraryManager->getModel(modelId);
    m_uiManager->propertiesPanel()->setMesh(mesh, record ? record->name : "");
}

void Application::shutdown() {
    if (!m_initialized) return;

    // Shutdown in reverse order
    m_configManager.reset();
    m_fileIOManager.reset();
    m_uiManager.reset();  // Destroys panels/dialogs

    m_importQueue.reset();  // Joins worker thread
    m_workspace.reset();
    m_thumbnailGenerator.reset();
    m_projectManager.reset();
    m_libraryManager.reset();
    m_database.reset();
    m_eventBus.reset();

    // SDL/OpenGL cleanup (~20 lines - unchanged)
    SDL_GL_DeleteContext(m_glContext);
    SDL_DestroyWindow(m_window);
    SDL_Quit();

    m_initialized = false;
}

} // namespace dw
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Monolithic Application class (1,071 lines) | Decomposed managers (~300 line coordinator) | 2026 refactoring | Improved maintainability, testability, clearer responsibilities |
| Direct method calls between subsystems | EventBus pub/sub | Phase 1.1 (EventBus) | Decoupled components, easier to test in isolation |
| Callback lambdas capturing `this` | EventBus event types | Phase 1.4 refactoring | Type-safe events, no dangling pointer risks |
| Manual dependency wiring | Constructor injection | Phase 1.4 refactoring | Explicit dependencies, easier to reason about initialization |
| Single UIManager (ImGui only) | Extended UIManager (panels + ImGui) | Phase 1.4 refactoring | Consolidates all UI concerns in one manager |

**Deprecated/outdated:**
- God class pattern: Modern C++ architecture emphasizes single responsibility principle (SRP) and focused classes
- Direct cross-subsystem calls: Prefer event-driven architecture for loosely coupled systems
- Big-bang refactoring: Incremental extraction (Strangler Fig pattern) is now standard for large refactorings

## Open Questions

1. **Should ConfigManager own ConfigWatcher, or should Application poll it?**
   - What we know: Application currently owns ConfigWatcher and polls it in update()
   - What's unclear: Best ownership model for hot-reload coordination
   - Recommendation: ConfigManager owns ConfigWatcher, Application calls `configManager->poll()` in update(). ConfigManager publishes ConfigChangedEvent when reload occurs.

2. **How to handle keyboard shortcuts that trigger file operations?**
   - What we know: `handleKeyboardShortcuts()` currently calls Application methods directly
   - What's unclear: Should shortcuts live in UIManager (UI concern) or route through Application?
   - Recommendation: Move `handleKeyboardShortcuts()` to UIManager, wire to FileIOManager via callbacks passed in (same pattern as menu bar)

3. **Should ImportQueue post to EventBus or MainThreadQueue?**
   - What we know: Phase 1.3 creates MainThreadQueue for worker→main communication
   - What's unclear: ImportQueue completion events - EventBus or MainThreadQueue?
   - Recommendation: MainThreadQueue for thread-safety (import worker posts to main thread), then main thread publishes ModelImportedEvent to EventBus

4. **Where should workspace state save/restore live?**
   - What we know: `saveWorkspaceState()` saves window size, panel visibility, last model ID to Config
   - What's unclear: Who orchestrates saving? Application on shutdown? ConfigManager?
   - Recommendation: Application::shutdown() calls `configManager->saveWorkspaceState()`, ConfigManager reads from UIManager and writes to Config singleton

5. **How to handle relaunchApp() which needs to quit Application?**
   - What we know: ConfigManager needs to trigger app relaunch on UI scale change
   - What's unclear: ConfigManager can't call Application::quit() directly (no reference)
   - Recommendation: ConfigManager publishes RestartRequestedEvent, Application subscribes and calls quit() + relaunch

## Sources

### Primary (HIGH confidence)
- Direct source code analysis of /data/DW/src/app/application.h (142 lines)
- Direct source code analysis of /data/DW/src/app/application.cpp (1,071 lines)
- Direct source code analysis of /data/DW/src/ui/ui_manager.h (75 lines)
- Direct source code analysis of /data/DW/src/core/events/event_bus.h (85 lines)
- Direct source code analysis of all panel headers (7 files analyzed for constructor signatures)
- Direct source code analysis of /data/DW/src/core/config/config.h (185 lines)
- Project ROADMAP.md Phase 1.4 specification

### Secondary (MEDIUM confidence)
- [How to Refactor a God Class: Architectural Decomposition and Dependency Control](https://www.in-com.com/blog/how-to-refactor-a-god-class-architectural-decomposition-and-dependency-control/) - Responsibility-based splitting strategies
- [How to refactor the God object class antipattern](https://www.theserverside.com/tip/How-to-refactor-the-God-object-antipattern) - Incremental decomposition patterns
- [Refactoring a monolith to microservices](https://microservices.io/refactoring/) - Strangler Fig pattern for incremental extraction
- [How to Refactor Complex Codebases](https://www.freecodecamp.org/news/how-to-refactor-complex-codebases/) - Safe refactoring practices
- [Dependency Injection in C++](https://softwarepatternslexicon.com/cpp/creational-patterns-in-c/dependency-injection/) - Constructor injection patterns
- [C++ Manager initialization order lifecycle](https://www.modernescpp.com/index.php/c-20-static-initialization-order-fiasco/) - Two-phase initialization to avoid SIOF
- [Object Lifetime Manager Pattern](https://adtmag.com/articles/2000/02/29/object-lifetime-manager-a-complementary-pattern-for-controlling-object-creation-and-destruction.aspx) - Shutdown ordering patterns

### Tertiary (LOW confidence - marked for validation)
- None - all research based on direct source code analysis or established patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Using project's existing dependencies, no new libraries
- Architecture: HIGH - Patterns verified against existing EventBus/MainThreadQueue implementations and source code analysis
- Pitfalls: HIGH - Derived from complete analysis of all 1,071 lines of application.cpp and all 7 panel constructors
- Code examples: HIGH - All examples based on actual project source code structure

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (30 days - stable domain, not rapidly evolving)

---

## Critical Findings for Planner

1. **EXISTING OVERLAP:** `src/ui/ui_manager.h` already exists (75 lines) handling ImGui frame/menu/docking. MUST extend it (move to `src/managers/`), NOT create duplicate.

2. **INITIALIZATION ORDER CRITICAL:** 15 subsystems with dependencies:
   - Core: EventBus, Database
   - Business: LibraryManager, ProjectManager, Workspace, ThumbnailGenerator, ImportQueue
   - Managers: UIManager (needs business systems), FileIOManager (needs business + UI), ConfigManager (needs UI)
   - Order violation = segfault at startup

3. **CALLBACK WEB:** 13 callbacks connect panels to Application methods. Must migrate to EventBus or manager methods:
   - LibraryPanel: `onModelSelected` (line 223), `onModelOpened` (line 233)
   - ProjectPanel: `onModelSelected` (line 235), `onOpenProject` (line 252), `onSaveProject` (line 254)
   - PropertiesPanel: `onMeshModified` (line 237), `onColorChanged` (line 245)
   - StartPage: `onNewProject` (line 198), `onOpenProject` (line 202), `onImportModel` (line 203), `onOpenRecentProject` (line 207)

4. **VISIBILITY STATE:** 7 boolean flags for panel visibility currently in Application, config save/restore depends on them - must move to UIManager as single source of truth.

5. **SHUTDOWN ORDER:** Must preserve order: ConfigWatcher/Dialogs → Panels → Core systems → ImportQueue (joins thread) → EventBus (last). Use explicit shutdown methods, not destructor order.

6. **FILE SIZE TARGET:** Application.cpp: 1,071 → ~300 lines (70% reduction). UIManager: ~350 lines. FileIOManager: ~250 lines. ConfigManager: ~100 lines. Total extracted: ~700 lines.
