---
phase: 01.4-godclass
plan: 02
type: execute
wave: 2
depends_on: ["1.4-01"]
files_modified:
  - src/managers/file_io_manager.h
  - src/managers/file_io_manager.cpp
  - src/app/application.h
  - src/app/application.cpp
  - src/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Import model via file dialog works identically to before (enqueues to ImportQueue)"
    - "Export model saves mesh to file with success/error dialog"
    - "New/Open/Save project operations work identically"
    - "Drag-and-drop file import filters by supported extensions and enqueues"
    - "Recent project opening works (searches DB, creates if not found)"
    - "Completed imports trigger thumbnail generation, library refresh, and mesh focus"
    - "All 387+ existing tests pass with zero regressions"
  artifacts:
    - path: "src/managers/file_io_manager.h"
      provides: "FileIOManager class for all file I/O orchestration"
      min_lines: 40
    - path: "src/managers/file_io_manager.cpp"
      provides: "Implementation of import, export, project operations"
      min_lines: 200
    - path: "src/app/application.cpp"
      provides: "Further reduced Application delegating file I/O to FileIOManager"
  key_links:
    - from: "src/app/application.cpp"
      to: "src/managers/file_io_manager.h"
      via: "m_fileIOManager member, delegation calls"
      pattern: "m_fileIOManager->"
    - from: "src/managers/file_io_manager.cpp"
      to: "src/core/import/import_queue.h"
      via: "ImportQueue pointer for enqueueing imports"
      pattern: "m_importQueue->"
    - from: "src/managers/file_io_manager.cpp"
      to: "src/core/library/library_manager.h"
      via: "LibraryManager pointer for mesh loading and model queries"
      pattern: "m_libraryManager->"
    - from: "src/app/application.cpp"
      to: "src/managers/ui_manager.h"
      via: "Panel access for callback wiring and import completion handling"
      pattern: "m_uiManager->"
---

<objective>
Extract FileIOManager from Application: move all file I/O orchestration (import, export, project new/open/save, drag-and-drop, completed import processing, recent project opening) into a focused FileIOManager class.

Purpose: Second extraction step. FileIOManager removes ~250 lines of file operation orchestration from Application. After this plan, Application no longer handles any file I/O directly -- it delegates to FileIOManager, which coordinates between LibraryManager, ProjectManager, ImportQueue, and FileDialog.

Output: src/managers/file_io_manager.h, src/managers/file_io_manager.cpp, further-reduced application.h/.cpp
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01.4-godclass/1.4-RESEARCH.md
@.planning/phases/01.4-godclass/1.4-01-SUMMARY.md

@src/app/application.h
@src/app/application.cpp
@src/managers/ui_manager.h
@src/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FileIOManager class</name>
  <files>src/managers/file_io_manager.h, src/managers/file_io_manager.cpp</files>
  <action>
**src/managers/file_io_manager.h:**

Create a focused class that orchestrates all file I/O operations. FileIOManager does NOT own the subsystems it coordinates -- it receives raw pointers via constructor injection.

```cpp
#pragma once
#include <memory>
#include <vector>
#include <string>
#include <functional>
#include "../core/types.h"

namespace dw {

class EventBus;
class Database;
class LibraryManager;
class ProjectManager;
class ImportQueue;
class Workspace;
class FileDialog;
class ThumbnailGenerator;
class ViewportPanel;
class PropertiesPanel;
class LibraryPanel;

class FileIOManager {
public:
    FileIOManager(EventBus* eventBus,
                  Database* database,
                  LibraryManager* libraryManager,
                  ProjectManager* projectManager,
                  ImportQueue* importQueue,
                  Workspace* workspace,
                  FileDialog* fileDialog,
                  ThumbnailGenerator* thumbnailGenerator);
    ~FileIOManager();

    // Import/Export
    void importModel();
    void exportModel();
    void onFilesDropped(const std::vector<std::string>& paths);
    void processCompletedImports(ViewportPanel* viewport,
                                 PropertiesPanel* properties,
                                 LibraryPanel* library,
                                 std::function<void(bool)> setShowStartPage);

    // Project operations
    void newProject(std::function<void(bool)> setShowStartPage);
    void openProject(std::function<void(bool)> setShowStartPage);
    void saveProject();
    void openRecentProject(const Path& path, std::function<void(bool)> setShowStartPage);

private:
    EventBus* m_eventBus;
    Database* m_database;
    LibraryManager* m_libraryManager;
    ProjectManager* m_projectManager;
    ImportQueue* m_importQueue;
    Workspace* m_workspace;
    FileDialog* m_fileDialog;
    ThumbnailGenerator* m_thumbnailGenerator;
};

} // namespace dw
```

Key design decisions:
- processCompletedImports takes panel pointers and a setShowStartPage callback because it needs to interact with UI panels (refresh library, set mesh on viewport, set mesh on properties). These are passed as parameters rather than stored to keep FileIOManager decoupled from UIManager.
- newProject/openProject/openRecentProject take a `setShowStartPage` callback to hide the start page after project creation. This avoids FileIOManager needing to know about UIManager's visibility state.
- FileIOManager does NOT own any of the subsystems it coordinates -- all received via constructor injection as raw pointers.
- FileIOManager does NOT store panel pointers as members. They are passed per-call where needed. This prevents lifetime issues and keeps the dependency minimal.

**src/managers/file_io_manager.cpp:**

Move these methods from application.cpp almost verbatim, updating member references:

1. `importModel()` -- from application.cpp onImportModel() (lines 535-553). Uses m_fileDialog and m_importQueue.

2. `exportModel()` -- from application.cpp onExportModel() (lines 555-579). Uses m_workspace to get focused mesh, m_fileDialog for save dialog.

3. `onFilesDropped()` -- from application.cpp (lines 675-694). Uses LoaderFactory::isSupported() and m_importQueue.

4. `processCompletedImports()` -- from application.cpp (lines 696-728). Uses m_importQueue->pollCompleted(), m_thumbnailGenerator, m_libraryManager for thumbnail generation, and the panel pointers passed as parameters for UI updates (library refresh, viewport/properties mesh setting).

5. `newProject()` -- from application.cpp onNewProject() (lines 581-585). Uses m_projectManager->create().

6. `openProject()` -- from application.cpp onOpenProject() (lines 587-624). Uses m_fileDialog, m_projectManager.

7. `saveProject()` -- from application.cpp onSaveProject() (lines 626-654). Uses m_projectManager, m_fileDialog.

8. `openRecentProject()` -- from application.cpp onOpenRecentProject() (lines 730-758). Uses m_projectManager.

All methods that manipulate m_showStartPage should instead call the `setShowStartPage(false)` callback.

Keep the same error handling (MessageDialog::warning, MessageDialog::error, MessageDialog::info).

Follow project conventions: #pragma once, namespace dw, m_ prefix, snake_case files.
  </action>
  <verify>
Verify files exist and have correct structure:
```bash
test -f src/managers/file_io_manager.h && test -f src/managers/file_io_manager.cpp && echo "Files exist"
wc -l src/managers/file_io_manager.h src/managers/file_io_manager.cpp
```
  </verify>
  <done>
src/managers/file_io_manager.h exists with FileIOManager class owning no subsystems but coordinating between EventBus, Database, LibraryManager, ProjectManager, ImportQueue, Workspace, FileDialog, and ThumbnailGenerator. src/managers/file_io_manager.cpp exists with all 8 file I/O methods extracted from application.cpp.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate FileIOManager into Application</name>
  <files>src/app/application.h, src/app/application.cpp, src/CMakeLists.txt</files>
  <action>
**src/CMakeLists.txt:**
Add `managers/file_io_manager.cpp` to DW_SOURCES, after `managers/ui_manager.cpp`:
```
    managers/file_io_manager.cpp
```

**src/app/application.h:**
1. Add forward declaration for FileIOManager (if not already present)
2. Add `std::unique_ptr<FileIOManager> m_fileIOManager;` member
3. Remove method declarations that moved to FileIOManager: onImportModel, onExportModel, onNewProject, onOpenProject, onSaveProject, onFilesDropped, processCompletedImports, onOpenRecentProject
4. Keep onModelSelected (business logic that stays in Application)

**src/app/application.cpp:**
1. Add `#include "../managers/file_io_manager.h"`
2. Remove includes only needed by FileIOManager methods (model_exporter.h, import_task.h, loader_factory.h) -- only if Application no longer references them directly. Check carefully.

**In Application::init():**
After UIManager creation and init, create FileIOManager:
```cpp
m_fileIOManager = std::make_unique<FileIOManager>(
    m_eventBus.get(),
    m_database.get(),
    m_libraryManager.get(),
    m_projectManager.get(),
    m_importQueue.get(),
    m_workspace.get(),
    m_uiManager->fileDialog(),
    m_thumbnailGenerator.get()
);
```

Update StartPage callbacks (they were set up in UIManager::init, but the file operation targets now live in FileIOManager). Two approaches:
- Option A: UIManager::init() sets up StartPage callbacks with stored functors (like menu bar)
- Option B: Application wires StartPage callbacks after UIManager::init()

Use Option B (Application wires StartPage after both managers exist):
```cpp
// Wire StartPage callbacks to FileIOManager
m_uiManager->startPage()->setOnNewProject([this]() {
    m_fileIOManager->newProject([this](bool show) { m_uiManager->setShowStartPage(show); });
});
m_uiManager->startPage()->setOnOpenProject([this]() {
    m_fileIOManager->openProject([this](bool show) { m_uiManager->setShowStartPage(show); });
});
m_uiManager->startPage()->setOnImportModel([this]() {
    m_fileIOManager->importModel();
    m_uiManager->setShowStartPage(false);
});
m_uiManager->startPage()->setOnOpenRecentProject([this](const Path& path) {
    m_fileIOManager->openRecentProject(path, [this](bool show) { m_uiManager->setShowStartPage(show); });
});
```

This means UIManager::init() should NOT set up StartPage callbacks. If it does from Plan 01, remove them from UIManager::init() and wire them here instead.

**In Application::render():**
Update the callback lambdas passed to UIManager's renderMenuBar and handleKeyboardShortcuts to use FileIOManager:
```cpp
m_uiManager->renderMenuBar(
    [this]() { m_fileIOManager->importModel(); },
    [this]() { m_fileIOManager->exportModel(); },
    [this]() { m_fileIOManager->newProject([this](bool show) { m_uiManager->setShowStartPage(show); }); },
    [this]() { m_fileIOManager->openProject([this](bool show) { m_uiManager->setShowStartPage(show); }); },
    [this]() { m_fileIOManager->saveProject(); },
    [this]() { quit(); },
    [this]() { spawnSettingsApp(); },
    m_uiManager->lightingDialog()
);
```
Same pattern for handleKeyboardShortcuts.

**In Application::processEvents():**
Update file drop handling:
```cpp
if (!droppedFiles.empty()) {
    m_fileIOManager->onFilesDropped(droppedFiles);
}
```

**In Application::update():**
Replace processCompletedImports() call with delegation:
```cpp
m_fileIOManager->processCompletedImports(
    m_uiManager->viewportPanel(),
    m_uiManager->propertiesPanel(),
    m_uiManager->libraryPanel(),
    [this](bool show) { m_uiManager->setShowStartPage(show); }
);
```

**Delete these methods from application.cpp:**
- onImportModel() (lines ~535-553)
- onExportModel() (lines ~555-579)
- onNewProject() (lines ~581-585)
- onOpenProject() (lines ~587-624)
- onSaveProject() (lines ~626-654)
- onFilesDropped() (lines ~675-694)
- processCompletedImports() (lines ~696-728)
- onOpenRecentProject() (lines ~730-758)

**In Application::shutdown():**
Add FileIOManager reset before UIManager reset:
```cpp
m_fileIOManager.reset();
m_uiManager.reset();
```
  </action>
  <verify>
Build and test:
```bash
cd /data/DW/build && cmake .. && cmake --build . 2>&1 | tail -20
cd /data/DW/build && ctest --output-on-failure 2>&1 | tail -30
```
All tests must pass. Measure line counts:
```bash
wc -l src/app/application.cpp src/app/application.h src/managers/file_io_manager.cpp src/managers/file_io_manager.h src/managers/ui_manager.cpp src/managers/ui_manager.h
```
Application.cpp should now be ~450-500 lines (down from ~700-750 after Plan 01).
  </verify>
  <done>
Application.cpp compiles and links with FileIOManager delegation. All 387+ existing tests pass. Application.cpp is further reduced by ~250 lines. All file I/O operations (import, export, new/open/save project, drag-drop, completed imports, recent projects) are delegated to FileIOManager. Application only retains lifecycle, event processing, onModelSelected business logic, config management, and shutdown.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero errors and zero new warnings
2. All existing tests pass (387+)
3. Application.cpp reduced by additional ~250 lines
4. src/managers/file_io_manager.h and .cpp exist and follow project conventions
5. No file I/O logic remains directly in Application (except delegation calls)
6. Import, export, project operations all route through FileIOManager
</verification>

<success_criteria>
- Application.cpp at ~450-500 lines (cumulative reduction of ~550-600 from original 1,080)
- FileIOManager handles all 8 file I/O methods
- No behavioral changes -- import, export, project ops work identically
- Build compiles and links successfully
- All 387+ tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/01.4-godclass/1.4-02-SUMMARY.md`
</output>
