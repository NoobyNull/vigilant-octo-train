---
phase: 01.4-godclass
plan: 03
type: execute
wave: 3
depends_on: ["1.4-02"]
files_modified:
  - src/managers/config_manager.h
  - src/managers/config_manager.cpp
  - src/app/application.h
  - src/app/application.cpp
  - src/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Config file hot-reload works: editing config file applies theme, render settings, log level changes live"
    - "UI scale change triggers restart popup via UIManager"
    - "Workspace state is saved on shutdown: window size, maximized state, panel visibility, last selected model"
    - "Settings app spawns correctly on both Linux and Windows"
    - "Relaunch app works (saves config, spawns new instance, quits current)"
    - "Application.cpp is under 400 lines (target ~300-350)"
    - "All 387+ existing tests pass with zero regressions"
  artifacts:
    - path: "src/managers/config_manager.h"
      provides: "ConfigManager class for config watching, applying, workspace state, settings spawn, relaunch"
      min_lines: 30
    - path: "src/managers/config_manager.cpp"
      provides: "Implementation of config management methods"
      min_lines: 100
    - path: "src/app/application.cpp"
      provides: "Final thin coordinator Application under 400 lines"
  key_links:
    - from: "src/app/application.cpp"
      to: "src/managers/config_manager.h"
      via: "m_configManager member, delegation calls"
      pattern: "m_configManager->"
    - from: "src/managers/config_manager.cpp"
      to: "src/managers/ui_manager.h"
      via: "UIManager pointer for viewport render settings, restart popup, visibility state"
      pattern: "m_uiManager->"
    - from: "src/managers/config_manager.cpp"
      to: "src/core/config/config.h"
      via: "Config singleton for reading/writing settings"
      pattern: "Config::instance\\(\\)"
---

<objective>
Extract ConfigManager from Application: move config file watching, config applying (theme, render settings, log level), UI scale restart detection, workspace state saving, settings app spawning, and app relaunch into a focused ConfigManager class. After this plan, Application.cpp is under 400 lines -- a thin coordinator owning managers and running the event loop.

Purpose: Final extraction step. ConfigManager removes ~100-150 lines of config-related code from Application. This completes the god class decomposition, achieving the Phase 1.4 goal of reducing Application.cpp from 1,080 to under 400 lines.

Output: src/managers/config_manager.h, src/managers/config_manager.cpp, final slim application.h/.cpp under 400 lines
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01.4-godclass/1.4-RESEARCH.md
@.planning/phases/01.4-godclass/1.4-01-SUMMARY.md
@.planning/phases/01.4-godclass/1.4-02-SUMMARY.md

@src/app/application.h
@src/app/application.cpp
@src/managers/ui_manager.h
@src/managers/file_io_manager.h
@src/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConfigManager class</name>
  <files>src/managers/config_manager.h, src/managers/config_manager.cpp</files>
  <action>
**src/managers/config_manager.h:**

ConfigManager handles all config-related responsibilities extracted from Application. Unlike UIManager and FileIOManager, ConfigManager owns the ConfigWatcher and coordinates config reload, workspace state persistence, and app relaunch.

```cpp
#pragma once
#include <memory>
#include <functional>
#include "../core/types.h"

struct SDL_Window;

namespace dw {

class EventBus;
class UIManager;
class ConfigWatcher;
class ViewportPanel;
class LibraryPanel;

class ConfigManager {
public:
    ConfigManager(EventBus* eventBus, UIManager* uiManager);
    ~ConfigManager();

    // Initialize config watching
    void init(SDL_Window* window);

    // Call each frame to poll config watcher
    void poll(uint64_t ticksMs);

    // Shutdown (stops watcher)
    void shutdown();

    // Save workspace state (window size, panel visibility, last model)
    void saveWorkspaceState();

    // Spawn external settings app
    void spawnSettingsApp();

    // Relaunch the application (save config, spawn new instance, quit)
    void relaunchApp();

    // Set quit callback (for relaunch to quit current instance)
    void setQuitCallback(std::function<void()> cb) { m_quitCallback = std::move(cb); }

private:
    void onConfigFileChanged();
    void applyConfig();

    EventBus* m_eventBus;
    UIManager* m_uiManager;
    SDL_Window* m_window = nullptr;

    std::unique_ptr<ConfigWatcher> m_configWatcher;
    float m_lastAppliedUiScale = 1.0f;
    std::function<void()> m_quitCallback;
};

} // namespace dw
```

Key design decisions:
- ConfigManager receives UIManager* because applyConfig() needs to update viewport render settings and trigger restart popup. This is an acceptable coupling since ConfigManager specifically exists to coordinate config changes with the UI.
- ConfigManager owns ConfigWatcher (moved from Application).
- m_window needed for saveWorkspaceState() (SDL_GetWindowFlags, SDL_GetWindowSize).
- m_quitCallback provided by Application for relaunchApp() to trigger Application::quit().
- m_lastAppliedUiScale moved from Application to ConfigManager.

**src/managers/config_manager.cpp:**

Move these methods from application.cpp:

1. `onConfigFileChanged()` -- from application.cpp (lines ~843-847). Calls Config::instance().load() then applyConfig().

2. `applyConfig()` -- from application.cpp (lines ~849-884). Applies theme based on config index, updates viewport render settings via m_uiManager->viewportPanel(), updates log level, checks UI scale change and triggers m_uiManager->showRestartPopup().

3. `spawnSettingsApp()` -- from application.cpp (lines ~886-916). Platform-specific code to spawn dw_settings. Direct port.

4. `relaunchApp()` -- from application.cpp (lines ~918-941). Saves config, spawns new instance, calls m_quitCallback(). Direct port but replace quit() with m_quitCallback().

5. `saveWorkspaceState()` -- from application.cpp (lines ~999-1029). Reads window state from SDL, reads panel visibility from m_uiManager (showViewport(), showLibrary(), etc.), reads last selected model from m_uiManager->libraryPanel(), writes to Config singleton.

6. `init()` -- creates ConfigWatcher, sets callback, watches config file, stores initial UI scale.

7. `poll()` -- calls m_configWatcher->poll(ticksMs).

8. `shutdown()` -- resets m_configWatcher.

Include platform headers conditionally:
```cpp
#ifdef _WIN32
    #include <shellapi.h>
    #include <windows.h>
#elif defined(__linux__)
    #include <unistd.h>
#endif
```

These platform includes can be removed from application.cpp after extraction.

Follow project conventions: #pragma once, namespace dw, m_ prefix, snake_case files.
  </action>
  <verify>
Verify files exist and have correct structure:
```bash
test -f src/managers/config_manager.h && test -f src/managers/config_manager.cpp && echo "Files exist"
wc -l src/managers/config_manager.h src/managers/config_manager.cpp
```
  </verify>
  <done>
src/managers/config_manager.h exists with ConfigManager class declaration. src/managers/config_manager.cpp exists with implementations of onConfigFileChanged, applyConfig, spawnSettingsApp, relaunchApp, saveWorkspaceState, init, poll, and shutdown.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate ConfigManager, finalize Application as thin coordinator</name>
  <files>src/app/application.h, src/app/application.cpp, src/CMakeLists.txt</files>
  <action>
**src/CMakeLists.txt:**
Add `managers/config_manager.cpp` to DW_SOURCES, after file_io_manager:
```
    managers/config_manager.cpp
```

**src/app/application.h:**
1. Add forward declaration for ConfigManager
2. Add `std::unique_ptr<ConfigManager> m_configManager;` member
3. Remove forward declarations now owned by ConfigManager: ConfigWatcher
4. Remove method declarations that moved to ConfigManager: onConfigFileChanged, applyConfig, spawnSettingsApp, relaunchApp, saveWorkspaceState
5. Remove members that moved to ConfigManager: m_configWatcher, m_lastAppliedUiScale
6. Remove platform-specific includes if they were in the header (they're in .cpp only, so likely no change needed)

After all removals, Application.h should have:
- Forward declarations: EventBus, Database, LibraryManager, ProjectManager, Workspace, ThumbnailGenerator, ImportQueue, UIManager, FileIOManager, ConfigManager
- Public: constructor, destructor, init(), run(), quit(), isRunning(), getWindow(), eventBus()
- Private: processEvents(), update(), render(), shutdown(), onModelSelected()
- Members: m_window, m_glContext, m_running, m_initialized, plus unique_ptrs for all owned subsystems and 3 managers
- Constants: DEFAULT_WIDTH, DEFAULT_HEIGHT, WINDOW_TITLE

**src/app/application.cpp:**
1. Add `#include "../managers/config_manager.h"`
2. Remove includes only needed by ConfigManager: config_watcher.h, platform headers (windows.h, shellapi.h, unistd.h)

**In Application::init():**
After FileIOManager creation, create ConfigManager:
```cpp
m_configManager = std::make_unique<ConfigManager>(
    m_eventBus.get(),
    m_uiManager.get()
);
m_configManager->init(m_window);
m_configManager->setQuitCallback([this]() { quit(); });
```

Remove the ConfigWatcher setup code that was previously in init() (m_configWatcher creation, watch, m_lastAppliedUiScale).

**In Application::render():**
Update the renderMenuBar and handleKeyboardShortcuts calls -- the spawnSettingsApp callback now goes through ConfigManager:
```cpp
[this]() { m_configManager->spawnSettingsApp(); }
```

Also update the relaunch callback on UIManager (if it was set up):
```cpp
m_uiManager->setRelaunchCallback([this]() { m_configManager->relaunchApp(); });
```

**In Application::update():**
Replace config watcher poll with ConfigManager poll:
```cpp
void Application::update() {
    m_fileIOManager->processCompletedImports(
        m_uiManager->viewportPanel(),
        m_uiManager->propertiesPanel(),
        m_uiManager->libraryPanel(),
        [this](bool show) { m_uiManager->setShowStartPage(show); }
    );
    m_configManager->poll(SDL_GetTicks64());
}
```

**In Application::shutdown():**
Replace saveWorkspaceState() and m_configWatcher.reset() with ConfigManager calls:
```cpp
void Application::shutdown() {
    if (!m_initialized) return;

    // Save workspace state before destroying anything
    m_configManager->saveWorkspaceState();

    // Shutdown managers in reverse creation order
    m_configManager.reset();
    m_fileIOManager.reset();
    m_uiManager.reset();

    // Shutdown core systems
    m_importQueue.reset();
    m_workspace.reset();
    m_thumbnailGenerator.reset();
    m_projectManager.reset();
    m_libraryManager.reset();
    m_database.reset();
    m_eventBus.reset();

    // SDL/ImGui/OpenGL cleanup
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplSDL2_Shutdown();
    ImGui::DestroyContext();

    if (m_glContext) {
        SDL_GL_DeleteContext(m_glContext);
        m_glContext = nullptr;
    }
    if (m_window) {
        SDL_DestroyWindow(m_window);
        m_window = nullptr;
    }
    SDL_Quit();
    m_initialized = false;
}
```

**Delete these methods from application.cpp:**
- onConfigFileChanged()
- applyConfig()
- spawnSettingsApp()
- relaunchApp()
- saveWorkspaceState()

**Final Application.cpp should contain only:**
1. Constructor/Destructor (~5 lines)
2. init() -- SDL/GL init + manager creation + callback wiring (~180 lines)
3. run() -- main loop (~15 lines)
4. quit() (~3 lines)
5. eventBus() (~3 lines)
6. processEvents() -- SDL event polling (~25 lines)
7. update() -- delegates to managers (~8 lines)
8. render() -- ImGui frame + delegates to UIManager (~35 lines)
9. onModelSelected() -- business logic (~18 lines)
10. shutdown() -- manager and SDL cleanup (~35 lines)

Total: approximately 300-350 lines.

**Final verification:**
After all changes, confirm:
- Application.cpp is under 400 lines (measure with `wc -l`)
- Application.h is clean with only the coordinator interface
- All three managers exist: UIManager, FileIOManager, ConfigManager
- No TODO, FIXME, or temporary code left behind
- All includes are clean (no orphaned includes from moved code)
  </action>
  <verify>
Build and test:
```bash
cd /data/DW/build && cmake .. && cmake --build . 2>&1 | tail -20
cd /data/DW/build && ctest --output-on-failure 2>&1 | tail -30
```
All tests must pass. Measure final line counts:
```bash
echo "=== Final Line Counts ==="
wc -l src/app/application.cpp src/app/application.h
echo "=== Manager Line Counts ==="
wc -l src/managers/ui_manager.cpp src/managers/ui_manager.h src/managers/file_io_manager.cpp src/managers/file_io_manager.h src/managers/config_manager.cpp src/managers/config_manager.h
echo "=== Total ==="
wc -l src/app/application.cpp src/managers/*.cpp src/managers/*.h
```
Application.cpp MUST be under 400 lines. Target is ~300-350.
  </verify>
  <done>
Application.cpp is under 400 lines (target ~300-350). All three managers (UIManager, FileIOManager, ConfigManager) are integrated and working. Application is a thin coordinator: SDL/GL lifecycle, manager creation, event loop, and the single remaining business logic method (onModelSelected). All 387+ tests pass. No behavioral changes from the user's perspective. The god class decomposition is complete.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero errors and zero new warnings
2. All existing tests pass (387+)
3. **Application.cpp is under 400 lines** (Phase 1.4 success criterion)
4. Three managers exist and are properly integrated
5. No config-related logic remains in Application (except delegation)
6. Workspace state saves correctly on shutdown
7. Config hot-reload works through ConfigManager
8. Settings spawn and app relaunch work on current platform
</verification>

<success_criteria>
- Application.cpp under 400 lines (from original 1,080 -- 63%+ reduction)
- ConfigManager handles all config watching, applying, workspace state, settings spawn, relaunch
- Build compiles and links successfully
- All 387+ tests pass with zero regressions
- Phase 1.4 goal achieved: "Application.cpp under 400 lines, all tests pass, no behavioral changes"
</success_criteria>

<output>
After completion, create `.planning/phases/01.4-godclass/1.4-03-SUMMARY.md`
</output>
