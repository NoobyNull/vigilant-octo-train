---
phase: 04-organization-and-graph
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cmake/Dependencies.cmake
  - src/core/database/database.h
  - src/core/database/database.cpp
  - src/core/graph/graph_manager.h
  - src/core/graph/graph_manager.cpp
  - src/CMakeLists.txt
autonomous: true
requirements: [ORG-03]

must_haves:
  truths:
    - "GraphQLite .so is downloaded and bundled with the build"
    - "Database class exposes sqlite3_enable_load_extension and sqlite3_load_extension"
    - "GraphManager loads GraphQLite extension at initialization"
    - "Application starts cleanly with graph support enabled"
    - "Graceful fallback if GraphQLite .so is missing"
  artifacts:
    - path: "src/core/graph/graph_manager.h"
      provides: "GraphManager class for GraphQLite extension lifecycle"
      min_lines: 30
    - path: "src/core/graph/graph_manager.cpp"
      provides: "Extension loading, graph schema init, Cypher query execution"
      min_lines: 50
    - path: "src/core/database/database.h"
      provides: "loadExtension and enableExtensionLoading methods"
      contains: "loadExtension"
    - path: "src/core/database/database.cpp"
      provides: "sqlite3_load_extension wrapper"
      contains: "sqlite3_load_extension"
  key_links:
    - from: "src/core/graph/graph_manager.cpp"
      to: "src/core/database/database.h"
      via: "Database::loadExtension call"
      pattern: "loadExtension"
    - from: "src/core/graph/graph_manager.cpp"
      to: "GraphQLite .so"
      via: "extension path resolution"
      pattern: "graphqlite"
---

<objective>
GraphQLite extension loading and GraphManager foundation

Purpose: Enable Cypher graph query support (ORG-03) by loading the GraphQLite SQLite extension at database initialization. GraphQLite is a C library loaded via sqlite3_load_extension() -- NOT a separate database. All graph data lives in the same SQLite file.

Output: GraphManager class that loads GraphQLite at startup, Database class with extension loading API, CMake fetches GraphQLite .so.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/SUMMARY.md
@.planning/research/ARCHITECTURE.md
@src/core/database/database.h
@src/core/database/database.cpp
@src/core/database/connection_pool.h
@src/CMakeLists.txt
@cmake/Dependencies.cmake
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add extension loading API to Database class and fetch GraphQLite</name>
  <files>
    src/core/database/database.h
    src/core/database/database.cpp
    cmake/Dependencies.cmake
  </files>
  <action>
1. In `database.h`, add two public methods to the Database class:
   ```cpp
   // Enable loading of SQLite extensions (must call before loadExtension)
   bool enableExtensionLoading();

   // Load a SQLite extension from the given path
   // Returns true on success, sets error on failure
   bool loadExtension(const std::string& path, std::string& error);

   // Get raw sqlite3 handle (needed for advanced operations)
   sqlite3* handle() const { return m_db; }
   ```

2. In `database.cpp`, implement:
   ```cpp
   bool Database::enableExtensionLoading() {
       if (!m_db) return false;
       int rc = sqlite3_enable_load_extension(m_db, 1);
       if (rc != SQLITE_OK) {
           log::errorf("Database", "Failed to enable extension loading: %s",
                       sqlite3_errmsg(m_db));
           return false;
       }
       return true;
   }

   bool Database::loadExtension(const std::string& path, std::string& error) {
       if (!m_db) {
           error = "Database not open";
           return false;
       }
       char* errMsg = nullptr;
       int rc = sqlite3_load_extension(m_db, path.c_str(), nullptr, &errMsg);
       if (rc != SQLITE_OK) {
           error = errMsg ? errMsg : "Unknown error loading extension";
           if (errMsg) sqlite3_free(errMsg);
           return false;
       }
       return true;
   }
   ```

3. In `cmake/Dependencies.cmake`, add compile definition to enable extension loading for the fetched SQLite:
   After `target_compile_definitions(sqlite3 PRIVATE SQLITE_ENABLE_FTS5)` (added in Plan 01), add:
   ```
   target_compile_definitions(sqlite3 PRIVATE SQLITE_ENABLE_LOAD_EXTENSION)
   ```
   Note: This flag is needed to enable sqlite3_load_extension() in the amalgamation build. If Plan 01 hasn't been executed yet, add both flags together.

4. For GraphQLite binary acquisition: GraphQLite v0.3.5 (Feb 2026) provides pre-built shared libraries. Add a CMake ExternalProject or FetchContent step to download the appropriate .so/.dll at configure time.

   Add to `cmake/Dependencies.cmake`:
   ```cmake
   # GraphQLite - SQLite extension for Cypher graph queries
   # Downloaded as pre-built shared library, loaded at runtime via sqlite3_load_extension()
   set(GRAPHQLITE_VERSION "0.3.5")
   if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
       set(GRAPHQLITE_PLATFORM "linux-x86_64")
       set(GRAPHQLITE_LIB "graphqlite.so")
   elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
       set(GRAPHQLITE_PLATFORM "win-x86_64")
       set(GRAPHQLITE_LIB "graphqlite.dll")
   elseif(CMAKE_SYSTEM_NAME STREQUAL "Darwin")
       set(GRAPHQLITE_PLATFORM "macos-x86_64")
       set(GRAPHQLITE_LIB "graphqlite.dylib")
   endif()

   FetchContent_Declare(
       graphqlite
       URL https://github.com/nicholasgasior/graphqlite/releases/download/v${GRAPHQLITE_VERSION}/graphqlite-${GRAPHQLITE_PLATFORM}.tar.gz
       DOWNLOAD_NO_EXTRACT FALSE
   )
   FetchContent_MakeAvailable(graphqlite)

   # Copy GraphQLite .so to build output directory so it's next to the executable
   add_custom_command(TARGET digital_workshop POST_BUILD
       COMMAND ${CMAKE_COMMAND} -E copy_if_different
           "${graphqlite_SOURCE_DIR}/${GRAPHQLITE_LIB}"
           "$<TARGET_FILE_DIR:digital_workshop>/${GRAPHQLITE_LIB}"
       COMMENT "Copying GraphQLite extension to build directory"
   )
   ```

   IMPORTANT: The exact GitHub URL for GraphQLite must be verified at implementation time. The URL pattern above is a best-guess based on research. The implementor MUST:
   - Visit https://github.com/colliery-io/graphqlite/releases (or nicholasgasior/graphqlite)
   - Verify the actual release asset filenames and URLs
   - If the URL is wrong or the release structure differs, adapt the FetchContent accordingly
   - If pre-built binaries are not available, build from source (the repo is C, should compile easily with CMake)
   - As a FALLBACK: if GraphQLite cannot be fetched, make the extension optional -- the app should work without it, just log a warning. Define a CMake option `DW_ENABLE_GRAPHQLITE` defaulting to ON.

   Note: The `add_custom_command(TARGET digital_workshop ...)` line must go in `src/CMakeLists.txt` after the target is defined, not in Dependencies.cmake. Move the copy command there.
  </action>
  <verify>
Build: `cd /data/DW/build && cmake .. 2>&1 | tail -20` -- should configure without errors (or with a clear warning if GraphQLite URL needs adjustment). `make -j$(nproc)` compiles. Check that database.h has loadExtension method.
  </verify>
  <done>Database class has enableExtensionLoading() and loadExtension() methods. SQLITE_ENABLE_LOAD_EXTENSION flag set. GraphQLite download configured in CMake (or marked as optional if URL unavailable). Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Create GraphManager class with extension lifecycle and graph schema</name>
  <files>
    src/core/graph/graph_manager.h
    src/core/graph/graph_manager.cpp
    src/CMakeLists.txt
  </files>
  <action>
1. Create `src/core/graph/graph_manager.h`:
   ```cpp
   #pragma once

   #include <string>
   #include <vector>
   #include "../database/database.h"
   #include "../types.h"

   namespace dw {

   // GraphManager wraps GraphQLite extension lifecycle.
   // GraphQLite adds Cypher query support to SQLite via sqlite3_load_extension().
   // All graph data lives in the same SQLite database -- no separate graph DB.
   class GraphManager {
   public:
       explicit GraphManager(Database& db);

       // Initialize: load extension + create graph schema
       // Returns false if extension not found (non-fatal, app works without)
       bool initialize(const Path& extensionDir);

       // Is GraphQLite loaded and available?
       bool isAvailable() const { return m_available; }

       // Execute a Cypher query via GraphQLite's cypher() SQL function
       // Returns true on success, error string on failure
       bool executeCypher(const std::string& cypher, std::string& error);

       // Query that returns results as vector of string vectors (rows x cols)
       struct QueryResult {
           std::vector<std::string> columns;
           std::vector<std::vector<std::string>> rows;
       };
       std::optional<QueryResult> queryCypher(const std::string& cypher);

       // Graph schema initialization (creates node/edge types)
       bool initializeSchema();

   private:
       Database& m_db;
       bool m_available = false;
   };

   } // namespace dw
   ```

2. Create `src/core/graph/graph_manager.cpp`:
   - `initialize()`:
     a. Call `m_db.enableExtensionLoading()`
     b. Construct extension path: `extensionDir / "graphqlite"` (without extension -- sqlite3_load_extension auto-appends .so/.dll/.dylib)
     c. Call `m_db.loadExtension(path, error)`
     d. If loading fails, log warning "GraphQLite extension not found at {path} -- graph queries disabled" and set m_available = false, return false
     e. If loading succeeds, set m_available = true, call initializeSchema(), return true
     f. After loading, disable extension loading for security: call `sqlite3_enable_load_extension(m_db.handle(), 0)` directly

   - `initializeSchema()`:
     GraphQLite uses SQL functions like `cypher()` to execute Cypher queries. The graph schema is created via Cypher DDL:
     ```cpp
     executeCypher("CREATE NODE TABLE IF NOT EXISTS Model(id INT64, name STRING, hash STRING, PRIMARY KEY(id))", error);
     executeCypher("CREATE NODE TABLE IF NOT EXISTS Category(id INT64, name STRING, PRIMARY KEY(id))", error);
     executeCypher("CREATE NODE TABLE IF NOT EXISTS Project(id INT64, name STRING, PRIMARY KEY(id))", error);
     executeCypher("CREATE REL TABLE IF NOT EXISTS BELONGS_TO(FROM Model TO Category)", error);
     executeCypher("CREATE REL TABLE IF NOT EXISTS CONTAINS(FROM Project TO Model)", error);
     executeCypher("CREATE REL TABLE IF NOT EXISTS RELATED_TO(FROM Model TO Model)", error);
     ```
     Note: The exact Cypher DDL syntax depends on GraphQLite's implementation. If GraphQLite uses a different syntax for schema creation, adapt accordingly. Check GraphQLite docs/README at implementation time.

   - `executeCypher()`:
     GraphQLite typically exposes a `cypher()` SQL function. Execute via:
     ```cpp
     std::string sql = "SELECT cypher('" + escapedCypher + "')";
     return m_db.execute(sql);
     ```
     Or it may use a virtual table approach. Check GraphQLite's README for the exact API. The key patterns to look for:
     - `SELECT * FROM cypher('graph_name', $$ MATCH ... $$)` (PostgreSQL-style)
     - `SELECT cypher('MATCH ...')` (function-style)
     Adapt the implementation to match the actual API.

   - `queryCypher()`:
     Similar to executeCypher but uses prepare/step/getXxx to collect results.

3. In `src/CMakeLists.txt`, add the new source files to DW_SOURCES:
   ```
   # Graph
   core/graph/graph_manager.cpp
   ```
   Add after the `# Library` section.

4. If GraphQLite copy command was placed in Dependencies.cmake in Task 1, move the POST_BUILD copy command to `src/CMakeLists.txt` after the `add_executable(digital_workshop ...)` line, since the target must exist before referencing it.
  </action>
  <verify>
Build: `cd /data/DW/build && cmake .. && make -j$(nproc)` compiles cleanly. The GraphManager class compiles. If GraphQLite .so is not available at runtime, the app should still start (graceful degradation).
  </verify>
  <done>GraphManager class exists with initialize(), isAvailable(), executeCypher(), queryCypher(), and initializeSchema(). Extension loading is gated behind availability check. CMake source list updated. App compiles and starts cleanly regardless of whether GraphQLite .so is present.</done>
</task>

</tasks>

<verification>
1. `cd /data/DW/build && cmake .. && make -j$(nproc)` compiles cleanly
2. `./build/tests/dw_tests` -- all existing tests pass
3. `grep "loadExtension" src/core/database/database.h` confirms extension API
4. `ls src/core/graph/graph_manager.h src/core/graph/graph_manager.cpp` confirms new files
5. GraphManager compiles with graceful degradation when extension unavailable
</verification>

<success_criteria>
- Database class has enableExtensionLoading() and loadExtension() methods
- GraphManager loads GraphQLite at init with graceful fallback
- Graph schema created via Cypher DDL (Model, Category, Project nodes; BELONGS_TO, CONTAINS, RELATED_TO edges)
- CMake configured to fetch/bundle GraphQLite .so (or marked optional)
- Application starts cleanly with or without GraphQLite
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-organization-and-graph/04-02-SUMMARY.md`
</output>
