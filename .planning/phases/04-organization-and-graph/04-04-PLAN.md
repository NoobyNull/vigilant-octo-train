---
phase: 04-organization-and-graph
plan: 04
type: execute
wave: 2
depends_on: [04-01, 04-03]
files_modified:
  - src/ui/panels/library_panel.h
  - src/ui/panels/library_panel.cpp
  - src/app/application.h
  - src/app/application.cpp
autonomous: false
requirements: [ORG-01, ORG-02, ORG-03, ORG-04, ORG-05]

must_haves:
  truths:
    - "User can assign a model to a 2-level category via the UI"
    - "User can filter the library by category"
    - "User can type a search query and get ranked FTS5 results"
    - "Search updates as user types (debounced)"
    - "GraphManager is wired in Application and initialized at startup"
    - "Category breadcrumb shows when filtering by category"
  artifacts:
    - path: "src/ui/panels/library_panel.h"
      provides: "Category filter sidebar, FTS5 search integration, category assignment UI"
      contains: "m_selectedCategory"
    - path: "src/ui/panels/library_panel.cpp"
      provides: "Category tree rendering, FTS5 search, category assignment dialog"
      min_lines: 100
    - path: "src/app/application.h"
      provides: "GraphManager member, wired to LibraryManager"
      contains: "GraphManager"
    - path: "src/app/application.cpp"
      provides: "GraphManager initialization at startup"
      contains: "graph_manager"
  key_links:
    - from: "src/ui/panels/library_panel.cpp"
      to: "src/core/library/library_manager.h"
      via: "searchModelsFTS and filterByCategory calls"
      pattern: "searchModelsFTS|filterByCategory"
    - from: "src/app/application.cpp"
      to: "src/core/graph/graph_manager.h"
      via: "GraphManager construction and initialization"
      pattern: "GraphManager"
---

<objective>
Category UI, FTS5 search bar, and full Application wiring

Purpose: Complete the user-facing features for Phase 4: category browsing/assignment (ORG-01), full-text search (ORG-02), and wire GraphManager into the application lifecycle (ORG-03/04/05). This plan connects all the infrastructure from Plans 01-03 to the UI.

Output: Library panel with category filter, FTS5 search, category assignment. Application wires GraphManager at startup.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-organization-and-graph/04-01-SUMMARY.md
@.planning/phases/04-organization-and-graph/04-02-SUMMARY.md
@.planning/phases/04-organization-and-graph/04-03-SUMMARY.md
@src/ui/panels/library_panel.h
@src/ui/panels/library_panel.cpp
@src/app/application.h
@src/app/application.cpp
@src/core/library/library_manager.h
@src/core/graph/graph_manager.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire GraphManager in Application and connect to LibraryManager</name>
  <files>
    src/app/application.h
    src/app/application.cpp
  </files>
  <action>
1. In `application.h`:
   - Add `#include "../core/graph/graph_manager.h"` (or forward-declare)
   - Add private member: `std::unique_ptr<GraphManager> m_graphManager;`

2. In `application.cpp`:
   - In the initialization sequence (after Database/ConnectionPool and Schema init, after LibraryManager is created):
     a. Create GraphManager: `m_graphManager = std::make_unique<GraphManager>(primaryDb);` where primaryDb is the Database reference used for schema init
     b. Initialize: Get the executable directory for extension path resolution. Use the build output directory (where the .so was copied by CMake POST_BUILD):
        ```cpp
        Path exeDir = paths::getExecutableDir(); // or std::filesystem::current_path()
        if (!m_graphManager->initialize(exeDir)) {
            log::warning("Application", "GraphQLite extension not available -- graph queries disabled");
        }
        ```
     c. Wire to LibraryManager: `m_libraryManager->setGraphManager(m_graphManager.get());`

   - In shutdown/cleanup: GraphManager destructor handles cleanup (unique_ptr auto-destroys). Ensure it is destroyed BEFORE the Database is closed. Since unique_ptr members are destroyed in reverse declaration order, declare m_graphManager AFTER the database member.

   IMPORTANT: Check the actual Application class member declarations and initialization order. The GraphManager must be initialized AFTER the schema is set up (Plan 01's schema v7) and BEFORE any imports or UI operations. Look for the existing init sequence pattern and insert at the right point.

   If ConnectionPool is used, GraphManager should use the primary Database connection (not a pooled one) for extension loading, since sqlite3_load_extension applies per-connection. However, once loaded, the extension should be available to all connections from the same database file. Verify this at implementation time.
  </action>
  <verify>
Build and run: `cd /data/DW/build && cmake .. && make -j$(nproc) && ./digital_workshop` -- app starts. Check log output for either "GraphQLite extension loaded" or "GraphQLite extension not available" (both are acceptable).
  </verify>
  <done>GraphManager is created, initialized (with graceful fallback), and wired to LibraryManager in Application's init sequence. App starts cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Add category filter, FTS5 search, and category assignment to LibraryPanel</name>
  <files>
    src/ui/panels/library_panel.h
    src/ui/panels/library_panel.cpp
  </files>
  <action>
NOTE: library_panel.cpp is already 1045 lines (over the 800-line guideline). Be mindful of additions. The category tree and assignment dialog add significant code. If the file exceeds ~1200 lines after changes, consider extracting the category UI into a helper, but do not split the file in this plan -- just be concise.

1. In `library_panel.h`, add:
   ```cpp
   // Category filter state
   i64 m_selectedCategoryId = -1;     // -1 = show all
   std::string m_selectedCategoryName; // For breadcrumb display
   std::vector<CategoryRecord> m_categories; // Cached category list
   bool m_showCategoryAssignDialog = false;
   float m_searchDebounceTimer = 0.0f;
   bool m_searchDirty = false;
   bool m_useFTS = true; // Use FTS5 for search (true) vs LIKE (false)
   ```

2. In `library_panel.cpp`, modify `renderToolbar()`:
   - Replace the existing search InputText callback with a debounced version:
     - On each keystroke, set `m_searchDirty = true` and reset `m_searchDebounceTimer = 0.2f` (200ms)
     - In `render()`, before renderToolbar(), tick the debounce timer:
       ```cpp
       if (m_searchDirty && m_searchDebounceTimer > 0) {
           m_searchDebounceTimer -= ImGui::GetIO().DeltaTime;
           if (m_searchDebounceTimer <= 0) {
               m_searchDirty = false;
               refresh();
           }
       }
       ```
   - The InputText still triggers immediate visual update of the text, but refresh() is debounced

3. Modify `refresh()`:
   - When `m_searchQuery` is not empty, use `m_library->searchModelsFTS(m_searchQuery)` instead of `m_library->searchModels(m_searchQuery)` (FTS5 with BM25 ranking)
   - When `m_selectedCategoryId > 0` and search is empty, use `m_library->filterByCategory(m_selectedCategoryId)`
   - When both search and category filter are active, search first then filter client-side by category (or combine in a single query if the repository supports it)

4. Add category sidebar rendering. Insert a collapsible category tree above the model list:
   - In renderModelList() (or a new renderCategoryFilter() called before the model list):
     ```cpp
     void LibraryPanel::renderCategoryFilter() {
         // "All" button to clear filter
         bool allSelected = (m_selectedCategoryId == -1);
         if (ImGui::Selectable("All Models", allSelected)) {
             m_selectedCategoryId = -1;
             m_selectedCategoryName.clear();
             refresh();
         }

         ImGui::Separator();

         // Category tree (2-level max)
         auto roots = // filter m_categories for parent_id == nullopt
         for (auto& root : roots) {
             bool isSelected = (m_selectedCategoryId == root.id);
             ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;
             if (isSelected) flags |= ImGuiTreeNodeFlags_Selected;

             auto children = // filter m_categories for parent_id == root.id
             if (children.empty()) flags |= ImGuiTreeNodeFlags_Leaf;

             bool open = ImGui::TreeNodeEx(root.name.c_str(), flags);
             if (ImGui::IsItemClicked()) {
                 m_selectedCategoryId = root.id;
                 m_selectedCategoryName = root.name;
                 refresh();
             }
             if (open) {
                 for (auto& child : children) {
                     bool childSelected = (m_selectedCategoryId == child.id);
                     if (ImGui::Selectable(child.name.c_str(), childSelected)) {
                         m_selectedCategoryId = child.id;
                         m_selectedCategoryName = root.name + " > " + child.name;
                         refresh();
                     }
                 }
                 ImGui::TreePop();
             }
         }
     }
     ```

5. Show breadcrumb when a category is selected:
   - At the top of the model list area, if `m_selectedCategoryId > 0`, show:
     ```
     [Category: Furniture > Chair] [x clear]
     ```
   - Clicking [x] clears the filter

6. Add "Assign Category" to the model context menu (in registerContextMenuEntries):
   - Add a new entry: `{"Assign Category", [this]() { m_showCategoryAssignDialog = true; }}`
   - Place it after "Assign Default Material"

7. Add `renderCategoryAssignDialog()`:
   - Modal popup listing all categories as a tree
   - Checkboxes for each category the selected model(s) belong to
   - "Add Category" button at the bottom to create a new category inline
   - Apply/Cancel buttons
   - On Apply: call `m_library->assignCategory(modelId, categoryId)` for each checked category, `m_library->removeModelCategory(modelId, categoryId)` for each unchecked
   - Call renderCategoryAssignDialog() from render()

8. Refresh categories cache in `refresh()`:
   ```cpp
   m_categories = m_library->getAllCategories();
   ```

9. Use a `ImGui::BeginChild("CategorySidebar", ImVec2(180, 0), true)` on the left side of the library panel, with the model list in a second child on the right. Use `ImGui::Columns(2)` or side-by-side children for the layout. Keep the category sidebar compact (180px wide).
  </action>
  <verify>
Build and run: `cd /data/DW/build && make -j$(nproc) && ./digital_workshop`. Verify:
1. Library panel shows category sidebar on the left
2. Clicking a category filters the model list
3. Search bar uses FTS5 (type a word, results update after 200ms pause)
4. Right-click model > "Assign Category" opens assignment dialog
5. Breadcrumb shows when filtering by category
  </verify>
  <done>Library panel has category filter sidebar with 2-level tree, FTS5 debounced search, category assignment dialog, and breadcrumb display. All existing functionality preserved.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 4 Organization and Graph system: category hierarchy in the library panel, FTS5 full-text search with BM25 ranking, GraphQLite extension loading, and Cypher-based relationship queries.</what-built>
  <how-to-verify>
1. Start the application: `cd /data/DW/build && ./digital_workshop`
2. Open the Library panel
3. Verify the category sidebar appears on the left
4. Right-click a model and choose "Assign Category" -- verify the dialog shows categories
5. Assign a category, then click that category in the sidebar -- verify the model appears in the filtered list
6. Type a search term in the search bar -- verify results update after a brief pause (debounced FTS5)
7. Check the terminal/log for GraphQLite status (loaded or fallback warning)
8. If GraphQLite loaded: verify no errors in log related to graph operations
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `cd /data/DW/build && cmake .. && make -j$(nproc)` compiles cleanly
2. `./build/tests/dw_tests` -- all existing tests pass
3. Application starts with GraphManager initialized
4. Library panel has category sidebar, FTS5 search, category assignment
5. Phase 4 success criteria met:
   - SC1: User can assign model to 2-level category and filter by category
   - SC2: User can search with ranked results across name, tags
   - SC3: Models, categories, projects exist as graph nodes
   - SC4: Cypher queries return relationship data
   - SC5: GraphQLite loads at DB init (or graceful fallback)
</verification>

<success_criteria>
- Category sidebar in library panel with 2-level tree (ORG-01)
- Category assignment dialog with many-to-many support (ORG-01)
- FTS5 search with BM25 ranking and search-as-you-type debounce (ORG-02)
- GraphManager wired in Application, initialized at startup (ORG-03)
- Graph nodes/edges created on model import and category assignment (ORG-04)
- Cypher query methods accessible for relationship traversal (ORG-05)
- Human verification of visual UI confirms usability
</success_criteria>

<output>
After completion, create `.planning/phases/04-organization-and-graph/04-04-SUMMARY.md`
</output>
