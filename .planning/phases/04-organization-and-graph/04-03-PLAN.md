---
phase: 04-organization-and-graph
plan: 03
type: execute
wave: 2
depends_on: [04-01, 04-02]
files_modified:
  - src/core/graph/graph_manager.h
  - src/core/graph/graph_manager.cpp
  - src/core/library/library_manager.h
  - src/core/library/library_manager.cpp
autonomous: true
requirements: [ORG-04, ORG-05]

must_haves:
  truths:
    - "Models inserted into library are also created as graph nodes"
    - "Category assignments create BELONGS_TO edges in the graph"
    - "Project-model associations create CONTAINS edges in the graph"
    - "User can query related models via Cypher (models in same category, models in project)"
    - "Graph writes are non-fatal -- failures log warnings but do not block operations"
  artifacts:
    - path: "src/core/graph/graph_manager.h"
      provides: "Node/edge CRUD methods for models, categories, projects"
      exports: ["addModelNode", "addCategoryEdge", "queryRelatedModels"]
    - path: "src/core/graph/graph_manager.cpp"
      provides: "Cypher queries for node creation, edge creation, relationship traversal"
      min_lines: 80
    - path: "src/core/library/library_manager.h"
      provides: "GraphManager injection, category assignment with dual-write"
      contains: "GraphManager"
    - path: "src/core/library/library_manager.cpp"
      provides: "Dual-write to SQLite + graph on category assignment and model import"
      min_lines: 30
  key_links:
    - from: "src/core/library/library_manager.cpp"
      to: "src/core/graph/graph_manager.h"
      via: "GraphManager::addModelNode on import"
      pattern: "addModelNode"
    - from: "src/core/library/library_manager.cpp"
      to: "src/core/graph/graph_manager.h"
      via: "GraphManager::addCategoryEdge on category assign"
      pattern: "addCategoryEdge"
---

<objective>
Graph node/edge CRUD and LibraryManager integration for relationship queries

Purpose: Create graph nodes for models, categories, and projects (ORG-04), and enable Cypher-based relationship traversal (ORG-05). LibraryManager dual-writes to SQLite (source of truth) and GraphQLite (for graph queries).

Output: GraphManager with full node/edge CRUD, LibraryManager with graph-aware category assignment and model import, Cypher query methods for relationship discovery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/04-organization-and-graph/04-01-SUMMARY.md
@.planning/phases/04-organization-and-graph/04-02-SUMMARY.md
@src/core/graph/graph_manager.h
@src/core/graph/graph_manager.cpp
@src/core/library/library_manager.h
@src/core/library/library_manager.cpp
@src/core/database/model_repository.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add node/edge CRUD and relationship query methods to GraphManager</name>
  <files>
    src/core/graph/graph_manager.h
    src/core/graph/graph_manager.cpp
  </files>
  <action>
1. In `graph_manager.h`, add convenience methods for typed graph operations:
   ```cpp
   // Node operations (non-fatal -- all return bool, log on failure)
   bool addModelNode(i64 id, const std::string& name, const std::string& hash);
   bool removeModelNode(i64 id);
   bool addCategoryNode(i64 id, const std::string& name);
   bool removeCategoryNode(i64 id);
   bool addProjectNode(i64 id, const std::string& name);
   bool removeProjectNode(i64 id);

   // Edge operations
   bool addBelongsToEdge(i64 modelId, i64 categoryId);
   bool removeBelongsToEdge(i64 modelId, i64 categoryId);
   bool addContainsEdge(i64 projectId, i64 modelId);
   bool removeContainsEdge(i64 projectId, i64 modelId);
   bool addRelatedToEdge(i64 modelId1, i64 modelId2);

   // Relationship queries
   // Returns model IDs in the same category as the given model
   std::vector<i64> queryModelsInSameCategory(i64 modelId);
   // Returns model IDs in a given project
   std::vector<i64> queryModelsInProject(i64 projectId);
   // Returns model IDs related to a given model (via RELATED_TO edges)
   std::vector<i64> queryRelatedModels(i64 modelId);
   // Returns category IDs a model belongs to
   std::vector<i64> queryModelCategories(i64 modelId);
   // Returns project IDs containing a model
   std::vector<i64> queryModelProjects(i64 modelId);
   // Returns models not in any project (orphans)
   std::vector<i64> queryOrphanModels();
   ```

2. In `graph_manager.cpp`, implement each method:
   - All write methods: If `!m_available`, return false immediately (silent no-op).
   - All write methods: Log warning on Cypher execution failure, do NOT throw or propagate errors.
   - Node creation uses MERGE (idempotent): `MERGE (m:Model {id: $id}) SET m.name = $name, m.hash = $hash`
   - Edge creation uses MERGE: `MATCH (m:Model {id: $mid}), (c:Category {id: $cid}) MERGE (m)-[:BELONGS_TO]->(c)`
   - Relationship queries: Use Cypher MATCH patterns:
     - queryModelsInSameCategory: `MATCH (m:Model {id: $id})-[:BELONGS_TO]->(c:Category)<-[:BELONGS_TO]-(other:Model) RETURN other.id`
     - queryModelsInProject: `MATCH (p:Project {id: $pid})-[:CONTAINS]->(m:Model) RETURN m.id`
     - queryRelatedModels: `MATCH (m:Model {id: $id})-[:RELATED_TO]-(other:Model) RETURN other.id`
     - queryOrphanModels: `MATCH (m:Model) WHERE NOT EXISTS { MATCH (m)<-[:CONTAINS]-(:Project) } RETURN m.id`

   IMPORTANT: The exact Cypher syntax depends on GraphQLite's implementation. At implementation time, check the GraphQLite README/docs for:
   - How to pass parameters (positional? named?)
   - Whether MERGE is supported or only CREATE
   - How results are returned from the cypher() function
   Adapt accordingly. If parameters are not supported, use string interpolation with proper escaping (escape single quotes in strings).

   For all query methods, parse the result rows to extract i64 IDs. Use queryCypher() from Plan 02.
  </action>
  <verify>
Build: `cd /data/DW/build && make -j$(nproc)` compiles cleanly. All methods compile and link.
  </verify>
  <done>GraphManager has addModelNode, addCategoryNode, addProjectNode, edge creation, and 6 relationship query methods. All operations are non-fatal. All methods no-op when GraphQLite unavailable.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate GraphManager into LibraryManager for dual-write</name>
  <files>
    src/core/library/library_manager.h
    src/core/library/library_manager.cpp
  </files>
  <action>
1. In `library_manager.h`:
   - Add forward declaration: `class GraphManager;`
   - Add to private members: `GraphManager* m_graphManager = nullptr;`
   - Add public setter: `void setGraphManager(GraphManager* gm) { m_graphManager = gm; }`
   - Add new public methods for category management (delegates to ModelRepository):
     ```cpp
     // Category management
     bool assignCategory(i64 modelId, i64 categoryId);
     bool removeModelCategory(i64 modelId, i64 categoryId);
     std::optional<i64> createCategory(const std::string& name, std::optional<i64> parentId = std::nullopt);
     bool deleteCategory(i64 categoryId);
     std::vector<CategoryRecord> getAllCategories();
     std::vector<CategoryRecord> getRootCategories();
     std::vector<CategoryRecord> getChildCategories(i64 parentId);
     std::vector<ModelRecord> filterByCategory(i64 categoryId);

     // FTS5 search (replaces LIKE-based searchModels for text queries)
     std::vector<ModelRecord> searchModelsFTS(const std::string& query);

     // Graph queries (delegated to GraphManager)
     std::vector<i64> getRelatedModelIds(i64 modelId);
     std::vector<i64> getModelsInProject(i64 projectId);
     bool isGraphAvailable() const;
     ```

2. In `library_manager.cpp`:
   - Include `"../graph/graph_manager.h"`
   - `assignCategory()`:
     a. Call `m_modelRepo.assignCategory(modelId, categoryId)` (SQLite -- source of truth)
     b. If GraphManager available: `m_graphManager->addBelongsToEdge(modelId, categoryId)` (non-fatal)
   - `removeModelCategory()`:
     a. Call `m_modelRepo.removeCategory(modelId, categoryId)`
     b. If GraphManager: `m_graphManager->removeBelongsToEdge(modelId, categoryId)` (non-fatal)
   - In `importModel()` (existing method), after the model is inserted and modelId is obtained:
     a. If GraphManager available: `m_graphManager->addModelNode(*modelId, record.name, record.hash)` (non-fatal, log warning on failure)
   - In `removeModel()` (existing method), before deleting from DB:
     a. If GraphManager available: `m_graphManager->removeModelNode(modelId)` (non-fatal)
   - `searchModelsFTS()`: Delegates to `m_modelRepo.searchFTS(query)`
   - `getRelatedModelIds()`: Delegates to `m_graphManager->queryRelatedModels(modelId)` if available, else returns empty vector
   - `getModelsInProject()`: Delegates to `m_graphManager->queryModelsInProject(projectId)` if available, else returns empty vector
   - `isGraphAvailable()`: Returns `m_graphManager && m_graphManager->isAvailable()`
   - Category CRUD methods: Direct delegation to `m_modelRepo` equivalents
   - `filterByCategory()`: Direct delegation to `m_modelRepo.findByCategory(categoryId)`

3. Keep the existing `searchModels()` method (LIKE-based) for backward compatibility. The new `searchModelsFTS()` is the preferred search path and will be wired to the UI in Plan 04.
  </action>
  <verify>
Build: `cd /data/DW/build && make -j$(nproc)` compiles cleanly. Run `./build/tests/dw_tests` -- all existing tests pass. Verify LibraryManager has both old searchModels and new searchModelsFTS.
  </verify>
  <done>LibraryManager has GraphManager injection, dual-write on category assignment and model import/delete, FTS5 search method, and graph query delegation. SQLite remains source of truth. All graph operations non-fatal. Existing tests pass.</done>
</task>

</tasks>

<verification>
1. `cd /data/DW/build && cmake .. && make -j$(nproc)` compiles cleanly
2. `./build/tests/dw_tests` -- all existing tests pass
3. `grep "addModelNode\|addBelongsToEdge" src/core/library/library_manager.cpp` confirms dual-write wiring
4. `grep "m_graphManager" src/core/library/library_manager.h` confirms GraphManager injection
5. GraphManager has relationship query methods: queryModelsInSameCategory, queryModelsInProject, queryRelatedModels, queryOrphanModels
</verification>

<success_criteria>
- Models, categories, projects exist as graph nodes (ORG-04)
- BELONGS_TO, CONTAINS, RELATED_TO edges created on assignment (ORG-04)
- Cypher queries return related models, models in project, orphan models (ORG-05)
- All graph writes are non-fatal (warnings only)
- SQLite is source of truth; graph is supplementary
- Existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-organization-and-graph/04-03-SUMMARY.md`
</output>
