---
phase: 13-tcp-ip-byte-stream-transport-for-cnc-connections
plan: 03
type: execute
wave: 3
depends_on: ["13-01", "13-02"]
files_modified:
  - src/ui/panels/gcode_panel.h
  - src/ui/panels/gcode_panel.cpp
autonomous: true
requirements:
  - TCP-05

must_haves:
  truths:
    - "Operator can switch between Serial and TCP connection modes in the connection bar"
    - "TCP mode shows host and port input fields instead of serial port and baud rate combos"
    - "Connect button in TCP mode calls CncController::connectTcp(host, port)"
  artifacts:
    - path: "src/ui/panels/gcode_panel.h"
      provides: "TCP connection UI state members"
      contains: "m_tcpHost"
    - path: "src/ui/panels/gcode_panel.cpp"
      provides: "Connection bar with Serial/TCP mode selector"
      contains: "connectTcp"
  key_links:
    - from: "src/ui/panels/gcode_panel.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "connectTcp() call from UI"
      pattern: "m_cnc->connectTcp"
---

<objective>
Add TCP connection UI to the GCode panel's connection bar, allowing the operator to choose between Serial and TCP transports.

Purpose: Makes the TCP transport accessible to the user through the existing connection interface, with a mode selector to switch between serial port and network connection.
Output: Updated `gcode_panel.h/cpp` with TCP connection mode
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-tcp-ip-byte-stream-transport-for-cnc-connections/13-01-SUMMARY.md
@.planning/phases/13-tcp-ip-byte-stream-transport-for-cnc-connections/13-02-SUMMARY.md

@src/ui/panels/gcode_panel.h
@src/ui/panels/gcode_panel.cpp
@src/core/cnc/cnc_controller.h

<interfaces>
<!-- CncController connection methods (after Plan 01 + Plan 02) -->

From src/core/cnc/cnc_controller.h:
```cpp
class CncController {
    bool connect(const std::string& device, int baudRate = 115200);
    bool connectTcp(const std::string& host, int port);
    bool connectSimulator();
    void disconnect();
    bool isConnected() const;
};
```

<!-- GCode panel connection bar members (current) -->

From src/ui/panels/gcode_panel.h:
```cpp
class GCodePanel {
    CncController* m_cnc = nullptr;
    bool m_cncConnected = false;
    std::vector<std::string> m_availablePorts;
    size_t m_selectedPort = 0;
    size_t m_selectedBaud = 3; // 115200

    void renderConnectionBar();
};
```

<!-- Current renderConnectionBar() layout -->
From src/ui/panels/gcode_panel.cpp line 545-621:
- Refresh button + Port combo (150px) + Baud combo (80px) + Connect/Disconnect button + version text
- Uses listSerialPorts() for port enumeration
- Uses BAUD_RATES[] array for baud rate options
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TCP connection mode to connection bar UI</name>
  <files>src/ui/panels/gcode_panel.h, src/ui/panels/gcode_panel.cpp</files>
  <action>
**gcode_panel.h changes:**

Add new member variables near the existing connection members (around line 207-209):

```cpp
// Connection mode
enum class ConnMode { Serial, Tcp };
ConnMode m_connMode = ConnMode::Serial;

// TCP connection state
char m_tcpHost[128] = "192.168.1.1";   // ImGui InputText buffer
int m_tcpPort = 23;                     // Default telnet port (common for serial-to-ethernet bridges)
```

**gcode_panel.cpp renderConnectionBar() changes:**

Restructure the connection bar to add a mode selector BEFORE the transport-specific controls. The layout becomes:

```
[Refresh] [Serial|TCP] [... transport-specific controls ...] [Connect/Disconnect] [version]
```

Specific implementation:

1. After the "Connection" text label, add a mode selector using `ImGui::RadioButton`:
```cpp
ImGui::SameLine();
if (ImGui::RadioButton("Serial", m_connMode == ConnMode::Serial)) m_connMode = ConnMode::Serial;
ImGui::SameLine();
if (ImGui::RadioButton("TCP", m_connMode == ConnMode::Tcp)) m_connMode = ConnMode::Tcp;
ImGui::SameLine();
```

2. Replace the current port/baud controls with a conditional block:

```cpp
if (m_connMode == ConnMode::Serial) {
    // Existing code: Refresh button + Port combo + Baud combo
    // (move existing code here unchanged)
} else {
    // TCP mode: Host input + Port input
    ImGui::SetNextItemWidth(150);
    ImGui::InputText("##TcpHost", m_tcpHost, sizeof(m_tcpHost));
    ImGui::SameLine();
    ImGui::SetNextItemWidth(60);
    ImGui::InputInt("##TcpPort", &m_tcpPort, 0, 0);
    // Clamp port to valid range
    if (m_tcpPort < 1) m_tcpPort = 1;
    if (m_tcpPort > 65535) m_tcpPort = 65535;
}
```

3. Update the Connect button logic to call the appropriate method:

```cpp
if (ImGui::Button("Connect")) {
    if (m_connMode == ConnMode::Serial) {
        if (!m_cnc->connect(m_availablePorts[m_selectedPort], BAUD_RATES[m_selectedBaud])) {
            addConsoleLine("Failed to open " + m_availablePorts[m_selectedPort], ConsoleLine::Error);
        } else {
            addConsoleLine("Connecting to " + m_availablePorts[m_selectedPort] + "...", ConsoleLine::Info);
        }
    } else {
        std::string host(m_tcpHost);
        if (!m_cnc->connectTcp(host, m_tcpPort)) {
            addConsoleLine("Failed to connect to " + host + ":" + std::to_string(m_tcpPort), ConsoleLine::Error);
        } else {
            addConsoleLine("Connecting to " + host + ":" + std::to_string(m_tcpPort) + "...", ConsoleLine::Info);
        }
    }
}
```

4. Update the `canConnect` logic: In Serial mode, require non-empty ports list (existing behavior). In TCP mode, require non-empty host string:
```cpp
bool canConnect = false;
if (m_connMode == ConnMode::Serial)
    canConnect = m_cnc && !m_availablePorts.empty();
else
    canConnect = m_cnc && m_tcpHost[0] != '\0';
```

5. The Refresh button should only show in Serial mode (TCP doesn't need port enumeration). Move it inside the Serial mode branch.

6. Keep the Disconnect button and version display unchanged — they work identically for both transports since CncController::disconnect() is transport-agnostic.

Do NOT change the rest of gcode_panel.cpp — all other CNC functionality (streaming, console, status display) works through CncController which is transport-agnostic.
  </action>
  <verify>
    <automated>cd /data/DW && cmake --build build -j$(nproc) 2>&1 | tail -20 && ctest --test-dir build --output-on-failure 2>&1 | tail -10</automated>
  </verify>
  <done>Connection bar shows Serial/TCP mode selector. Serial mode works exactly as before. TCP mode shows host input (default "192.168.1.1") and port input (default 23). Connect calls connectTcp() in TCP mode. Compiles cleanly and all tests pass.</done>
</task>

</tasks>

<verification>
1. `cmake --build build -j$(nproc)` compiles without errors
2. `ctest --test-dir build --output-on-failure` — all tests pass
3. `grep -n "ConnMode" src/ui/panels/gcode_panel.h` confirms mode enum and member
4. `grep -n "connectTcp" src/ui/panels/gcode_panel.cpp` confirms TCP connect call
5. `grep -n "m_tcpHost\|m_tcpPort" src/ui/panels/gcode_panel.h` confirms TCP state members
</verification>

<success_criteria>
- Connection bar has Serial/TCP radio button selector
- Serial mode retains all existing UI: refresh, port combo, baud combo
- TCP mode shows host text input and port number input
- Connect button dispatches to correct CncController method based on mode
- Disconnect works for both modes (transport-agnostic)
- No changes to any other panel functionality
</success_criteria>

<output>
After completion, create `.planning/phases/13-tcp-ip-byte-stream-transport-for-cnc-connections/13-03-SUMMARY.md`
</output>
