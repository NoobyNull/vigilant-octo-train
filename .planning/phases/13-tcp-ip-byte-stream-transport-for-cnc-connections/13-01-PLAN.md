---
phase: 13-tcp-ip-byte-stream-transport-for-cnc-connections
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/cnc/byte_stream.h
  - src/core/cnc/serial_port.h
  - src/core/cnc/serial_port.cpp
  - src/core/cnc/cnc_controller.h
  - src/core/cnc/cnc_controller.cpp
autonomous: true
requirements:
  - TCP-01
  - TCP-02

must_haves:
  truths:
    - "SerialPort implements an abstract IByteStream interface with all existing methods"
    - "CncController owns a unique_ptr<IByteStream> instead of a concrete SerialPort member"
    - "Existing serial connection and simulator workflows continue working identically"
  artifacts:
    - path: "src/core/cnc/byte_stream.h"
      provides: "IByteStream abstract base class"
      contains: "class IByteStream"
    - path: "src/core/cnc/serial_port.h"
      provides: "SerialPort implementing IByteStream"
      contains: "class SerialPort : public IByteStream"
    - path: "src/core/cnc/cnc_controller.h"
      provides: "CncController using unique_ptr<IByteStream>"
      contains: "unique_ptr<IByteStream>"
  key_links:
    - from: "src/core/cnc/cnc_controller.cpp"
      to: "src/core/cnc/byte_stream.h"
      via: "m_port->method() calls through interface"
      pattern: "m_port->"
    - from: "src/core/cnc/serial_port.h"
      to: "src/core/cnc/byte_stream.h"
      via: "inheritance"
      pattern: "class SerialPort : public IByteStream"
---

<objective>
Extract an abstract `IByteStream` interface from `SerialPort` and refactor `CncController` to use it through a `unique_ptr`, enabling polymorphic transport implementations.

Purpose: This is the foundational refactor that decouples CncController from the concrete SerialPort, making it possible to add TCP and future transports without modifying the controller logic.
Output: `byte_stream.h` interface, updated `serial_port.h/cpp`, updated `cnc_controller.h/cpp`
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/core/cnc/serial_port.h
@src/core/cnc/serial_port.cpp
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_controller.cpp

<interfaces>
<!-- Current SerialPort public API that becomes IByteStream -->

From src/core/cnc/serial_port.h:
```cpp
enum class ConnectionState { Closed, Connected, Disconnected, Error };

class SerialPort {
  public:
    bool open(const std::string& device, int baudRate);
    void close();
    bool isOpen() const;
    bool write(const std::string& data);
    bool writeByte(u8 byte);
    std::optional<std::string> readLine(int timeoutMs);
    void drain();
    const std::string& device() const;
    ConnectionState connectionState() const;
};
```

From src/core/cnc/cnc_controller.h:
```cpp
class CncController {
    SerialPort m_port;  // Direct member — needs to become unique_ptr<IByteStream>
    // ...
    bool connect(const std::string& device, int baudRate = 115200);
    bool connectSimulator();
    void disconnect();
};
```

CncController uses m_port via these patterns (from cnc_controller.cpp):
- m_port.open(device, baudRate)
- m_port.close()
- m_port.isOpen()
- m_port.write(toSend)
- m_port.writeByte(byte)
- m_port.readLine(100)
- m_port.drain()
- m_port.connectionState()
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IByteStream interface and refactor SerialPort</name>
  <files>src/core/cnc/byte_stream.h, src/core/cnc/serial_port.h, src/core/cnc/serial_port.cpp</files>
  <action>
Create `src/core/cnc/byte_stream.h` containing:

```cpp
#pragma once
#include <optional>
#include <string>
#include "../types.h"

namespace dw {

enum class ConnectionState { Closed, Connected, Disconnected, Error };

class IByteStream {
  public:
    virtual ~IByteStream() = default;

    virtual void close() = 0;
    virtual bool isOpen() const = 0;
    virtual bool write(const std::string& data) = 0;
    virtual bool writeByte(u8 byte) = 0;
    virtual std::optional<std::string> readLine(int timeoutMs) = 0;
    virtual void drain() = 0;
    virtual const std::string& device() const = 0;
    virtual ConnectionState connectionState() const = 0;
};

} // namespace dw
```

Key design decisions:
- `ConnectionState` enum moves from serial_port.h to byte_stream.h (since both transports need it)
- `open()` is NOT in the interface — each transport has a different open signature (serial needs device+baudRate, TCP needs host+port). Construction/opening is transport-specific.
- `IByteStream` is non-copyable by default (pure virtual destructor makes it abstract)
- Keep `device()` in the interface — for TCP it returns "host:port", for serial it returns "/dev/ttyUSB0"

Update `serial_port.h`:
- Remove the `ConnectionState` enum (now in byte_stream.h)
- Add `#include "byte_stream.h"`
- Change class declaration to `class SerialPort : public IByteStream`
- Add `override` to all virtual method implementations: `close()`, `isOpen()`, `write()`, `writeByte()`, `readLine()`, `drain()`, `device()`, `connectionState()`
- Keep `open(const std::string& device, int baudRate)` as a SerialPort-specific method (not in interface)
- Keep the move constructor/assignment operators (concrete class can still be moved)

Update `serial_port.cpp`:
- Remove `ConnectionState` includes if any (enum now in byte_stream.h)
- No changes needed to implementation code — methods are the same, just now virtual overrides

Remove the old `ConnectionState` enum from serial_port.h and ensure all files that used `ConnectionState` still compile (it's re-exported via byte_stream.h included from serial_port.h).
  </action>
  <verify>
    <automated>cd /data/DW && cmake --build build -j$(nproc) 2>&1 | tail -20</automated>
  </verify>
  <done>IByteStream abstract class exists in byte_stream.h, SerialPort inherits from it with override on all methods, ConnectionState enum lives in byte_stream.h, project compiles cleanly</done>
</task>

<task type="auto">
  <name>Task 2: Refactor CncController to use unique_ptr&lt;IByteStream&gt;</name>
  <files>src/core/cnc/cnc_controller.h, src/core/cnc/cnc_controller.cpp</files>
  <action>
Update `cnc_controller.h`:
- Add `#include "byte_stream.h"` and `#include <memory>`
- Change `SerialPort m_port;` to `std::unique_ptr<IByteStream> m_port;`
- Can remove `#include "serial_port.h"` from the header (move to .cpp only) — but only if no other header code references SerialPort directly

Update `cnc_controller.cpp`:
- Add `#include "serial_port.h"` at top (needed to construct SerialPort)
- In `connect()`: Create a SerialPort, open it, then assign to m_port:
  ```cpp
  auto port = std::make_unique<SerialPort>();
  if (!port->open(device, baudRate))
      return false;
  m_port = std::move(port);
  ```
- Change all `m_port.method()` calls to `m_port->method()` throughout the file. This affects:
  - `m_port.open(device, baudRate)` → handled by connect() restructure above
  - `m_port.writeByte(...)` → `m_port->writeByte(...)`
  - `m_port.drain()` → `m_port->drain()`
  - `m_port.close()` → `m_port->close()`
  - `m_port.isOpen()` → `m_port && m_port->isOpen()`
  - `m_port.write(...)` → `m_port->write(...)`
  - `m_port.readLine(...)` → `m_port->readLine(...)`
  - `m_port.connectionState()` → `m_port->connectionState()`
- In `disconnect()`: Replace `m_port.close()` / `m_port.isOpen()` with null-safe pointer checks:
  ```cpp
  if (m_port) {
      m_port->close();
      m_port.reset();
  }
  ```
  The `else if (m_port.isOpen())` block in disconnect becomes `else if (m_port && m_port->isOpen())`
- In `ioThreadFunc()` and all IO thread methods: Same `.` to `->` changes. The m_port pointer is guaranteed non-null while m_running is true (set before thread start, port created before thread start).

IMPORTANT: Do NOT change the simulator path. `connectSimulator()` does not use m_port at all (it uses m_sim state and simIoThreadFunc). The simulator path should remain unchanged.

IMPORTANT: The `isOpen()` inline in the header (`return m_fd >= 0`) becomes a virtual call, but that's fine — it's only called on the IO thread or during connect/disconnect, not in a tight loop.
  </action>
  <verify>
    <automated>cd /data/DW && cmake --build build -j$(nproc) 2>&1 | tail -20 && ctest --test-dir build --output-on-failure 2>&1 | tail -30</automated>
  </verify>
  <done>CncController compiles and all existing tests pass. m_port is a unique_ptr&lt;IByteStream&gt;. Serial connections work through the interface. Simulator mode is unaffected.</done>
</task>

</tasks>

<verification>
1. `cmake --build build -j$(nproc)` compiles without errors or warnings
2. `ctest --test-dir build --output-on-failure` — all existing tests pass (especially test_serial_port and test_cnc_controller tests)
3. `grep -n "SerialPort m_port" src/core/cnc/cnc_controller.h` returns no matches (member is now unique_ptr)
4. `grep -n "class IByteStream" src/core/cnc/byte_stream.h` confirms interface exists
5. `grep -n "class SerialPort : public IByteStream" src/core/cnc/serial_port.h` confirms inheritance
</verification>

<success_criteria>
- IByteStream interface defined with all transport-agnostic methods
- SerialPort implements IByteStream
- CncController uses unique_ptr<IByteStream> for polymorphic dispatch
- All existing tests pass without modification
- No behavioral changes to serial or simulator connections
</success_criteria>

<output>
After completion, create `.planning/phases/13-tcp-ip-byte-stream-transport-for-cnc-connections/13-01-SUMMARY.md`
</output>
