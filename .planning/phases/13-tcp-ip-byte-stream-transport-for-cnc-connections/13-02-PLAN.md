---
phase: 13-tcp-ip-byte-stream-transport-for-cnc-connections
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/core/cnc/tcp_socket.h
  - src/core/cnc/tcp_socket.cpp
  - src/core/cnc/cnc_controller.h
  - src/core/cnc/cnc_controller.cpp
  - src/CMakeLists.txt
  - tests/test_tcp_socket.cpp
  - tests/CMakeLists.txt
autonomous: true
requirements:
  - TCP-03
  - TCP-04

must_haves:
  truths:
    - "TcpSocket can connect to a host:port and send/receive newline-delimited text"
    - "CncController has a connectTcp(host, port) method that creates a TcpSocket transport"
    - "TcpSocket detects disconnection via poll() errors and updates ConnectionState"
  artifacts:
    - path: "src/core/cnc/tcp_socket.h"
      provides: "TcpSocket class implementing IByteStream"
      contains: "class TcpSocket : public IByteStream"
    - path: "src/core/cnc/tcp_socket.cpp"
      provides: "POSIX TCP socket implementation"
      contains: "socket(AF_INET"
    - path: "tests/test_tcp_socket.cpp"
      provides: "Unit tests for TcpSocket"
      contains: "TEST(TcpSocket"
  key_links:
    - from: "src/core/cnc/cnc_controller.cpp"
      to: "src/core/cnc/tcp_socket.h"
      via: "connectTcp() creates TcpSocket"
      pattern: "make_unique<TcpSocket>"
    - from: "src/core/cnc/tcp_socket.h"
      to: "src/core/cnc/byte_stream.h"
      via: "inheritance"
      pattern: "class TcpSocket : public IByteStream"
---

<objective>
Implement the TcpSocket transport class and wire it into CncController via a new `connectTcp()` method.

Purpose: Provides network connectivity for CNC controllers accessible over TCP (FluidNC WiFi, serial-to-ethernet bridges, etc.) using the same IByteStream interface established in Plan 01.
Output: `tcp_socket.h/cpp`, updated `cnc_controller.h/cpp`, unit tests
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-tcp-ip-byte-stream-transport-for-cnc-connections/13-01-SUMMARY.md

@src/core/cnc/byte_stream.h
@src/core/cnc/serial_port.h
@src/core/cnc/serial_port.cpp
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_controller.cpp

<interfaces>
<!-- IByteStream interface from Plan 01 -->

From src/core/cnc/byte_stream.h:
```cpp
enum class ConnectionState { Closed, Connected, Disconnected, Error };

class IByteStream {
  public:
    virtual ~IByteStream() = default;
    virtual void close() = 0;
    virtual bool isOpen() const = 0;
    virtual bool write(const std::string& data) = 0;
    virtual bool writeByte(u8 byte) = 0;
    virtual std::optional<std::string> readLine(int timeoutMs) = 0;
    virtual void drain() = 0;
    virtual const std::string& device() const = 0;
    virtual ConnectionState connectionState() const = 0;
};
```

From src/core/cnc/serial_port.cpp (reference for poll/read/write pattern):
- Uses `poll(&pfd, 1, remaining)` with `POLLIN` for readLine
- Uses `::write(m_fd, data, len)` with EINTR retry loop
- Detects disconnect via `POLLHUP | POLLERR` revents
- Uses monotonic clock for accurate timeout tracking
- Accumulates partial reads in m_readBuffer, splits on '\n'
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TcpSocket class</name>
  <files>src/core/cnc/tcp_socket.h, src/core/cnc/tcp_socket.cpp, src/CMakeLists.txt</files>
  <action>
Create `src/core/cnc/tcp_socket.h`:

```cpp
#pragma once
#include "byte_stream.h"
#include <string>

namespace dw {

// Raw TCP socket transport for network-attached CNC controllers.
// Plain bidirectional byte stream (telnet-style) — no framing, no WebSocket.
class TcpSocket : public IByteStream {
  public:
    TcpSocket() = default;
    ~TcpSocket() override;

    // Non-copyable, movable
    TcpSocket(const TcpSocket&) = delete;
    TcpSocket& operator=(const TcpSocket&) = delete;
    TcpSocket(TcpSocket&& other) noexcept;
    TcpSocket& operator=(TcpSocket&& other) noexcept;

    // Connect to host:port (blocking connect with timeout)
    bool connect(const std::string& host, int port, int timeoutMs = 3000);

    // IByteStream interface
    void close() override;
    bool isOpen() const override { return m_fd >= 0; }
    bool write(const std::string& data) override;
    bool writeByte(u8 byte) override;
    std::optional<std::string> readLine(int timeoutMs) override;
    void drain() override;
    const std::string& device() const override { return m_device; }
    ConnectionState connectionState() const override { return m_connectionState; }

  private:
    int m_fd = -1;
    std::string m_device;       // "host:port" for display
    std::string m_readBuffer;   // Accumulates partial reads
    ConnectionState m_connectionState = ConnectionState::Closed;
};

} // namespace dw
```

Create `src/core/cnc/tcp_socket.cpp` with POSIX implementation:

**connect() method:**
- Create socket: `socket(AF_INET, SOCK_STREAM, 0)`
- Resolve host: Use `getaddrinfo()` with `AI_NUMERICSERV` hint for both DNS names and IP addresses
- Set non-blocking: `fcntl(m_fd, F_SETFL, O_NONBLOCK)` before connect
- Call `::connect()` — will return -1 with EINPROGRESS for non-blocking
- Use `poll()` with POLLOUT and `timeoutMs` to wait for connection
- Check for connection errors: `getsockopt(m_fd, SOL_LEVEL, SO_ERROR, ...)` after poll
- On success: keep non-blocking mode (matches serial port pattern), set TCP_NODELAY to disable Nagle's algorithm (important for real-time CNC commands), store "host:port" in m_device
- On failure: close socket, log error, return false
- Set m_connectionState = ConnectionState::Connected on success

**close() method:**
- If m_fd >= 0: `::close(m_fd)`, set m_fd = -1, log
- Clear m_readBuffer
- Set m_connectionState = ConnectionState::Closed

**write() method:**
- Same retry loop as SerialPort: `::write()` in a loop handling EINTR
- On EPIPE/ECONNRESET: set m_connectionState = Disconnected
- On EAGAIN/EWOULDBLOCK: use poll(POLLOUT) with short timeout, then retry

**writeByte() method:**
- Single `::write(m_fd, &byte, 1)` call
- On EPIPE/ECONNRESET: set m_connectionState = Disconnected

**readLine() method:**
- Nearly identical to SerialPort::readLine() — copy the pattern:
  1. Check m_readBuffer for existing '\n'
  2. poll() with POLLIN and monotonic clock timeout tracking
  3. POLLHUP|POLLERR → Disconnected
  4. read() into buffer, check for '\n', strip '\r'
- The only difference from serial: TCP read() returning 0 means clean disconnect (FIN received), not error

**drain() method:**
- Read and discard: `while (::read(m_fd, buf, sizeof(buf)) > 0) {}`
- Clear m_readBuffer

**Move operations:**
- Same pattern as SerialPort: transfer m_fd, m_device, m_readBuffer, m_connectionState; set source to -1/Closed

**Windows stubs:**
- Follow the same pattern as serial_port.cpp: `#ifdef _WIN32` stubs that log "TCP not yet implemented on Windows" and return false/nullopt

**Platform includes:**
```cpp
#ifdef _WIN32
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <cerrno>
#include <fcntl.h>
#include <netdb.h>
#include <netinet/tcp.h>
#include <poll.h>
#include <sys/socket.h>
#include <unistd.h>
#endif
```

Add `core/cnc/tcp_socket.cpp` to `src/CMakeLists.txt` in the source list, near `serial_port.cpp`.
  </action>
  <verify>
    <automated>cd /data/DW && cmake --build build -j$(nproc) 2>&1 | tail -20</automated>
  </verify>
  <done>TcpSocket class compiles cleanly, implements IByteStream, handles non-blocking connect with timeout, TCP_NODELAY enabled, disconnect detection via poll/read errors, Windows stubs present</done>
</task>

<task type="auto">
  <name>Task 2: Add connectTcp() to CncController and write tests</name>
  <files>src/core/cnc/cnc_controller.h, src/core/cnc/cnc_controller.cpp, tests/test_tcp_socket.cpp, tests/CMakeLists.txt</files>
  <action>
**CncController changes:**

In `cnc_controller.h`, add to the Connection section (after `connectSimulator()`):
```cpp
bool connectTcp(const std::string& host, int port);
```

In `cnc_controller.cpp`, add `#include "tcp_socket.h"` and implement:
```cpp
bool CncController::connectTcp(const std::string& host, int port) {
    disconnect();

    auto sock = std::make_unique<TcpSocket>();
    if (!sock->connect(host, port))
        return false;

    m_port = std::move(sock);

    // Soft-reset to get a clean state (same as serial connect)
    m_port->writeByte(cnc::CMD_SOFT_RESET);
    m_port->drain();

    m_running = true;
    m_connected = false;
    m_consecutiveTimeouts = 0;
    m_statusPending = false;
    m_pendingRtCommands.store(0, std::memory_order_relaxed);
    m_statusPollMs = Config::instance().getStatusPollIntervalMs();
    m_ioThread = std::thread(&CncController::ioThreadFunc, this);

    return true;
}
```

This mirrors the existing `connect()` method exactly, but constructs a TcpSocket instead of a SerialPort. The IO thread runs identically regardless of transport since it uses IByteStream methods.

**Tests (tests/test_tcp_socket.cpp):**

Write unit tests that mirror test_serial_port.cpp patterns (no real network needed):

```cpp
TEST(TcpSocket, DefaultNotOpen) — EXPECT_FALSE(socket.isOpen())
TEST(TcpSocket, DefaultConnectionState) — EXPECT_EQ(socket.connectionState(), ConnectionState::Closed)
TEST(TcpSocket, BadHostReturnsFalse) — connect("invalid.host.that.does.not.exist.example.com", 9999, 500) returns false, isOpen() remains false
TEST(TcpSocket, BadPortReturnsFalse) — connect("127.0.0.1", 1, 500) returns false (port 1 unlikely to be listening)
TEST(TcpSocket, DoubleCloseSafe) — close() twice without crash
TEST(TcpSocket, WriteOnClosedFails) — write("test") returns false, writeByte(0x18) returns false
TEST(TcpSocket, ReadLineOnClosedReturnsNullopt) — readLine(10) returns nullopt
TEST(TcpSocket, MoveConstruction) — move an unopened socket, should not crash
TEST(TcpSocket, MoveAssignment) — move assign an unopened socket
TEST(TcpSocket, DrainOnClosedSafe) — drain() on closed socket doesn't crash
TEST(TcpSocket, DeviceEmptyWhenClosed) — device() returns empty string
```

Add to tests/CMakeLists.txt:
- Add `test_tcp_socket.cpp` to the test source list (near `test_serial_port.cpp`)
- Add `${CMAKE_SOURCE_DIR}/src/core/cnc/tcp_socket.cpp` to the source list (near `serial_port.cpp`)
  </action>
  <verify>
    <automated>cd /data/DW && cmake --build build -j$(nproc) 2>&1 | tail -20 && ctest --test-dir build --output-on-failure -R "TcpSocket|SerialPort|CncController" 2>&1 | tail -30</automated>
  </verify>
  <done>CncController::connectTcp() exists and compiles. TcpSocket tests pass (11+ tests). Existing serial and CNC tests still pass. Connection timeout on bad host/port completes within ~500ms.</done>
</task>

</tasks>

<verification>
1. `cmake --build build -j$(nproc)` compiles without errors
2. `ctest --test-dir build --output-on-failure` — all tests pass including new TcpSocket tests
3. `grep -n "connectTcp" src/core/cnc/cnc_controller.h` confirms method declared
4. `grep -n "class TcpSocket : public IByteStream" src/core/cnc/tcp_socket.h` confirms inheritance
5. `grep -c "TEST(TcpSocket" tests/test_tcp_socket.cpp` shows 10+ tests
</verification>

<success_criteria>
- TcpSocket implements IByteStream with full POSIX TCP socket support
- Non-blocking connect with configurable timeout
- TCP_NODELAY enabled for real-time command responsiveness
- Disconnect detection via POLLHUP/POLLERR/read-returning-0
- CncController::connectTcp() wires TcpSocket into existing IO thread
- Unit tests cover all TcpSocket methods without requiring network
- Windows stubs present for future implementation
</success_criteria>

<output>
After completion, create `.planning/phases/13-tcp-ip-byte-stream-transport-for-cnc-connections/13-02-SUMMARY.md`
</output>
