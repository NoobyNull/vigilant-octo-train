# Phase 1.3: MainThreadQueue & Threading Contracts - Research

**Researched:** 2026-02-08
**Domain:** C++ thread-safe message passing, ImGui threading constraints, debug assertions
**Confidence:** HIGH

## Summary

Phase 1.3 requires implementing a thread-safe message queue for worker threads to post results to the main thread, and establishing threading contracts to prevent ImGui violations. The current codebase already has a working pattern: `ImportQueue` uses `pollCompleted()` with mutex-protected vectors, processing 1-N completed imports per frame in `Application::update()`. This phase will formalize that pattern into a reusable `MainThreadQueue` and add debug assertions to catch violations.

**Key insight:** The codebase already implements the core pattern correctly (mutex + vector, poll-based), but lacks: (1) a reusable abstraction, (2) documented threading contracts, (3) debug assertions to catch violations early.

**Primary recommendation:** Implement bounded queue with mutex + condition variable (standard pattern), integrate as drop-in replacement for `ImportQueue::m_completed`, and add thread ID assertions to UI entry points using existing `GL_CHECK` macro style.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| std::mutex | C++17 | Mutual exclusion | Standard C++ threading primitive, zero dependencies |
| std::condition_variable | C++17 | Thread signaling | Standard producer-consumer pattern, efficient blocking |
| std::queue | C++17 | FIFO message storage | Standard container, type-safe, efficient |
| std::function | C++17 | Type-erased callables | Allows posting arbitrary lambdas/callbacks |
| std::thread::id | C++17 | Thread identification | Thread ownership verification for assertions |
| std::this_thread::get_id() | C++17 | Current thread ID | Used in ASSERT_MAIN_THREAD checks |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| std::atomic | C++17 | Lock-free counters | Queue size queries, shutdown flags |
| std::unique_lock | C++17 | Flexible locking | Required for condition_variable.wait() |
| std::lock_guard | C++17 | RAII locking | Simple critical sections (enqueue) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Mutex-based queue | Lock-free queue | Lock-free adds complexity, not needed for ~60fps message rate |
| std::queue | std::deque | Deque direct, but queue enforces FIFO semantics |
| Bounded queue | Unbounded queue | Unbounded risks memory exhaustion, bounded provides backpressure |
| Polling | Callbacks/events | Polling matches existing pattern, simpler for ImGui frame-driven update |

**Installation:**
```bash
# Already available - C++17 standard library
# No external dependencies needed
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── core/
│   ├── threading/              # New: Thread synchronization utilities
│   │   ├── main_thread_queue.h # MainThreadQueue class
│   │   └── main_thread_queue.cpp
│   └── utils/
│       └── thread_utils.h      # New: ASSERT_MAIN_THREAD macro
tests/
└── test_main_thread_queue.cpp  # Unit tests
docs/
└── THREADING.md                # Threading contracts documentation
```

### Pattern 1: Mutex-Protected Queue with Condition Variable
**What:** Producer-consumer pattern with blocking enqueue and polling dequeue
**When to use:** Background workers post results, main thread polls each frame

**Example:**
```cpp
// Source: Standard C++ producer-consumer pattern
// https://en.cppreference.com/w/cpp/thread/condition_variable

class MainThreadQueue {
public:
    void enqueue(std::function<void()> task) {
        std::unique_lock<std::mutex> lock(m_mutex);

        // Wait if queue is full (bounded queue)
        m_cvFull.wait(lock, [this] {
            return m_queue.size() < m_maxSize || m_shutdown;
        });

        if (m_shutdown) return;

        m_queue.push(std::move(task));
        m_cvEmpty.notify_one();  // Wake consumers
    }

    void processAll() {
        std::vector<std::function<void()>> tasks;
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            while (!m_queue.empty()) {
                tasks.push_back(std::move(m_queue.front()));
                m_queue.pop();
            }
        }
        // Execute outside lock to avoid deadlocks
        for (auto& task : tasks) {
            task();
        }
    }

private:
    std::queue<std::function<void()>> m_queue;
    std::mutex m_mutex;
    std::condition_variable m_cvEmpty, m_cvFull;
    size_t m_maxSize = 1000;
    std::atomic<bool> m_shutdown{false};
};
```

### Pattern 2: Thread ID Assertions (Debug Only)
**What:** Store main thread ID at startup, assert equality on UI operations
**When to use:** Entry points to ImGui, Workspace setters, EventBus

**Example:**
```cpp
// Source: Existing GL_CHECK pattern in src/render/gl_utils.h
// Adapted for thread checking

// In thread_utils.h
namespace dw {
namespace threading {

inline std::thread::id g_mainThreadId;

inline void initMainThread() {
    g_mainThreadId = std::this_thread::get_id();
}

inline bool isMainThread() {
    return std::this_thread::get_id() == g_mainThreadId;
}

} // namespace threading
} // namespace dw

#ifdef NDEBUG
    #define ASSERT_MAIN_THREAD() ((void)0)
#else
    #define ASSERT_MAIN_THREAD() \
        do { \
            if (!dw::threading::isMainThread()) { \
                std::cerr << "THREADING VIOLATION: " << __FILE__ \
                          << ":" << __LINE__ << " - " << __func__ \
                          << " must be called from main thread\n"; \
                std::abort(); \
            } \
        } while (0)
#endif

// Usage in Panel::render()
void Panel::render() {
    ASSERT_MAIN_THREAD();  // Catches cross-thread ImGui calls
    // ... ImGui code ...
}
```

### Pattern 3: Existing ImportQueue Integration
**What:** Replace `ImportQueue::m_completed` vector with MainThreadQueue
**When to use:** This phase - migrate existing pattern to new abstraction

**Current (import_queue.cpp:114-119):**
```cpp
{
    std::lock_guard<std::mutex> lock(m_mutex);
    if (task.stage == ImportStage::WaitingForThumbnail) {
        m_completed.push_back(std::move(task));
    }
}
```

**After (using MainThreadQueue):**
```cpp
if (task.stage == ImportStage::WaitingForThumbnail) {
    m_mainThreadQueue->enqueue([this, task = std::move(task)]() mutable {
        // Thumbnail generation on main thread
        processCompletedImport(std::move(task));
    });
}
```

### Anti-Patterns to Avoid
- **Calling ImGui from worker threads:** ImGui is not thread-safe, all calls must be on main thread
- **Shared mutable state without synchronization:** Even reads need protection if writers exist
- **Condition variable without predicate:** Always use `cv.wait(lock, predicate)` to avoid spurious wakeups
- **Lock ordering violations:** Always acquire locks in consistent order to prevent deadlock
- **Assertions with side effects:** Never put `++i` inside `ASSERT_MAIN_THREAD()` - disabled in release

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Lock-free queue | Custom lock-free MPSC queue | std::mutex + std::queue | Lock-free is complex, not needed for 60fps rate; standard library is tested and debuggable |
| Thread pool | Custom worker thread pool | Single worker (existing) + MainThreadQueue | Current architecture uses single ImportQueue worker; multi-threaded import comes in Phase 2+ |
| Custom logging mutex | Per-module mutexes | Existing `log::g_logMutex` | Already thread-safe (log.cpp:18) |
| Thread-local storage | Manual TLS management | C++17 thread_local keyword | Standard, portable, compiler-optimized |

**Key insight:** The codebase already uses correct primitives (std::mutex in log.cpp, import_queue.cpp). Don't reinvent threading - formalize existing patterns.

## Common Pitfalls

### Pitfall 1: ImGui Threading Violations
**What goes wrong:** Calling ImGui functions from worker threads causes crashes or undefined behavior
**Why it happens:** ImGui is not thread-safe; macOS AppKit requires main-thread-only calls
**How to avoid:**
- All ImGui calls behind `ASSERT_MAIN_THREAD()`
- Worker threads post to MainThreadQueue, never call UI directly
- Document contract: "UI state changes happen in MainThreadQueue callbacks only"

**Warning signs:**
- Crashes in ImGui::Text, ImGui::Begin, etc. with no stack trace
- macOS crashes with "AppKit called from non-main thread"
- Valgrind/ThreadSanitizer reports data races in ImGui code

**Sources:**
- [ImGui Issue #221 - Multithreading](https://github.com/ocornut/imgui/issues/221)
- [ImGui Issue #2932 - Thread safety of draw calls](https://github.com/ocornut/imgui/issues/2932)

### Pitfall 2: Deadlock from Lock Ordering
**What goes wrong:** Thread A locks mutex1 then mutex2; Thread B locks mutex2 then mutex1 → deadlock
**Why it happens:** Inconsistent lock acquisition order between threads
**How to avoid:**
- Document lock hierarchy in THREADING.md
- Current locks: `ImportQueue::m_mutex`, `log::g_logMutex`, `MainThreadQueue::m_mutex`
- Rule: Never hold `ImportQueue::m_mutex` when acquiring `MainThreadQueue::m_mutex`
- Execute callbacks outside lock (Pattern 1 shows this)

**Warning signs:**
- Application hangs with 100% CPU usage
- Debugger shows threads waiting on mutexes
- ThreadSanitizer reports "lock-order-inversion"

### Pitfall 3: Spurious Wakeups from Condition Variables
**What goes wrong:** `cv.wait()` returns even though condition not met
**Why it happens:** OS threading implementation allows spurious wakeups
**How to avoid:** Always use predicate form: `cv.wait(lock, [this] { return condition; })`
**Warning signs:** Queue processed when empty, double-processing of items

**Example (WRONG):**
```cpp
cv.wait(lock);  // WRONG - no predicate
if (!m_queue.empty()) { ... }
```

**Example (CORRECT):**
```cpp
cv.wait(lock, [this] { return !m_queue.empty() || m_shutdown; });
```

**Source:** [C++ Reference - condition_variable](https://en.cppreference.com/w/cpp/thread/condition_variable)

### Pitfall 4: Bounded Queue Starvation
**What goes wrong:** Producer blocks forever because consumer stopped processing
**Why it happens:** Bounded queue full, consumer not draining (e.g., UI frozen)
**How to avoid:**
- Set reasonable bound (1000 messages at 60fps = 16 seconds of backlog)
- Add timeout to enqueue: `cv.wait_for(lock, 100ms, predicate)`
- Log warning if queue > 80% full

**Warning signs:** Worker thread hangs, import progress stops, UI responsive but no updates

### Pitfall 5: ASSERT_MAIN_THREAD with Side Effects
**What goes wrong:** `ASSERT_MAIN_THREAD(++counter)` - counter not incremented in release builds
**Why it happens:** NDEBUG disables macro to `((void)0)`, argument not evaluated
**How to avoid:** Never put side effects in assertions
**Warning signs:** Different behavior in debug vs release, missing updates in production

**Example (WRONG):**
```cpp
ASSERT_MAIN_THREAD(workspace->setFocusedMesh(mesh));  // setFocusedMesh not called in release!
```

**Example (CORRECT):**
```cpp
ASSERT_MAIN_THREAD();
workspace->setFocusedMesh(mesh);
```

**Source:** [C++ Reference - assert](https://en.cppreference.com/w/cpp/error/assert)

## Code Examples

Verified patterns from official sources:

### Producer-Consumer with Bounded Queue
```cpp
// Source: https://en.cppreference.com/w/cpp/thread/condition_variable
// Adapted for MainThreadQueue bounded queue pattern

#include <condition_variable>
#include <functional>
#include <mutex>
#include <queue>

class MainThreadQueue {
public:
    explicit MainThreadQueue(size_t maxSize = 1000)
        : m_maxSize(maxSize) {}

    // Called from worker threads
    void enqueue(std::function<void()> task) {
        std::unique_lock<std::mutex> lock(m_mutex);

        // Block if queue full
        m_cvFull.wait(lock, [this] {
            return m_queue.size() < m_maxSize || m_shutdown;
        });

        if (m_shutdown) return;

        m_queue.push(std::move(task));
        m_size.fetch_add(1);  // Atomic for lock-free size queries
        m_cvEmpty.notify_one();
    }

    // Called from main thread each frame
    void processAll() {
        std::vector<std::function<void()>> tasks;
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            while (!m_queue.empty()) {
                tasks.push_back(std::move(m_queue.front()));
                m_queue.pop();
                m_size.fetch_sub(1);
            }
            m_cvFull.notify_all();  // Wake blocked producers
        }

        // Execute outside lock to prevent deadlocks
        for (auto& task : tasks) {
            task();
        }
    }

    // Thread-safe size query (lock-free)
    size_t size() const {
        return m_size.load();
    }

    void shutdown() {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_shutdown = true;
        }
        m_cvEmpty.notify_all();
        m_cvFull.notify_all();
    }

private:
    std::queue<std::function<void()>> m_queue;
    std::mutex m_mutex;
    std::condition_variable m_cvEmpty, m_cvFull;
    size_t m_maxSize;
    std::atomic<size_t> m_size{0};
    std::atomic<bool> m_shutdown{false};
};
```

### Thread Ownership Assertions
```cpp
// Source: Adapted from existing GL_CHECK pattern (src/render/gl_utils.h:14-22)
// Pattern: NDEBUG-disabled debug checks

// thread_utils.h
#pragma once
#include <thread>
#include <iostream>

namespace dw {
namespace threading {

// Store main thread ID at Application::init()
inline std::thread::id g_mainThreadId;

inline void initMainThread() {
    g_mainThreadId = std::this_thread::get_id();
}

inline bool isMainThread() {
    return std::this_thread::get_id() == g_mainThreadId;
}

} // namespace threading
} // namespace dw

// Debug-only assertion macro (disabled in release builds)
#ifdef NDEBUG
    #define ASSERT_MAIN_THREAD() ((void)0)
#else
    #define ASSERT_MAIN_THREAD() \
        do { \
            if (!dw::threading::isMainThread()) { \
                std::cerr << "THREADING VIOLATION: " << __FILE__ \
                          << ":" << __LINE__ << " - " << __func__ \
                          << " must be called from main thread\n"; \
                std::abort(); \
            } \
        } while (0)
#endif

// Usage examples:
// In Application::init():
//   threading::initMainThread();
//
// In Panel::render():
//   ASSERT_MAIN_THREAD();
//   ImGui::Begin(m_title.c_str());
//
// In Workspace::setFocusedMesh():
//   ASSERT_MAIN_THREAD();
//   m_focusedMesh = std::move(mesh);
```

### Integration with Application::update()
```cpp
// Source: Existing pattern in application.cpp:354-361

// Current (application.cpp:354-356)
void Application::update() {
    processCompletedImports();

    // Poll config watcher for live settings reload
    if (m_configWatcher) {
        m_configWatcher->poll(SDL_GetTicks64());
    }
}

// After MainThreadQueue integration
void Application::update() {
    // Process all pending main-thread tasks
    if (m_mainThreadQueue) {
        m_mainThreadQueue->processAll();
    }

    // Poll config watcher
    if (m_configWatcher) {
        m_configWatcher->poll(SDL_GetTicks64());
    }
}

// processCompletedImports() logic moves into ImportQueue callbacks:
// m_mainThreadQueue->enqueue([this, task]() {
//     // Thumbnail generation
//     // Library panel refresh
//     // Workspace update
// });
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Direct std::vector with mutex | std::queue + condition_variable | C++11 | Proper blocking, no busy-wait polling |
| Unbounded queues | Bounded queues with backpressure | Modern practice | Prevents memory exhaustion, provides flow control |
| Thread ID as int | std::thread::id type | C++11 | Type-safe, portable across platforms |
| Manual thread_local emulation | thread_local keyword | C++11 | Compiler-optimized, standard syntax |
| assert() for threading | Custom ASSERT_MAIN_THREAD | Domain-specific | Clearer error messages, domain context |

**Deprecated/outdated:**
- pthread mutexes: Use std::mutex (portable, RAII-friendly)
- Spin locks for user-space: Use std::mutex (kernel handles scheduling efficiently)
- Manual condition variable loops: Use predicate form of wait() (prevents spurious wakeup bugs)

## Open Questions

1. **Queue size bound for typical workloads**
   - What we know: ImportQueue processes 1-N files per batch, ~5-10 stages per file, frame rate 60fps
   - What's unclear: Worst-case batch size (100 files? 1000?)
   - Recommendation: Start with 1000 (16 seconds at 60fps), add telemetry to measure peak usage

2. **Should MainThreadQueue support priorities?**
   - What we know: Current ImportQueue is FIFO, no priority needed
   - What's unclear: Future features (real-time preview, cancellation) may need priorities
   - Recommendation: Implement FIFO only for Phase 1.3, add priority in future phase if needed

3. **Timeout behavior if queue full**
   - What we know: Blocking forever risks deadlock if consumer stops
   - What's unclear: Should enqueue timeout and return error, or log warning and block?
   - Recommendation: Block with timeout (100ms), log warning if queue consistently full

4. **Move processCompletedImports() into ImportQueue or keep in Application?**
   - What we know: Application.cpp currently handles thumbnail generation (line 696-728)
   - What's unclear: Should this move to ImportQueue::onCompleted callback?
   - Recommendation: Keep in Application for Phase 1.3 (minimize churn), refactor in Phase 1.4 (god class decomposition)

## Sources

### Primary (HIGH confidence)
- [C++ Reference - condition_variable](https://en.cppreference.com/w/cpp/thread/condition_variable) - Standard library threading primitives
- [C++ Reference - std::this_thread::get_id](https://en.cppreference.com/w/cpp/thread/get_id.html) - Thread identification
- [C++ Reference - assert](https://en.cppreference.com/w/cpp/error/assert.html) - NDEBUG and assertion behavior
- Existing codebase patterns:
  - `src/render/gl_utils.h:14-22` - Debug-only macro pattern
  - `src/core/utils/log.cpp:18,64` - Mutex usage for thread safety
  - `src/core/import/import_queue.cpp:57-62,114-119` - Poll-based pattern with mutex

### Secondary (MEDIUM confidence)
- [ImGui Issue #221 - Multithreading](https://github.com/ocornut/imgui/issues/221) - ImGui not thread-safe, main-thread-only
- [ImGui Issue #2932 - Thread safety of draw calls](https://github.com/ocornut/imgui/issues/2932) - ImGui threading requirements
- [GeeksforGeeks - Thread-safe queue in C++](https://www.geeksforgeeks.org/dsa/implement-thread-safe-queue-in-c/) - Producer-consumer pattern examples
- [1024cores - Producer-Consumer Queues](https://www.1024cores.net/home/lock-free-algorithms/queues) - Bounded vs unbounded queue tradeoffs
- [C++ Concurrent Queues Proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p0260r6.html) - Bounded queue semantics

### Tertiary (LOW confidence)
- [Medium - Multithreading with C++ Producer-Consumer](https://medium.com/nerd-for-tech/hands-on-multithreading-with-c-04-producer-consumer-problem-26abdddc485d) - Tutorial implementation
- [GitHub - K-Adam/SafeQueue](https://github.com/K-Adam/SafeQueue) - Example implementation

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - C++17 standard library, widely used, documented
- Architecture: HIGH - Existing codebase uses correct patterns (mutex + poll), formalizing proven approach
- Pitfalls: HIGH - ImGui threading documented in official issues, std assert pitfalls well-known

**Research date:** 2026-02-08
**Valid until:** ~90 days (C++17 stable, ImGui threading constraints unchanged since 2015)

**Key findings:**
1. Current `ImportQueue::pollCompleted()` pattern is correct - mutex + vector + poll
2. MainThreadQueue should be bounded (1000 messages) with condition variable for efficiency
3. ImGui is definitively NOT thread-safe, all UI calls must be main-thread
4. Thread ID assertions follow existing `GL_CHECK` macro pattern (NDEBUG-disabled)
5. No external dependencies needed - C++17 standard library sufficient
