---
phase: 01.3-mainthreadqueue
plan: 02
type: execute
wave: 2
depends_on: ["1.3-01"]
files_modified:
  - src/app/application.h
  - src/app/application.cpp
  - src/core/events/event_bus.h
  - src/ui/panels/panel.h
  - src/app/workspace.cpp
  - docs/THREADING.md
autonomous: true

must_haves:
  truths:
    - "Application::update() calls MainThreadQueue::processAll() every frame"
    - "MainThreadQueue is initialized before ImportQueue and destroyed after it"
    - "Panel::render() asserts main thread in debug builds"
    - "Workspace setters assert main thread in debug builds"
    - "EventBus::publish() asserts main thread in debug builds"
    - "Threading contracts are documented with rules for each subsystem"
  artifacts:
    - path: "src/app/application.h"
      provides: "MainThreadQueue member declaration"
      contains: "MainThreadQueue"
    - path: "src/app/application.cpp"
      provides: "MainThreadQueue lifecycle and processAll() call in update()"
      contains: "processAll"
    - path: "src/core/events/event_bus.h"
      provides: "ASSERT_MAIN_THREAD in publish()"
      contains: "ASSERT_MAIN_THREAD"
    - path: "src/ui/panels/panel.h"
      provides: "ASSERT_MAIN_THREAD in render()"
      contains: "ASSERT_MAIN_THREAD"
    - path: "src/app/workspace.cpp"
      provides: "ASSERT_MAIN_THREAD in setters"
      contains: "ASSERT_MAIN_THREAD"
    - path: "docs/THREADING.md"
      provides: "Threading contracts documentation"
      contains: "Threading Contracts"
  key_links:
    - from: "src/app/application.cpp"
      to: "src/core/threading/main_thread_queue.h"
      via: "include and member usage"
      pattern: "m_mainThreadQueue->processAll"
    - from: "src/app/application.cpp"
      to: "src/core/utils/thread_utils.h"
      via: "threading::initMainThread() call in init()"
      pattern: "threading::initMainThread"
    - from: "src/ui/panels/panel.h"
      to: "src/core/utils/thread_utils.h"
      via: "ASSERT_MAIN_THREAD in render()"
      pattern: "ASSERT_MAIN_THREAD"
    - from: "src/core/events/event_bus.h"
      to: "src/core/utils/thread_utils.h"
      via: "ASSERT_MAIN_THREAD in publish()"
      pattern: "ASSERT_MAIN_THREAD"
---

<objective>
Integrate MainThreadQueue into Application lifecycle and add debug threading assertions to all main-thread-only entry points (Panel::render, Workspace setters, EventBus::publish). Document threading contracts in docs/THREADING.md.

Purpose: Without integration, MainThreadQueue is unused infrastructure. Without assertions, threading violations are silent. Without documentation, the threading model is tribal knowledge. This plan wires everything together and makes violations crash-early in debug.

Output: Working integration, debug assertions at all UI entry points, THREADING.md documentation.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.3-mainthreadqueue/1.3-01-SUMMARY.md
@.planning/phases/01.3-mainthreadqueue/1.3-RESEARCH.md
@src/app/application.h
@src/app/application.cpp
@src/core/events/event_bus.h
@src/ui/panels/panel.h
@src/app/workspace.h
@src/app/workspace.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate MainThreadQueue into Application and add threading assertions</name>
  <files>
    src/app/application.h
    src/app/application.cpp
    src/core/events/event_bus.h
    src/ui/panels/panel.h
    src/app/workspace.cpp
  </files>
  <action>
    **application.h changes:**
    1. Add forward declaration: `class MainThreadQueue;` (alongside existing forward declarations)
    2. Add member: `std::unique_ptr<MainThreadQueue> m_mainThreadQueue;` in the "Core systems" section, BEFORE m_importQueue (initialization order matters -- MainThreadQueue must exist before ImportQueue starts posting to it)
    3. Add accessor: `auto mainThreadQueue() -> MainThreadQueue&;` in the public section (for subsystems to post tasks)

    **application.cpp changes:**
    1. Add include: `#include "core/threading/main_thread_queue.h"` and `#include "core/utils/thread_utils.h"`
    2. In Application::init(), BEFORE EventBus creation (very first thing after paths/config setup, around line 160-161):
       - Add: `dw::threading::initMainThread();` -- this records the main thread ID for all assertions
       - Add: `m_mainThreadQueue = std::make_unique<MainThreadQueue>();` -- uses default 1000 bound
    3. In Application::update(), REPLACE `processCompletedImports();` with:
       ```
       // Process all pending main-thread tasks (from worker threads)
       if (m_mainThreadQueue) {
           m_mainThreadQueue->processAll();
       }

       // Process completed imports (thumbnail generation needs GL context)
       processCompletedImports();
       ```
       NOTE: Keep processCompletedImports() for now -- migration of ImportQueue to use MainThreadQueue is deferred to Phase 1.4 (god class decomposition) per research recommendation #4. This plan only adds the queue processing; the ImportQueue migration happens when Application is refactored.
    4. Add accessor implementation:
       ```
       auto Application::mainThreadQueue() -> MainThreadQueue& {
           return *m_mainThreadQueue;
       }
       ```
    5. In Application::shutdown(), add `m_mainThreadQueue->shutdown();` and then `m_mainThreadQueue.reset();` AFTER m_importQueue.reset() (worker must finish before queue is destroyed) but BEFORE m_eventBus.reset(). The shutdown sequence should be:
       ```
       m_importQueue.reset();     // Joins worker thread -- worker may still enqueue during join
       m_mainThreadQueue->shutdown(); // Signal no more processing
       m_mainThreadQueue.reset(); // Destroy queue
       ```
       Place these lines in the existing "Destroy core systems" section, adjusting the order.

    **event_bus.h changes:**
    1. Add include: `#include "core/utils/thread_utils.h"` at the top (alongside existing includes)
    2. In the publish() template method, add `ASSERT_MAIN_THREAD();` as the FIRST line of the method body (before the type_index lookup). This enforces the "EventBus is main-thread-only" contract documented in STATE.md Decision #6.

    **panel.h changes:**
    1. Add include: `#include "core/utils/thread_utils.h"` at the top
    2. Change render() from pure virtual to a non-virtual public method that asserts then delegates:
       ```
       // Called each frame to render the panel
       void render() {
           ASSERT_MAIN_THREAD();
           renderImpl();
       }
       ```
       And add a new protected pure virtual: `virtual void renderImpl() = 0;`

       WAIT -- this would break ALL panel subclasses (they override render()). Instead, use the simpler approach: keep render() as pure virtual, and document that subclasses should call ASSERT_MAIN_THREAD() at the top. BUT that's scattered and unreliable.

       BETTER APPROACH: Add a non-virtual wrapper. Rename the virtual to doRender():
       - NO, this still breaks subclasses.

       SIMPLEST CORRECT APPROACH: Keep render() as-is (pure virtual). Add the assertion to the base class documentation comment only. The real enforcement happens in Application::renderPanels() which is already on the main thread. The ASSERT_MAIN_THREAD assertions on Workspace and EventBus are sufficient to catch cross-thread violations. Panel::render() is always called from Application::render() which is on the main thread by construction.

       FINAL DECISION: Do NOT change Panel::render(). Instead, add ASSERT_MAIN_THREAD() to Application::renderPanels() at the top of that method. This is a single assertion point that covers all panels without breaking any subclasses.

    So for panel.h: Add the include for thread_utils.h, and add a comment to the render() declaration:
    ```
    // Called each frame to render the panel (main thread only)
    virtual void render() = 0;
    ```

    In application.cpp, add ASSERT_MAIN_THREAD() as the first line of Application::renderPanels().

    **workspace.cpp changes:**
    1. Add include: `#include "core/utils/thread_utils.h"` at the top
    2. Add `ASSERT_MAIN_THREAD();` as the first line of:
       - Workspace::setFocusedMesh()
       - Workspace::setFocusedGCode()
       - Workspace::setFocusedCutPlan()
       - Workspace::clearFocusedMesh()
       - Workspace::clearFocusedGCode()
       - Workspace::clearFocusedCutPlan()
       - Workspace::clearAll()
    These are all state-mutation methods that affect what the UI renders. They must only be called from the main thread.
  </action>
  <verify>
    ```bash
    cd /data/DW && cmake --build build --target dw_tests 2>&1 | tail -20
    cd /data/DW && ./build/tests/dw_tests 2>&1 | tail -5
    cd /data/DW && cmake --build build --target digital_workshop 2>&1 | tail -10
    ```
    All tests pass. Main application builds without errors.
  </verify>
  <done>
    - threading::initMainThread() called in Application::init() before any subsystem creation
    - MainThreadQueue::processAll() called every frame in Application::update()
    - ASSERT_MAIN_THREAD() present in EventBus::publish(), Application::renderPanels(), all Workspace setters/clearers
    - MainThreadQueue lifecycle correct: created early, shutdown after ImportQueue, destroyed before EventBus
    - All existing tests pass, application compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Create threading contracts documentation</name>
  <files>
    docs/THREADING.md
  </files>
  <action>
    Create the docs/ directory if it does not exist, then create docs/THREADING.md with the following content:

    # Threading Contracts -- Digital Workshop

    ## Overview
    Document the threading model, who owns what thread, lock hierarchy, and contracts for each subsystem. Debug assertions (ASSERT_MAIN_THREAD) enforce these contracts at runtime in debug builds.

    ## Thread Inventory
    1. **Main Thread** -- SDL event loop, ImGui rendering, EventBus dispatch, Workspace state, MainThreadQueue processing. Identified by threading::initMainThread() called in Application::init().
    2. **Import Worker Thread** -- Spawned by ImportQueue::enqueue(), runs ImportQueue::workerLoop(). Reads files, parses meshes, writes to database. Posts completed tasks to m_completed vector (currently) or MainThreadQueue (future).
    3. **Future worker threads** -- Any additional background work (e.g., optimizer, batch export) must follow the same pattern: do work off-thread, post results to MainThreadQueue.

    ## Threading Rules
    1. **ImGui is NOT thread-safe.** All ImGui calls must happen on the main thread. Panel::render() is always called from Application::render() on the main thread.
    2. **EventBus is main-thread-only.** No internal synchronization. publish() includes ASSERT_MAIN_THREAD(). Workers must not publish events directly -- post a lambda to MainThreadQueue that publishes.
    3. **Workspace is main-thread-only.** All setters (setFocusedMesh, etc.) include ASSERT_MAIN_THREAD(). Workers must not modify workspace state directly.
    4. **MainThreadQueue is the bridge.** Thread-safe enqueue from any thread, processAll() on main thread only. This is the ONLY safe way for workers to affect UI state.
    5. **Database connections are per-thread** (future -- ConnectionPool in Phase 1.2). Never share a sqlite3* handle across threads.
    6. **Log is thread-safe.** log::g_logMutex protects all log writes. Safe to call from any thread.

    ## Lock Hierarchy
    To prevent deadlocks, always acquire locks in this order:
    1. MainThreadQueue::m_mutex
    2. ImportQueue::m_mutex
    3. log::g_logMutex

    Never hold a higher-numbered lock when acquiring a lower-numbered one.

    ## ASSERT_MAIN_THREAD Usage
    - Defined in src/core/utils/thread_utils.h
    - Active in debug builds (NDEBUG not defined), no-op in release
    - Call threading::initMainThread() once at startup (Application::init)
    - Add ASSERT_MAIN_THREAD() to any function that must only run on main thread
    - Currently enforced at: EventBus::publish(), Workspace setters, Application::renderPanels(), MainThreadQueue::processAll()

    ## Pattern: Worker-to-UI Communication
    ```cpp
    // WRONG: Worker thread calling UI directly
    void ImportQueue::workerLoop() {
        // ... process task ...
        workspace->setFocusedMesh(mesh);  // CRASH in debug, UB in release
    }

    // RIGHT: Worker posts to MainThreadQueue
    void ImportQueue::workerLoop() {
        // ... process task ...
        mainThreadQueue->enqueue([mesh]() {
            workspace->setFocusedMesh(mesh);  // Runs on main thread
        });
    }
    ```

    ## Subsystem Threading Summary
    | Subsystem | Thread Safety | Assertions |
    |-----------|--------------|------------|
    | ImGui | NOT safe | Via renderPanels() |
    | EventBus | Main-thread-only | publish() |
    | Workspace | Main-thread-only | All setters |
    | MainThreadQueue | Thread-safe (enqueue any, process main) | processAll() |
    | ImportQueue | Internal mutex | None (worker is private) |
    | Log | Thread-safe (g_logMutex) | None needed |
    | Database | NOT safe (single connection) | None yet (Phase 1.2) |
  </action>
  <verify>
    ```bash
    test -f /data/DW/docs/THREADING.md && echo "THREADING.md exists" || echo "MISSING"
    wc -l /data/DW/docs/THREADING.md  # Should be 60+ lines
    ```
  </verify>
  <done>
    - docs/THREADING.md exists with complete threading contracts
    - Document covers: thread inventory, rules, lock hierarchy, assertion usage, worker-to-UI pattern, subsystem summary table
    - Consistent with actual implementation from Task 1
  </done>
</task>

</tasks>

<verification>
```bash
# Full test suite passes
cd /data/DW && cmake --build build --target dw_tests 2>&1 | tail -5
cd /data/DW && ./build/tests/dw_tests 2>&1 | tail -5

# Main application builds
cd /data/DW && cmake --build build --target digital_workshop 2>&1 | tail -5

# Threading files exist
test -f /data/DW/docs/THREADING.md && echo "OK: THREADING.md"
grep -l "ASSERT_MAIN_THREAD" /data/DW/src/core/events/event_bus.h /data/DW/src/app/workspace.cpp /data/DW/src/app/application.cpp

# MainThreadQueue is called in update loop
grep "processAll" /data/DW/src/app/application.cpp

# initMainThread called at startup
grep "initMainThread" /data/DW/src/app/application.cpp
```
</verification>

<success_criteria>
- MainThreadQueue integrated into Application lifecycle (init, update, shutdown)
- threading::initMainThread() called at Application startup
- ASSERT_MAIN_THREAD() in EventBus::publish(), renderPanels(), all Workspace mutators
- docs/THREADING.md documents all threading contracts
- All existing tests pass (387+), application compiles and runs
- No behavioral changes to the application (NR1 compliance)
</success_criteria>

<output>
After completion, create `.planning/phases/01.3-mainthreadqueue/1.3-02-SUMMARY.md`
</output>
