---
phase: 01.3-mainthreadqueue
plan: 02
subsystem: threading
tags: [integration, thread-safety, assertions, documentation]
dependency_graph:
  requires:
    - MainThreadQueue (from 1.3-01)
    - thread_utils (from 1.3-01)
  provides:
    - Application with MainThreadQueue integration
    - Threading assertions on all UI entry points
    - Threading contracts documentation
  affects:
    - Application (lifecycle integration)
    - EventBus (main-thread-only enforcement)
    - Workspace (setter assertions)
    - All UI panels (via renderPanels assertion)
tech_stack:
  added: []
  patterns:
    - Main thread initialization at app startup
    - Per-frame queue processing in update loop
    - Lifecycle ordering (MainThreadQueue before ImportQueue)
    - Debug-only assertions for threading violations
key_files:
  created:
    - docs/THREADING.md
  modified:
    - src/app/application.h
    - src/app/application.cpp
    - src/core/events/event_bus.h
    - src/ui/panels/panel.h
    - src/app/workspace.cpp
    - src/CMakeLists.txt
    - tests/test_event_bus.cpp
decisions:
  - title: Panel::render() Assertion Location
    rationale: Adding assertion to Application::renderPanels() covers all panels without breaking subclass overrides
    alternatives: Change Panel::render() to non-virtual wrapper (breaks existing code), add to each subclass (scattered/unreliable)
    outcome: Single assertion in Application::renderPanels() at top of method
  - title: MainThreadQueue Lifecycle Position
    rationale: Must exist before ImportQueue (worker may post), must shutdown after ImportQueue joins (worker may post during join)
    alternatives: Create later in init (risk of null pointer), shutdown before ImportQueue (worker posts fail)
    outcome: Create early before EventBus, shutdown after ImportQueue reset
  - title: Test Fixture for EventBus
    rationale: EventBus now requires initMainThread() before publish() works
    alternatives: Call initMainThread() in each test (repetitive), remove assertion (defeats purpose)
    outcome: EventBusTest fixture with SetUp() calling initMainThread()
metrics:
  duration: 250s (4m 10s)
  tasks_completed: 2
  tests_added: 0
  tests_passing: 410
  files_created: 1
  files_modified: 7
  commits: 2
  completed_date: 2026-02-09
---

# Phase 1.3 Plan 02: MainThreadQueue Integration and Threading Assertions

**One-liner:** Integrated MainThreadQueue into Application lifecycle with per-frame processing, added debug threading assertions to all main-thread-only entry points, and documented threading contracts.

## Overview

Wired MainThreadQueue into Application's init/update/shutdown lifecycle, added ASSERT_MAIN_THREAD() debug assertions to all UI entry points (EventBus::publish, Workspace setters, Application::renderPanels), and created comprehensive threading contracts documentation in docs/THREADING.md.

**Purpose:** Without integration, MainThreadQueue is unused infrastructure. Without assertions, threading violations are silent until production crashes. Without documentation, the threading model is tribal knowledge. This plan makes the threading model explicit, enforced, and documented.

## What Was Built

### Application Integration

**Initialization (Application::init()):**
```cpp
// Before any subsystems
dw::threading::initMainThread();  // Record main thread ID

// Core systems initialization order
m_mainThreadQueue = std::make_unique<MainThreadQueue>();  // BEFORE ImportQueue
m_eventBus = std::make_unique<EventBus>();
// ... other systems ...
m_importQueue = std::make_unique<ImportQueue>(*m_connectionPool);  // AFTER MainThreadQueue
```

**Update Loop (Application::update()):**
```cpp
// Process all pending main-thread tasks (from worker threads)
if (m_mainThreadQueue) {
    m_mainThreadQueue->processAll();  // Every frame, before imports
}

// Process completed imports (thumbnail generation needs GL context)
processCompletedImports();
```

**Shutdown (Application::shutdown()):**
```cpp
// Correct order: worker joins → queue shutdown → queue destroy
m_importQueue.reset();         // Joins worker thread (may still enqueue during join)
m_mainThreadQueue->shutdown(); // Signal no more processing
m_mainThreadQueue.reset();     // Destroy queue
```

### Threading Assertions Added

**EventBus::publish()** — Main-thread-only contract enforcement:
```cpp
template <typename EventType>
void publish(const EventType& event) {
    ASSERT_MAIN_THREAD();  // First line of method
    // ... existing publish logic ...
}
```

**Application::renderPanels()** — ImGui is NOT thread-safe:
```cpp
void Application::renderPanels() {
    ASSERT_MAIN_THREAD();  // Covers all Panel::render() calls
    // ... render all panels ...
}
```

**Workspace setters** — All 7 state-mutation methods:
- setFocusedMesh()
- setFocusedGCode()
- setFocusedCutPlan()
- clearFocusedMesh()
- clearFocusedGCode()
- clearFocusedCutPlan()
- clearAll()

Each includes `ASSERT_MAIN_THREAD()` as first line.

### Threading Contracts Documentation

Created `docs/THREADING.md` (60 lines) covering:
- **Thread Inventory:** Main, import worker, future workers
- **Threading Rules:** ImGui NOT thread-safe, EventBus main-thread-only, Workspace main-thread-only, MainThreadQueue as bridge, database per-thread, log thread-safe
- **Lock Hierarchy:** MainThreadQueue::m_mutex → ImportQueue::m_mutex → log::g_logMutex
- **ASSERT_MAIN_THREAD Usage:** Where defined, when active, current enforcement points
- **Worker-to-UI Pattern:** WRONG (direct call) vs RIGHT (enqueue lambda)
- **Subsystem Summary Table:** Thread safety and assertion status for each subsystem

## Technical Decisions

### 1. Panel::render() Assertion Location

**Decision:** Add ASSERT_MAIN_THREAD() to Application::renderPanels() instead of changing Panel::render().

**Rationale:**
- Changing Panel::render() from pure virtual to wrapper would break all 7 panel subclasses
- Each subclass overrides render() — changing signature requires updating all
- Application::renderPanels() is the single call site for all panel rendering

**Alternative considered:** Non-virtual wrapper (rename render() to doRender(), add public render() that asserts then calls doRender())

**Why rejected:** Breaks existing code, requires updating all panel subclasses, adds indirection for no benefit when single call site exists.

**Implementation:** Single assertion at top of Application::renderPanels() covers all panels.

### 2. MainThreadQueue Lifecycle Position

**Decision:** Create MainThreadQueue early (before EventBus), shutdown after ImportQueue joins.

**Rationale:**
- Worker thread may post to queue at any time during execution
- ImportQueue::~ImportQueue() joins worker thread — worker may still enqueue during join
- Queue must exist before worker starts, must accept messages until worker fully stopped

**Initialization order:**
1. initMainThread() — FIRST
2. MainThreadQueue — BEFORE ImportQueue
3. EventBus, Database, etc.
4. ImportQueue — AFTER MainThreadQueue

**Shutdown order:**
1. ImportQueue.reset() — Joins worker (may still enqueue)
2. MainThreadQueue.shutdown() — Signal no more processing
3. MainThreadQueue.reset() — Destroy queue

**Alternative considered:** Create MainThreadQueue later (alongside ImportQueue)

**Why rejected:** Temporal coupling — if another subsystem needs MainThreadQueue before ImportQueue, we'd have to refactor again. Early initialization is safer.

### 3. Test Fixture for EventBus

**Decision:** Add EventBusTest fixture with SetUp() calling initMainThread().

**Rationale:**
- EventBus::publish() now includes ASSERT_MAIN_THREAD()
- Tests abort without initMainThread() call
- All 10 EventBus tests need same setup

**Implementation:**
```cpp
class EventBusTest : public ::testing::Test {
protected:
    void SetUp() override {
        dw::threading::initMainThread();
    }
};

TEST_F(EventBusTest, SubscribeAndReceive_SingleSubscriber) { ... }
```

**Alternative considered:** Call initMainThread() at start of each test.

**Why rejected:** Repetitive, error-prone (easy to forget in new tests), fixture is standard pattern.

## Deviations from Plan

**None** — Plan executed exactly as written. All integration points, assertions, and documentation created as specified.

## Files

**Created:**
- `docs/THREADING.md` — Threading contracts documentation (60 lines)

**Modified:**
- `src/app/application.h` — Added MainThreadQueue forward decl, member, accessor
- `src/app/application.cpp` — Integration (init, update, shutdown, accessor), renderPanels assertion
- `src/core/events/event_bus.h` — Added ASSERT_MAIN_THREAD to publish()
- `src/ui/panels/panel.h` — Updated render() comment, added thread_utils include
- `src/app/workspace.cpp` — Added ASSERT_MAIN_THREAD to all setters/clearers
- `src/CMakeLists.txt` — Added core/threading/main_thread_queue.cpp to build
- `tests/test_event_bus.cpp` — Added EventBusTest fixture, changed TEST to TEST_F

**Total:** 1 file created, 7 files modified

## Commits

1. **1421af0** — `feat(1.3-02): integrate MainThreadQueue into Application lifecycle`
   - Initialize main thread ID at startup
   - Create MainThreadQueue before ImportQueue
   - Call processAll() every frame in update()
   - Add assertions to EventBus, renderPanels, Workspace
   - Update shutdown sequence
   - Add MainThreadQueue to main executable build
   - Update EventBus tests with fixture

2. **65115c5** — `docs(1.3-02): create threading contracts documentation`
   - Created docs/THREADING.md with complete threading model
   - Documented thread inventory, rules, lock hierarchy
   - Provided worker-to-UI pattern examples
   - Included subsystem threading summary table

## Verification

✓ **Build succeeds:** cmake --build build --target digital_workshop (no errors)
✓ **All tests pass:** 410/410 tests passing (no regressions)
✓ **MainThreadQueue called:** processAll() in Application::update()
✓ **Threading initialized:** initMainThread() in Application::init()
✓ **Assertions present:** ASSERT_MAIN_THREAD in EventBus, Workspace, Application
✓ **Documentation exists:** docs/THREADING.md created (60 lines)
✓ **Lifecycle correct:** MainThreadQueue created early, shutdown after ImportQueue

## Next Steps

**Phase 1.3 Complete** — Both plans executed:
- Plan 01: MainThreadQueue core implementation (TDD RED→GREEN)
- Plan 02: Integration into Application and documentation

**Phase 1.4 God Class Decomposition** — Next sub-phase:
- Extract UIManager from Application
- Extract FileIOManager from Application
- Migrate ImportQueue to use MainThreadQueue for completed tasks
- Reduce Application.cpp from 1,071 lines to ~300 lines

**MainThreadQueue usage deferred:**
- ImportQueue still uses m_completed vector for results
- Migration happens during Phase 1.4 Application decomposition
- Current integration provides infrastructure for future refactoring

## Self-Check: PASSED

**Created files exist:**
```
✓ FOUND: docs/THREADING.md (60 lines)
```

**Modified files contain expected changes:**
```
✓ FOUND: threading::initMainThread() in application.cpp
✓ FOUND: m_mainThreadQueue->processAll() in application.cpp
✓ FOUND: ASSERT_MAIN_THREAD() in event_bus.h
✓ FOUND: ASSERT_MAIN_THREAD() in workspace.cpp (7 locations)
✓ FOUND: ASSERT_MAIN_THREAD() in application.cpp (renderPanels)
✓ FOUND: core/threading/main_thread_queue.cpp in CMakeLists.txt
```

**Commits exist:**
```
✓ FOUND: 1421af0 (Task 1 - integration)
✓ FOUND: 65115c5 (Task 2 - documentation)
```

**Tests pass:**
```
✓ 410/410 tests passing (no regressions)
✓ EventBus tests work with new assertion
✓ All existing functionality preserved
```

All claims verified. Plan execution successful.
