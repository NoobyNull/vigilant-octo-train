---
phase: 01.3-mainthreadqueue
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/threading/main_thread_queue.h
  - src/core/threading/main_thread_queue.cpp
  - src/core/utils/thread_utils.h
  - tests/test_main_thread_queue.cpp
  - tests/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "Worker threads can enqueue callables to MainThreadQueue without blocking (unless full)"
    - "processAll() drains the queue and executes all callbacks outside the lock"
    - "Queue is bounded with configurable max size (default 1000)"
    - "shutdown() unblocks any waiting producers and prevents further enqueues"
    - "ASSERT_MAIN_THREAD() aborts in debug builds when called from wrong thread"
    - "ASSERT_MAIN_THREAD() is a no-op in release builds"
  artifacts:
    - path: "src/core/threading/main_thread_queue.h"
      provides: "MainThreadQueue class declaration"
      contains: "class MainThreadQueue"
    - path: "src/core/threading/main_thread_queue.cpp"
      provides: "MainThreadQueue implementation"
      contains: "processAll"
    - path: "src/core/utils/thread_utils.h"
      provides: "ASSERT_MAIN_THREAD macro and threading::initMainThread/isMainThread"
      contains: "ASSERT_MAIN_THREAD"
    - path: "tests/test_main_thread_queue.cpp"
      provides: "Unit tests for MainThreadQueue"
      contains: "TEST"
  key_links:
    - from: "src/core/threading/main_thread_queue.h"
      to: "std::mutex, std::condition_variable, std::queue"
      via: "C++17 standard threading primitives"
      pattern: "std::mutex"
    - from: "src/core/utils/thread_utils.h"
      to: "std::this_thread::get_id"
      via: "thread identification"
      pattern: "g_mainThreadId"
    - from: "tests/test_main_thread_queue.cpp"
      to: "src/core/threading/main_thread_queue.h"
      via: "include and instantiation"
      pattern: "MainThreadQueue"
---

<objective>
Implement MainThreadQueue (thread-safe bounded queue for posting callables from worker threads to main thread) and thread_utils.h (ASSERT_MAIN_THREAD debug macro), with comprehensive TDD test coverage.

Purpose: Foundation for safe worker-to-UI communication. Workers must never call ImGui directly -- they post lambdas to MainThreadQueue, which executes them on the main thread during Application::update(). This plan creates the standalone classes and tests; integration comes in Plan 02.

Output: MainThreadQueue class, thread_utils.h with assertions, passing unit tests.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.3-mainthreadqueue/1.3-RESEARCH.md
@src/render/gl_utils.h
@src/core/utils/log.h
@src/core/import/import_queue.h
@tests/CMakeLists.txt
</context>

<feature>
  <name>MainThreadQueue and Thread Assertions</name>
  <files>
    src/core/threading/main_thread_queue.h
    src/core/threading/main_thread_queue.cpp
    src/core/utils/thread_utils.h
    tests/test_main_thread_queue.cpp
    tests/CMakeLists.txt
  </files>
  <behavior>
    MainThreadQueue is a bounded, thread-safe FIFO queue of std::function<void()> callables.

    API:
    - enqueue(std::function<void()> task): Thread-safe. Blocks if queue full (condition_variable with predicate). Returns immediately if shutdown. Called from ANY thread.
    - processAll(): Drains queue under lock into local vector, then executes all callbacks OUTSIDE the lock. Called from main thread only. Must include ASSERT_MAIN_THREAD().
    - size() const: Lock-free query via std::atomic<size_t>. Returns approximate queue depth.
    - shutdown(): Sets shutdown flag, notifies all waiting producers. After shutdown, enqueue is a no-op.
    - Constructor: explicit MainThreadQueue(size_t maxSize = 1000).

    Test cases (RED phase -- write these FIRST, all must fail initially):
    1. Enqueue single task, processAll executes it (value set by lambda)
    2. Enqueue multiple tasks, processAll executes all in FIFO order (push 1,2,3 -> verify order)
    3. processAll on empty queue does nothing (no crash)
    4. size() returns correct count before and after processAll
    5. Cross-thread: spawn std::thread that enqueues 100 tasks, main calls processAll, verify all 100 executed
    6. shutdown() causes blocked enqueue to return without adding
    7. After shutdown, enqueue is a no-op (size stays 0)
    8. Multiple processAll calls -- second call processes tasks enqueued after first call

    thread_utils.h:
    - dw::threading::g_mainThreadId (inline global)
    - dw::threading::initMainThread() -- stores current thread ID
    - dw::threading::isMainThread() -- compares current thread to stored ID
    - ASSERT_MAIN_THREAD() macro -- calls std::abort() in debug, ((void)0) in release
    - Follows existing GL_CHECK pattern from src/render/gl_utils.h (NDEBUG guard)

    Test cases for thread_utils:
    9. isMainThread() returns true on the thread that called initMainThread()
    10. isMainThread() returns false on a different thread
  </behavior>
  <implementation>
    Phase 1 - RED: Create test file with all 10 tests. Include headers that don't exist yet (will fail to compile). Run `cmake --build build --target dw_tests` to confirm failure.

    Phase 2 - GREEN: Implement:

    1. Create src/core/utils/thread_utils.h:
       - #pragma once
       - #include <thread> and <iostream>
       - namespace dw::threading with inline g_mainThreadId, initMainThread(), isMainThread()
       - ASSERT_MAIN_THREAD() macro guarded by NDEBUG (follow GL_CHECK pattern exactly)
       - Use do { ... } while(0) idiom for macro safety

    2. Create src/core/threading/main_thread_queue.h:
       - #pragma once
       - #include <atomic>, <condition_variable>, <functional>, <mutex>, <queue>, <vector>
       - #include "core/utils/thread_utils.h"
       - namespace dw
       - class MainThreadQueue with:
         - explicit MainThreadQueue(size_t maxSize = 1000)
         - void enqueue(std::function<void()> task)
         - void processAll()
         - size_t size() const
         - void shutdown()
       - Private members: m_queue (std::queue), m_mutex, m_cvFull (condition_variable), m_maxSize, m_size (atomic<size_t>), m_shutdown (atomic<bool>)

    3. Create src/core/threading/main_thread_queue.cpp:
       - enqueue: unique_lock + m_cvFull.wait with predicate (size < max || shutdown), early return if shutdown, push + atomic increment + notify
       - processAll: ASSERT_MAIN_THREAD(), lock_guard to drain into local vector (move front, pop, decrement atomic), notify_all on m_cvFull, then execute all callbacks outside lock
       - shutdown: set flag under lock, notify_all on m_cvFull
       - size: return m_size.load()

    4. Update tests/CMakeLists.txt:
       - Add test_main_thread_queue.cpp to DW_TEST_SOURCES (under "# Tier 1 -- MainThreadQueue" comment)
       - Add ${CMAKE_SOURCE_DIR}/src/core/threading/main_thread_queue.cpp to DW_TEST_DEPS

    5. Build and run tests. All 10 must pass.

    IMPORTANT: In the test file, call dw::threading::initMainThread() in a test fixture SetUp() so isMainThread() works correctly. For cross-thread tests, spawn std::thread and use std::atomic<int> counters to verify execution.

    NOTE on ASSERT_MAIN_THREAD in tests: Tests run in debug mode, so ASSERT_MAIN_THREAD() is active. The test thread IS the main thread (it called initMainThread), so processAll() assertions will pass. Do NOT test that ASSERT_MAIN_THREAD aborts (that would kill the test process). Instead test isMainThread() returning true/false.

    Naming conventions: snake_case for files and methods, PascalCase for class, m_ prefix for members, #pragma once.
  </implementation>
</feature>

<verification>
```bash
cd /data/DW && cmake --build build --target dw_tests 2>&1 | tail -20
cd /data/DW && ./build/tests/dw_tests --gtest_filter="MainThreadQueue*:ThreadUtils*" 2>&1
cd /data/DW && ./build/tests/dw_tests 2>&1 | tail -5  # All tests still pass
```
</verification>

<success_criteria>
- MainThreadQueue class compiles and links
- thread_utils.h provides ASSERT_MAIN_THREAD macro following GL_CHECK pattern
- All 10+ new unit tests pass
- All existing tests still pass (387+)
- No ThreadSanitizer warnings in cross-thread test
- No memory leaks (callbacks properly destroyed after execution)
</success_criteria>

<output>
After completion, create `.planning/phases/01.3-mainthreadqueue/1.3-01-SUMMARY.md`
</output>
