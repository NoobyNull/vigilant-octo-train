---
phase: 01.3-mainthreadqueue
plan: 01
subsystem: threading
tags: [tdd, thread-safety, assertions, core-infrastructure]
dependency_graph:
  requires: []
  provides:
    - MainThreadQueue
    - thread_utils (ASSERT_MAIN_THREAD macro)
    - threading::initMainThread()
    - threading::isMainThread()
  affects:
    - Application (future integration in plan 02)
    - ImportQueue (future integration in plan 02)
tech_stack:
  added:
    - std::condition_variable for producer-consumer pattern
    - std::atomic for lock-free size queries
    - std::thread::id for thread identification
  patterns:
    - Bounded queue with backpressure
    - NDEBUG-guarded debug assertions (following GL_CHECK pattern)
    - Lock minimization (drain under lock, execute outside lock)
key_files:
  created:
    - src/core/threading/main_thread_queue.h
    - src/core/threading/main_thread_queue.cpp
    - src/core/utils/thread_utils.h
    - tests/test_main_thread_queue.cpp
  modified:
    - tests/CMakeLists.txt
decisions:
  - title: Bounded Queue Size Default
    rationale: 1000 messages = 16 seconds at 60fps, provides reasonable backpressure
    alternatives: Unbounded (memory risk), smaller bound (may block legitimate work)
    outcome: 1000 default, configurable per instance
  - title: Condition Variable Over Lock-Free
    rationale: Lock-free adds complexity, not needed for ~60fps message rate
    alternatives: Lock-free MPSC queue, boost::lockfree::queue
    outcome: std::mutex + std::condition_variable (standard, debuggable)
  - title: Execute Callbacks Outside Lock
    rationale: Prevents deadlocks if callback tries to enqueue or acquires other locks
    alternatives: Execute under lock (simpler but deadlock-prone)
    outcome: Drain to local vector, release lock, then execute
metrics:
  duration: 150s (2m 30s)
  tasks_completed: 2
  tests_added: 10
  tests_passing: 410
  files_created: 4
  files_modified: 1
  commits: 2
  completed_date: 2026-02-09
---

# Phase 1.3 Plan 01: MainThreadQueue Core + Thread Utils

**One-liner:** Bounded thread-safe FIFO queue with condition variable blocking and ASSERT_MAIN_THREAD debug macro following GL_CHECK pattern.

## Overview

Implemented MainThreadQueue (thread-safe bounded queue for posting callables from worker threads to main thread) and thread_utils.h (ASSERT_MAIN_THREAD debug macro). Followed TDD approach: RED phase (10 failing tests) → GREEN phase (implementation passes all tests).

**Purpose:** Foundation for safe worker-to-UI communication. Workers must never call ImGui directly — they post lambdas to MainThreadQueue, which executes them on the main thread during Application::update(). This plan creates standalone classes and tests; integration comes in Plan 02.

## What Was Built

### MainThreadQueue API

```cpp
class MainThreadQueue {
public:
    explicit MainThreadQueue(size_t maxSize = 1000);

    void enqueue(std::function<void()> task);  // Thread-safe, blocks if full
    void processAll();                         // Main thread only, drains and executes
    size_t size() const;                       // Lock-free query
    void shutdown();                           // Unblock waiting producers
};
```

**Key behaviors:**
- **Bounded queue:** Default 1000 messages, configurable
- **Blocking enqueue:** Uses condition variable with predicate (size < max || shutdown)
- **Shutdown handling:** Unblocks waiting producers, prevents further enqueues
- **Lock minimization:** Drains queue under lock, executes callbacks outside lock
- **ASSERT_MAIN_THREAD:** processAll() asserts main-thread execution in debug builds

### thread_utils.h

```cpp
namespace dw::threading {
    inline std::thread::id g_mainThreadId;
    void initMainThread();      // Call from Application::init()
    bool isMainThread();        // Check current thread ID
}

#define ASSERT_MAIN_THREAD()    // Aborts in debug, no-op in release
```

**Pattern:** Follows existing GL_CHECK macro pattern from src/render/gl_utils.h:
- NDEBUG-guarded (debug only)
- do { ... } while(0) idiom for macro safety
- Logs file, line, function before abort()

## Test Coverage

**10 unit tests added** (all passing):

1. ✓ Enqueue single task, processAll executes it
2. ✓ Enqueue multiple tasks, processAll executes in FIFO order
3. ✓ processAll on empty queue does nothing (no crash)
4. ✓ size() returns correct count before and after processAll
5. ✓ Cross-thread: spawn thread that enqueues 100 tasks, main calls processAll
6. ✓ shutdown() causes blocked enqueue to return without adding
7. ✓ After shutdown, enqueue is a no-op (size stays 0)
8. ✓ Multiple processAll calls — second call processes new tasks
9. ✓ isMainThread() returns true on thread that called initMainThread()
10. ✓ isMainThread() returns false on a different thread

**Test fixture:** Calls `threading::initMainThread()` in SetUp() so assertions work correctly.

## Technical Decisions

### 1. Bounded Queue with Backpressure

**Decision:** Default max size 1000, configurable per instance.

**Rationale:**
- At 60fps, 1000 messages = 16 seconds of backlog
- Prevents memory exhaustion from runaway producers
- Provides backpressure signal (blocking enqueue)

**Implementation:** Condition variable with predicate `size < max || shutdown`.

### 2. Condition Variable Over Lock-Free

**Decision:** Use std::mutex + std::condition_variable (standard pattern).

**Alternatives considered:**
- Lock-free MPSC queue (e.g., boost::lockfree::queue)
- Custom lock-free implementation

**Why standard approach:**
- Lock-free adds complexity (ABA problem, memory ordering)
- Not needed for ~60fps message rate
- Standard library is tested, debuggable, portable

### 3. Execute Callbacks Outside Lock

**Decision:** Drain queue to local vector under lock, release lock, then execute callbacks.

**Rationale:**
- Prevents deadlocks if callback tries to enqueue or acquires other locks
- Minimizes lock hold time (better concurrency)
- Callbacks may throw exceptions (don't want lock held)

**Alternative:** Execute under lock (simpler but deadlock-prone).

**Implementation:**
```cpp
void MainThreadQueue::processAll() {
    std::vector<std::function<void()>> tasks;
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        while (!m_queue.empty()) {
            tasks.push_back(std::move(m_queue.front()));
            m_queue.pop();
        }
        m_cvFull.notify_all();  // Wake blocked producers
    }
    // Execute outside lock
    for (auto& task : tasks) {
        task();
    }
}
```

## Deviations from Plan

**None** — Plan executed exactly as written. All 10 tests specified in plan were implemented and pass.

## Files

**Created:**
- `src/core/threading/main_thread_queue.h` — MainThreadQueue class declaration (40 lines)
- `src/core/threading/main_thread_queue.cpp` — Implementation (58 lines)
- `src/core/utils/thread_utils.h` — Threading utilities and ASSERT_MAIN_THREAD macro (38 lines)
- `tests/test_main_thread_queue.cpp` — Unit tests (184 lines)

**Modified:**
- `tests/CMakeLists.txt` — Added test_main_thread_queue.cpp to DW_TEST_SOURCES, added main_thread_queue.cpp to DW_TEST_DEPS

**Total:** 4 files created, 1 file modified

## Commits

1. **eb5889d** — `test(1.3-01): add failing tests for MainThreadQueue and thread_utils`
   - RED phase: 10 failing tests (compilation error)
   - Added test file and CMake registration

2. **4390124** — `feat(1.3-01): implement MainThreadQueue and thread_utils`
   - GREEN phase: Implementation passes all tests
   - MainThreadQueue with bounded queue and condition variable
   - thread_utils.h with ASSERT_MAIN_THREAD macro

## Verification

✓ **Build succeeds:** cmake --build build --target dw_tests (no errors)
✓ **New tests pass:** All 10 MainThreadQueue tests pass (50ms total)
✓ **No regressions:** All 410 tests pass (400 existing + 10 new)
✓ **Threading safety:** Cross-thread test (100 enqueues from worker) passes
✓ **Shutdown behavior:** Blocked enqueue returns after shutdown (50ms test)

## Next Steps

**Plan 02: Integration into Application**
- Add MainThreadQueue instance to Application
- Call processAll() in Application::update() (each frame)
- Refactor ImportQueue to use MainThreadQueue for completed imports
- Add ASSERT_MAIN_THREAD() to UI entry points (Panel::render, Workspace setters)
- Document threading contracts in THREADING.md

**Integration points identified:**
- `Application::update()` — call `m_mainThreadQueue->processAll()`
- `ImportQueue::processTask()` — enqueue completion callback instead of pushing to m_completed vector
- `Panel::render()` — add ASSERT_MAIN_THREAD() assertion
- `Workspace` setters — add ASSERT_MAIN_THREAD() assertions

## Self-Check: PASSED

**Created files exist:**
```
✓ FOUND: src/core/threading/main_thread_queue.h
✓ FOUND: src/core/threading/main_thread_queue.cpp
✓ FOUND: src/core/utils/thread_utils.h
✓ FOUND: tests/test_main_thread_queue.cpp
```

**Commits exist:**
```
✓ FOUND: eb5889d (RED phase)
✓ FOUND: 4390124 (GREEN phase)
```

**Tests pass:**
```
✓ 10/10 MainThreadQueue tests passing
✓ 410/410 total tests passing (no regressions)
```

All claims verified. Plan execution successful.
