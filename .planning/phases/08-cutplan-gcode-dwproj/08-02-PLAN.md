# Plan 08-02: Extend ProjectExportManager — G-code, Costs, Cut Plans in Archive

## Goal
Extend the existing .dwproj export to include G-code files, cost estimates, and cut plans. No backward compatibility needed — modify the manifest and archive structure directly.

## Context

**Current .dwproj archive structure:**
```
manifest.json
models/<hash>.<ext>
thumbnails/<hash>.png
materials/<materialId>.dwmat
```

**Target structure:**
```
manifest.json
models/<hash>.<ext>
thumbnails/<hash>.png
materials/<materialId>.dwmat
gcode/<gcodeId>.<ext>          # NEW
costs.json                      # NEW
cut_plans.json                  # NEW
```

**Current manifest.json structure** (from project_export_manager.cpp):
```json
{
  "format_version": 1,
  "app_version": "...",
  "created_at": "...",
  "project_id": 123,
  "project_name": "...",
  "models": [{ ... }]
}
```

**Target manifest structure:**
```json
{
  "format_version": 2,
  "app_version": "...",
  "created_at": "...",
  "project_id": 123,
  "project_name": "...",
  "project_notes": "...",
  "models": [{ ... }],
  "gcode": [{ "id": 1, "name": "...", "file_in_archive": "gcode/1.nc", ... }],
  "cost_estimates": [{ ... }],
  "cut_plans": [{ ... }]
}
```

**Files to read before implementing:**
- `src/core/export/project_export_manager.h` — ManifestModel, Manifest structs, public API
- `src/core/export/project_export_manager.cpp` — buildManifestJson(), parseManifest(), exportProject(), importProject()
- `src/core/database/gcode_repository.h` — GCodeRecord fields
- `src/core/database/cost_repository.h` — CostEstimate, CostItem structs
- `src/core/database/cut_plan_repository.h` — CutPlanRecord struct
- `src/core/database/project_repository.h` — ProjectRecord with notes field

## Tasks

### Task 1: Extend Manifest struct (project_export_manager.h)

Add to the private `Manifest` struct:

```cpp
struct ManifestGCode {
    i64 id = 0;
    std::string name;
    std::string hash;
    std::string fileInArchive;  // "gcode/1.nc"
    f32 estimatedTime = 0.0f;
    std::vector<int> toolNumbers;
};

struct Manifest {
    int formatVersion = 2;  // Changed from 1
    // ... existing fields ...
    std::string projectNotes;                    // NEW
    std::vector<ManifestGCode> gcode;            // NEW
    std::vector<CostEstimate> costEstimates;     // NEW — reuse struct directly
    std::vector<CutPlanRecord> cutPlans;         // NEW — reuse struct directly
};
```

Add includes for the new repository headers.

### Task 2: Extend exportProject() (project_export_manager.cpp)

After the existing model/thumbnail/material export loop, add:

**G-code files:**
```cpp
// Export G-code files
GCodeRepository gcodeRepo(m_db);
auto gcodeFiles = gcodeRepo.findByProject(project.id());
for (const auto& gc : gcodeFiles) {
    if (progress) progress(current++, total, gc.name);
    std::string archivePath = "gcode/" + std::to_string(gc.id) +
        gc.filePath.extension().string();
    // Read file from disk and add to ZIP
    auto fileData = file::readBinary(gc.filePath);
    if (!fileData.empty()) {
        mz_zip_writer_add_mem(&zip, archivePath.c_str(),
            fileData.data(), fileData.size(), MZ_DEFAULT_COMPRESSION);
    }
}
```

**Cost estimates:**
```cpp
// Export cost estimates as JSON
CostRepository costRepo(m_db);
auto estimates = costRepo.findByProject(project.id());
if (!estimates.empty()) {
    std::string costsJson = buildCostsJson(estimates);
    mz_zip_writer_add_mem(&zip, "costs.json",
        costsJson.data(), costsJson.size(), MZ_DEFAULT_COMPRESSION);
}
```

**Cut plans:**
```cpp
// Export cut plans as JSON
CutPlanRepository cutPlanRepo(m_db);
auto plans = cutPlanRepo.findByProject(project.id());
if (!plans.empty()) {
    std::string plansJson = buildCutPlansJson(plans);
    mz_zip_writer_add_mem(&zip, "cut_plans.json",
        plansJson.data(), plansJson.size(), MZ_DEFAULT_COMPRESSION);
}
```

Update `total` count at the start to include gcode files.

### Task 3: Extend buildManifestJson()

Add sections for gcode, notes:

```cpp
// After "models" array
json += ",\"project_notes\":" + escapeJsonString(projectNotes);

json += ",\"gcode\":[";
for (size_t i = 0; i < gcodeFiles.size(); i++) {
    if (i > 0) json += ",";
    json += "{";
    json += "\"id\":" + std::to_string(gc.id);
    json += ",\"name\":" + escapeJsonString(gc.name);
    json += ",\"hash\":" + escapeJsonString(gc.hash);
    json += ",\"file_in_archive\":" + escapeJsonString(archivePath);
    json += ",\"estimated_time\":" + std::to_string(gc.estimatedTime);
    // tool_numbers as array
    json += ",\"tool_numbers\":[";
    for (size_t j = 0; j < gc.toolNumbers.size(); j++) {
        if (j > 0) json += ",";
        json += std::to_string(gc.toolNumbers[j]);
    }
    json += "]";
    json += "}";
}
json += "]";
```

Cost and cut plan data is in separate files (costs.json, cut_plans.json) to keep the manifest manageable, so the manifest just references them:

```cpp
json += ",\"has_costs\":" + std::string(hasCosts ? "true" : "false");
json += ",\"has_cut_plans\":" + std::string(hasCutPlans ? "true" : "false");
```

### Task 4: Add helper methods

**buildCostsJson(vector<CostEstimate>):**
Serialize the estimates array. Reuse the JSON pattern from CostRepository::itemsToJson() for items. Wrap in a top-level array.

**buildCutPlansJson(vector<CutPlanRecord>):**
Serialize the cut plan records. The records already have JSON strings for sheet_config, parts, and result — just embed them directly:

```json
[
  {
    "name": "Plan 1",
    "algorithm": "guillotine",
    "sheet_config": { ... },
    "parts": [ ... ],
    "result": { ... },
    "settings": { "allow_rotation": true, "kerf": 3.0, "margin": 5.0 }
  }
]
```

### Task 5: Update method signatures

`buildManifestJson()` needs additional parameters for the new data. Either extend the parameter list or pass a struct. Keep it simple — add parameters:

```cpp
std::string buildManifestJson(
    const Project& project,
    const std::vector<ModelRecord>& models,
    const std::unordered_map<i64, i64>& modelIdToMaterialId,
    const std::unordered_map<std::string, std::string>& hashToThumbnailPath,
    const std::vector<GCodeRecord>& gcodeFiles,     // NEW
    const std::string& projectNotes);                 // NEW
```

Update the header declaration to match.

### Task 6: Update FormatVersion

Change `static constexpr int FormatVersion = 1;` to `2` in the header.

## Verification

1. `cmake --build build -j$(nproc)` — compiles cleanly
2. `build/tests/dw_tests` — all tests pass
3. Create project with models, gcode, cost estimate, cut plan → export .dwproj
4. Inspect archive (unzip) — verify gcode/, costs.json, cut_plans.json present
5. Manifest has format_version 2, gcode array, has_costs/has_cut_plans flags

## Files Modified

| File | Change |
|------|--------|
| `src/core/export/project_export_manager.h` | ManifestGCode struct, Manifest fields, FormatVersion, updated method signatures |
| `src/core/export/project_export_manager.cpp` | Export gcode/costs/cutplans, build JSON helpers, update manifest builder |
