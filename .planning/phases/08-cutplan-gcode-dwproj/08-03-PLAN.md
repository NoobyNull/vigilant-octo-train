# Plan 08-03: Import All Asset Types & Round-Trip Test

## Goal
Extend `importProject()` to restore G-code files, cost estimates, and cut plans from .dwproj archives. Write a round-trip integration test proving export→import→export produces equivalent archives.

## Context

**After Plan 08-02:** Export writes gcode files, costs.json, cut_plans.json into the archive. Manifest has format_version 2, gcode array, has_costs/has_cut_plans flags.

**Current importProject()** (project_export_manager.cpp):
1. Opens ZIP, reads manifest.json
2. Parses manifest → creates project in DB
3. For each model: extracts blob → imports via LibraryManager (dedup by hash) → adds to project
4. For each material: extracts .dwmat → imports via MaterialManager (dedup by name)
5. For each thumbnail: extracts PNG → copies to thumbnail directory
6. Sets imported project as current

**Files to read before implementing:**
- `src/core/export/project_export_manager.cpp` — importProject() full implementation
- `src/core/database/gcode_repository.h` — insert(), addToProject()
- `src/core/database/cost_repository.h` — insert()
- `src/core/database/cut_plan_repository.h` — insert()
- `tests/test_exporter.cpp` — existing export test patterns

## Tasks

### Task 1: Extend parseManifest() for gcode

In `parseManifest()`, after parsing models array, add gcode parsing:

```cpp
// Parse gcode array
auto gcodePos = json.find("\"gcode\":");
if (gcodePos != std::string::npos) {
    // Parse array of gcode entries
    // Each entry: { "id", "name", "hash", "file_in_archive", "estimated_time", "tool_numbers" }
    // Populate out.gcode vector
}

// Parse project notes
auto notesPos = json.find("\"project_notes\":");
if (notesPos != std::string::npos) {
    // Extract string value
    out.projectNotes = extractJsonString(json, notesPos);
}
```

Use the same manual JSON parsing approach as the existing model parsing. Consider extracting a small JSON array parser helper if the code gets repetitive.

### Task 2: Import G-code files

In `importProject()`, after model import loop, add:

```cpp
// Import G-code files
GCodeRepository gcodeRepo(m_db);
for (const auto& gc : manifest.gcode) {
    if (progress) progress(current++, total, gc.name);

    // Extract file from ZIP
    size_t fileSize = 0;
    void* fileData = mz_zip_reader_extract_file_to_heap(
        &zip, gc.fileInArchive.c_str(), &fileSize, 0);
    if (!fileData) continue;

    // Write to gcode storage directory
    Path gcodeDir = AppPaths::gcodeDir();
    Path outPath = gcodeDir / (gc.hash + Path(gc.fileInArchive).extension().string());
    file::ensureDir(gcodeDir);
    file::writeBinary(outPath, static_cast<const uint8_t*>(fileData), fileSize);
    mz_free(fileData);

    // Check if gcode with this hash already exists (dedup)
    auto existing = gcodeRepo.findByHash(gc.hash);
    i64 gcodeId;
    if (existing) {
        gcodeId = existing->id;
    } else {
        // Create new gcode record
        GCodeRecord record;
        record.hash = gc.hash;
        record.name = gc.name;
        record.filePath = outPath;
        record.estimatedTime = gc.estimatedTime;
        record.toolNumbers = gc.toolNumbers;
        auto id = gcodeRepo.insert(record);
        if (!id) continue;
        gcodeId = *id;
    }

    // Link to imported project
    gcodeRepo.addToProject(*result.importedProjectId, gcodeId);
}
```

### Task 3: Import cost estimates

```cpp
// Import cost estimates
size_t costsSize = 0;
void* costsData = mz_zip_reader_extract_file_to_heap(
    &zip, "costs.json", &costsSize, 0);
if (costsData) {
    std::string costsJson(static_cast<char*>(costsData), costsSize);
    mz_free(costsData);

    auto estimates = parseCostsJson(costsJson);
    CostRepository costRepo(m_db);
    for (auto& est : estimates) {
        est.projectId = *result.importedProjectId;
        costRepo.insert(est);
    }
}
```

### Task 4: Import cut plans

```cpp
// Import cut plans
size_t plansSize = 0;
void* plansData = mz_zip_reader_extract_file_to_heap(
    &zip, "cut_plans.json", &plansSize, 0);
if (plansData) {
    std::string plansJson(static_cast<char*>(plansData), plansSize);
    mz_free(plansData);

    auto plans = parseCutPlansJson(plansJson);
    CutPlanRepository cutPlanRepo(m_db);
    for (auto& plan : plans) {
        plan.projectId = *result.importedProjectId;
        cutPlanRepo.insert(plan);
    }
}
```

### Task 5: Import project notes

In the project creation step, set the notes:

```cpp
ProjectRecord projectRecord;
projectRecord.name = manifest.projectName;
projectRecord.notes = manifest.projectNotes;  // NEW
// ... insert project ...
```

Ensure `ProjectRepository::insert()` writes the notes field (updated in Phase 6).

### Task 6: Add parse helper methods

**parseCostsJson(const string& json) → vector<CostEstimate>:**
Parse the JSON array of cost estimates. Reuse CostRepository's `jsonToItems()` for the items sub-array. Reconstruct CostEstimate structs with `recalculate()`.

**parseCutPlansJson(const string& json) → vector<CutPlanRecord>:**
Parse the JSON array of cut plan records. The sheet_config, parts, and result fields are already JSON strings in the database format, so they can be stored directly in CutPlanRecord without further processing.

### Task 7: Update total count for progress

In `importProject()`, compute total including gcode files:

```cpp
int total = manifest.models.size() + manifest.gcode.size();
// costs and cut plans are fast (single file each), don't need progress
```

### Task 8: Round-trip integration test

**tests/test_project_export.cpp** (new or extend existing):

```cpp
TEST(ProjectExport, RoundTrip_AllAssetTypes) {
    // Setup: in-memory or temp DB
    Database db;
    db.open(":memory:");
    Schema::initialize(db);

    // Create project with models, gcode, cost, cut plan
    ProjectRepository projRepo(db);
    ModelRepository modelRepo(db);
    GCodeRepository gcodeRepo(db);
    CostRepository costRepo(db);
    CutPlanRepository cutPlanRepo(db);

    // Insert project
    ProjectRecord proj;
    proj.name = "Test Project";
    proj.notes = "Round trip test notes";
    auto projId = projRepo.insert(proj);
    ASSERT_TRUE(projId);

    // Insert model + link
    ModelRecord model;
    model.name = "Test Model";
    model.hash = "abc123";
    model.fileFormat = "stl";
    auto modelId = modelRepo.insert(model);
    projRepo.addModel(*projId, *modelId);

    // Insert gcode + link
    GCodeRecord gcode;
    gcode.name = "test.nc";
    gcode.hash = "def456";
    gcode.filePath = "/tmp/test.nc";
    gcode.estimatedTime = 120.0f;
    auto gcodeId = gcodeRepo.insert(gcode);
    gcodeRepo.addToProject(*projId, *gcodeId);

    // Insert cost estimate
    CostEstimate cost;
    cost.name = "Material Cost";
    cost.projectId = *projId;
    cost.items.push_back({0, "Wood", CostCategory::Material, 2.0, 15.0, 30.0, ""});
    cost.recalculate();
    costRepo.insert(cost);

    // Insert cut plan
    CutPlanRecord plan;
    plan.name = "Main Cut Plan";
    plan.projectId = *projId;
    plan.algorithm = "guillotine";
    plan.sheetConfigJson = CutPlanRepository::sheetToJson({2440, 1220});
    plan.partsJson = "[]";
    plan.resultJson = "{}";
    plan.sheetsUsed = 2;
    plan.efficiency = 0.85f;
    cutPlanRepo.insert(plan);

    // Export
    ProjectExportManager exporter(db);
    Project project(*projId, proj.name, proj.description, "", {*modelId});
    Path exportPath = std::filesystem::temp_directory_path() / "test_roundtrip.dwproj";
    auto exportResult = exporter.exportProject(project, exportPath);
    ASSERT_TRUE(exportResult.success) << exportResult.error;

    // Import into fresh DB
    Database db2;
    db2.open(":memory:");
    Schema::initialize(db2);
    ProjectExportManager importer(db2);
    auto importResult = importer.importProject(exportPath);
    ASSERT_TRUE(importResult.success) << importResult.error;
    ASSERT_TRUE(importResult.importedProjectId);

    // Verify all assets restored
    ProjectRepository projRepo2(db2);
    auto imported = projRepo2.findById(*importResult.importedProjectId);
    ASSERT_TRUE(imported);
    EXPECT_EQ(imported->name, "Test Project");
    EXPECT_EQ(imported->notes, "Round trip test notes");

    GCodeRepository gcodeRepo2(db2);
    auto gcodes = gcodeRepo2.findByProject(*importResult.importedProjectId);
    EXPECT_EQ(gcodes.size(), 1u);
    if (!gcodes.empty()) {
        EXPECT_EQ(gcodes[0].name, "test.nc");
    }

    CostRepository costRepo2(db2);
    auto costs = costRepo2.findByProject(*importResult.importedProjectId);
    EXPECT_EQ(costs.size(), 1u);
    if (!costs.empty()) {
        EXPECT_EQ(costs[0].name, "Material Cost");
        EXPECT_EQ(costs[0].items.size(), 1u);
    }

    CutPlanRepository cutPlanRepo2(db2);
    auto plans = cutPlanRepo2.findByProject(*importResult.importedProjectId);
    EXPECT_EQ(plans.size(), 1u);
    if (!plans.empty()) {
        EXPECT_EQ(plans[0].name, "Main Cut Plan");
        EXPECT_EQ(plans[0].algorithm, "guillotine");
    }

    // Cleanup
    std::filesystem::remove(exportPath);
}
```

Note: This test may need adapting based on how the export actually writes model blobs (needs files on disk). If the test needs real model files, create temp files with dummy content. Check existing export tests for patterns.

Add to `tests/CMakeLists.txt`.

## Verification

1. `cmake --build build -j$(nproc)` — compiles cleanly
2. `build/tests/dw_tests` — all tests pass including round-trip test
3. Export project with all asset types → import on fresh DB → all assets present
4. Project panel shows all imported assets in correct sections

## Files Modified

| File | Change |
|------|--------|
| `src/core/export/project_export_manager.h` | Add parse helper declarations |
| `src/core/export/project_export_manager.cpp` | Import gcode/costs/cutplans, parse helpers, notes |
| `tests/test_project_export.cpp` | **NEW** (or extend existing) — round-trip test |
| `tests/CMakeLists.txt` | Add test file if new |
