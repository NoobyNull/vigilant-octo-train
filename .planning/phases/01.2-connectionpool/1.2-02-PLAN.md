---
phase: 01.2-connectionpool
plan: 02
type: execute
wave: 2
depends_on: ["1.2-01"]
files_modified:
  - src/core/import/import_queue.h
  - src/core/import/import_queue.cpp
  - src/app/application.h
  - src/app/application.cpp
autonomous: true

must_haves:
  truths:
    - "ImportQueue worker thread acquires a pooled connection per task"
    - "Pooled connections are released back after each import task completes"
    - "Application creates ConnectionPool and passes it to ImportQueue"
    - "Main thread Database connection remains separate from pool"
    - "Concurrent import and UI database queries work without SQLITE_BUSY"
  artifacts:
    - path: "src/core/import/import_queue.h"
      provides: "ImportQueue accepting ConnectionPool reference"
      contains: "ConnectionPool"
    - path: "src/core/import/import_queue.cpp"
      provides: "Worker thread using ScopedConnection per task"
      contains: "ScopedConnection"
    - path: "src/app/application.cpp"
      provides: "ConnectionPool initialization and ImportQueue wiring"
      contains: "ConnectionPool"
  key_links:
    - from: "src/core/import/import_queue.cpp"
      to: "src/core/database/connection_pool.h"
      via: "ScopedConnection in processTask"
      pattern: "ScopedConnection"
    - from: "src/app/application.cpp"
      to: "src/core/database/connection_pool.h"
      via: "Creates ConnectionPool member, passes to ImportQueue"
      pattern: "make_unique<ConnectionPool>"
    - from: "src/core/import/import_queue.cpp"
      to: "src/core/database/model_repository.h"
      via: "Creates ModelRepository with pooled connection per task"
      pattern: "ModelRepository.*conn"
---

<objective>
Integrate ConnectionPool into ImportQueue and Application, replacing ImportQueue's single Database reference with pooled connections acquired per-task via ScopedConnection.

Purpose: Wire the ConnectionPool (from Plan 01) into the actual application so background imports use pooled connections while the main thread keeps its dedicated Database connection. This eliminates potential SQLITE_BUSY conflicts between concurrent import and UI operations.

Output: Refactored ImportQueue using ConnectionPool, Application creating and owning ConnectionPool instance.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.2-connectionpool/1.2-01-SUMMARY.md
@src/core/import/import_queue.h
@src/core/import/import_queue.cpp
@src/app/application.h
@src/app/application.cpp
@src/core/database/connection_pool.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor ImportQueue to use ConnectionPool</name>
  <files>
    src/core/import/import_queue.h
    src/core/import/import_queue.cpp
  </files>
  <action>
    Modify ImportQueue to accept ConnectionPool& instead of Database&.

    In import_queue.h:
    - Add forward declaration: class ConnectionPool; (or include connection_pool.h)
    - Change constructor: explicit ImportQueue(ConnectionPool& pool)
    - Replace member Database& m_db with ConnectionPool& m_pool
    - Remove member ModelRepository m_modelRepo (will be created per-task instead)

    In import_queue.cpp:
    - Include "connection_pool.h" (for ScopedConnection)
    - Update constructor: ImportQueue(ConnectionPool& pool) : m_pool(pool) {}
    - Modify processTask() to acquire a ScopedConnection at the start:
      ```
      void ImportQueue::processTask(ImportTask& task) {
          ScopedConnection conn(m_pool);
          ModelRepository modelRepo(*conn);
          // ... rest of processTask using modelRepo instead of m_modelRepo
      }
      ```
    - The ScopedConnection acquires a pooled connection for the duration of processTask()
    - ModelRepository is created with the pooled Database& for this task only
    - Connection is automatically released when processTask() returns (ScopedConnection destructor)
    - All other ImportQueue logic (workerLoop, enqueue, cancel, pollCompleted) stays unchanged
    - The key insight: connection is held only during processTask(), not for the entire worker lifetime

    Important: Do NOT change any other ImportQueue behavior. The enqueue(), cancel(), pollCompleted(), workerLoop() methods remain identical. Only the database access pattern changes.
  </action>
  <verify>
    ```bash
    cd /data/DW && cmake --build build --target dw_tests 2>&1 | tail -20
    cd /data/DW && ./build/tests/dw_tests --gtest_filter="Import*" 2>&1
    ```
    Build succeeds. Import-related tests still pass (test_import_pipeline.cpp).
  </verify>
  <done>
    ImportQueue constructor takes ConnectionPool&. processTask() uses ScopedConnection to acquire/release pooled connection per task. No Database& member remains. ModelRepository created per-task with pooled connection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ConnectionPool into Application</name>
  <files>
    src/app/application.h
    src/app/application.cpp
  </files>
  <action>
    Add ConnectionPool ownership to Application and pass it to ImportQueue.

    In application.h:
    - Add forward declaration: class ConnectionPool; (alongside existing Database forward decl)
    - Add member: std::unique_ptr<ConnectionPool> m_connectionPool; (after m_database)

    In application.cpp:
    - Add include: #include "core/database/connection_pool.h"
    - In Application::init(), AFTER database open and schema initialization (after line ~173), add:
      ```
      // Initialize connection pool for background workers (2 connections)
      m_connectionPool = std::make_unique<ConnectionPool>(paths::getDatabasePath(), 2);
      ```
    - Change ImportQueue construction (around line ~186) from:
      m_importQueue = std::make_unique<ImportQueue>(*m_database);
      to:
      m_importQueue = std::make_unique<ImportQueue>(*m_connectionPool);
    - In Application::shutdown(), add m_connectionPool.reset() AFTER m_importQueue.reset() and BEFORE m_database.reset():
      ```
      m_importQueue.reset();       // Joins worker thread, releases pooled connections
      m_connectionPool.reset();    // Closes pooled connections
      // ... existing cleanup
      m_database.reset();          // Close main thread connection
      ```
    - The Application's m_database remains the dedicated main-thread connection for UI queries (LibraryManager, ProjectManager, etc.)
    - ConnectionPool is separate, used only by ImportQueue's worker thread
    - This follows the research recommendation: keep Application's dedicated Database for main thread, pool for workers

    Lifecycle order matters:
    - Init: EventBus -> Database -> Schema -> ConnectionPool -> managers -> ImportQueue(pool) -> panels
    - Shutdown: panels -> ImportQueue -> ConnectionPool -> managers -> Database -> EventBus
  </action>
  <verify>
    ```bash
    cd /data/DW && cmake --build build --target dw 2>&1 | tail -20
    cd /data/DW && cmake --build build --target dw_tests 2>&1 | tail -20
    cd /data/DW && ./build/tests/dw_tests 2>&1 | tail -5
    ```
    Main application binary builds. Test binary builds. All tests pass (387+).
  </verify>
  <done>
    Application owns ConnectionPool(2 connections). ImportQueue receives ConnectionPool reference. Main thread Database remains dedicated for UI queries. Shutdown order is correct (ImportQueue before ConnectionPool before Database). Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
```bash
# Full build
cd /data/DW && cmake --build build 2>&1 | tail -20

# All tests pass
cd /data/DW && ./build/tests/dw_tests 2>&1 | tail -10

# Verify ConnectionPool is wired (grep for usage)
grep -n "ConnectionPool" /data/DW/src/app/application.cpp
grep -n "ScopedConnection" /data/DW/src/core/import/import_queue.cpp

# Verify ImportQueue no longer holds Database& directly
grep -n "Database&" /data/DW/src/core/import/import_queue.h
# Should return nothing (replaced with ConnectionPool&)
```
</verification>

<success_criteria>
- ImportQueue uses ConnectionPool& instead of Database&
- processTask() acquires connection via ScopedConnection, releases on return
- Application creates ConnectionPool with 2 connections after database initialization
- Application passes ConnectionPool to ImportQueue constructor
- Shutdown order: ImportQueue -> ConnectionPool -> Database
- Main thread Database remains separate (used by LibraryManager, ProjectManager)
- All existing tests pass with no regressions
- Application binary builds and links successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01.2-connectionpool/1.2-02-SUMMARY.md`
</output>
