---
phase: 01.2-connectionpool
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/database/connection_pool.h
  - src/core/database/connection_pool.cpp
  - src/core/database/database.h
  - src/core/database/database.cpp
  - tests/test_connection_pool.cpp
  - tests/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "ConnectionPool creates N database connections on construction"
    - "acquire() returns a valid Database pointer from the pool"
    - "release() returns a connection back to the pool for reuse"
    - "ScopedConnection automatically releases on scope exit"
    - "Pool throws on exhaustion when all connections are in use"
    - "Pooled connections use NOMUTEX mode for multi-thread safety"
    - "Each pooled connection has busy_timeout and synchronous=NORMAL set"
  artifacts:
    - path: "src/core/database/connection_pool.h"
      provides: "ConnectionPool and ScopedConnection class declarations"
      contains: "class ConnectionPool"
    - path: "src/core/database/connection_pool.cpp"
      provides: "ConnectionPool implementation with mutex-protected deque"
      contains: "ConnectionPool"
    - path: "tests/test_connection_pool.cpp"
      provides: "Unit tests for pool acquire/release/exhaustion/RAII"
      min_lines: 100
  key_links:
    - from: "src/core/database/connection_pool.cpp"
      to: "src/core/database/database.h"
      via: "Creates Database instances and calls open()"
      pattern: "Database.*open"
    - from: "src/core/database/connection_pool.h"
      to: "src/core/database/database.h"
      via: "Stores unique_ptr<Database> in deque"
      pattern: "unique_ptr<Database>"
---

<objective>
Implement ConnectionPool and ScopedConnection using TDD, plus enhance Database::open() with NOMUTEX flag, busy_timeout, and synchronous=NORMAL pragma.

Purpose: Provide thread-safe connection pooling so background workers (ImportQueue) and the main thread can access SQLite concurrently without SQLITE_BUSY errors. This is the core infrastructure that Phase 1.2 integration (Plan 02) builds on.

Output: connection_pool.h/.cpp with ConnectionPool and ScopedConnection classes, enhanced database.cpp, comprehensive unit tests.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.2-connectionpool/1.2-RESEARCH.md
@src/core/database/database.h
@src/core/database/database.cpp
@tests/CMakeLists.txt
</context>

<feature>
  <name>ConnectionPool with RAII ScopedConnection</name>
  <files>
    src/core/database/connection_pool.h
    src/core/database/connection_pool.cpp
    src/core/database/database.h
    src/core/database/database.cpp
    tests/test_connection_pool.cpp
    tests/CMakeLists.txt
  </files>
  <behavior>
    ConnectionPool manages a fixed-size pool of Database connections using a mutex-protected std::deque.

    Construction:
    - ConnectionPool(path, pool_size=2) creates pool_size Database instances
    - Each Database opened with sqlite3_open_v2 using SQLITE_OPEN_NOMUTEX flag
    - Each connection gets: busy_timeout=5000ms, foreign_keys=ON, journal_mode=WAL, synchronous=NORMAL

    acquire():
    - Returns Database* from front of deque (FIFO cycling)
    - Throws std::runtime_error if pool exhausted (deque empty)
    - Thread-safe (mutex-protected)

    release(Database*):
    - Returns connection to back of deque
    - Ignores nullptr
    - Thread-safe (mutex-protected)

    availableCount() / inUseCount():
    - Return current pool state (mutex-protected)

    ScopedConnection(ConnectionPool&):
    - Constructor calls acquire()
    - Destructor calls release()
    - Non-copyable, movable
    - get() returns Database*, operator-> returns Database*, operator* returns Database&
    - explicit operator bool

    Database::open() enhancement:
    - Add overload or modify to accept optional flags parameter
    - When used by ConnectionPool, pass SQLITE_OPEN_NOMUTEX
    - Add PRAGMA synchronous=NORMAL after WAL mode
    - Add sqlite3_busy_timeout(db, 5000)

    Test cases:
    - Construct pool with size 2 -> availableCount() == 2
    - acquire() returns non-null Database* -> availableCount() == 1
    - release() returns connection -> availableCount() == 2
    - acquire() twice exhausts pool of size 2 -> third acquire() throws
    - ScopedConnection auto-releases on scope exit
    - ScopedConnection move transfers ownership
    - Pool connections have WAL mode enabled (PRAGMA journal_mode query returns "wal")
    - Pool connections have synchronous=NORMAL (PRAGMA synchronous query returns 1)
    - Concurrent acquire/release from two threads does not corrupt state
    - Pool destructor closes all connections cleanly
  </behavior>
  <implementation>
    Step 1 — Enhance Database::open():
    - Add a new method: bool openWithFlags(const Path& path, int extraFlags)
    - In openWithFlags, use sqlite3_open_v2 with SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | extraFlags
    - Add sqlite3_busy_timeout(m_db, 5000) after successful open
    - Add PRAGMA synchronous = NORMAL after WAL mode pragma
    - Keep existing open() unchanged (backward compatible) — it should call openWithFlags with flags=0
    - Do NOT break any existing code that calls Database::open()

    Step 2 — Create ConnectionPool class (connection_pool.h):
    - namespace dw
    - #pragma once
    - Include database.h, mutex, deque, memory, stdexcept
    - Forward declare: class Database (already in database.h)
    - ConnectionPool(const Path& dbPath, size_t poolSize = 2)
    - ~ConnectionPool() closes all connections
    - Database* acquire() — lock mutex, pop front or throw
    - void release(Database* conn) — lock mutex, push back
    - size_t availableCount() const — lock mutex, return size
    - size_t inUseCount() const — lock mutex, return size
    - size_t totalSize() const — return m_poolSize (no lock needed, immutable)
    - Private: Path m_dbPath, std::deque<std::unique_ptr<Database>> m_available, std::vector<Database*> m_inUse, mutable std::mutex m_mutex, size_t m_poolSize

    Step 3 — Create ScopedConnection class (in connection_pool.h):
    - Nested or same header as ConnectionPool
    - explicit ScopedConnection(ConnectionPool& pool)
    - ~ScopedConnection() releases if m_conn != nullptr
    - Non-copyable (delete copy ctor/assign)
    - Movable (move ctor nulls source, move assign releases current then takes)
    - Database* get() const
    - Database* operator->() const
    - Database& operator*() const
    - explicit operator bool() const

    Step 4 — Implement ConnectionPool (connection_pool.cpp):
    - Constructor: loop poolSize times, create Database, call openWithFlags(path, SQLITE_OPEN_NOMUTEX), push to deque. If any open fails, throw runtime_error.
    - Destructor: lock mutex, clear m_available (unique_ptr destructors close DBs), clear m_inUse tracking
    - acquire(): unique_lock, check empty -> throw, pop front, release unique_ptr to raw, track in m_inUse, return raw
    - release(): lock_guard, remove from m_inUse, wrap in unique_ptr, push to m_available back

    Conventions to follow:
    - snake_case methods, PascalCase classes, m_ prefix for members
    - #pragma once
    - namespace dw { }
    - Use log::infof/errorf/warning from core/utils/log.h
    - Follow existing Database class patterns for error handling

    CMakeLists.txt changes:
    - Add test_connection_pool.cpp to DW_TEST_SOURCES under a "# Tier 1 — ConnectionPool" comment
    - Add ${CMAKE_SOURCE_DIR}/src/core/database/connection_pool.cpp to DW_TEST_DEPS
  </implementation>
</feature>

<verification>
```bash
cd /data/DW && cmake --build build --target dw_tests 2>&1 | tail -20
cd /data/DW && ./build/tests/dw_tests --gtest_filter="ConnectionPool*" 2>&1
cd /data/DW && ./build/tests/dw_tests 2>&1 | tail -5
```
- All ConnectionPool tests pass
- No regressions in existing tests (387+ tests still pass)
- Build completes with no warnings in new files
</verification>

<success_criteria>
- ConnectionPool creates and manages pooled Database connections
- ScopedConnection provides RAII acquire/release
- Database::openWithFlags() uses sqlite3_open_v2 with NOMUTEX, sets busy_timeout and synchronous=NORMAL
- Existing Database::open() behavior unchanged (backward compatible)
- All new tests pass, all existing tests pass
- Pool exhaustion throws std::runtime_error
- Concurrent access test passes without data corruption
</success_criteria>

<output>
After completion, create `.planning/phases/01.2-connectionpool/1.2-01-SUMMARY.md`
</output>
