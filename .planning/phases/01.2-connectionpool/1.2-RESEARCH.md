# Phase 1.2: SQLite ConnectionPool & WAL Mode - Research

**Researched:** 2026-02-08
**Domain:** SQLite concurrency, connection pooling, C++ RAII patterns
**Confidence:** HIGH

## Summary

SQLite's Write-Ahead Logging (WAL) mode enables concurrent readers with a single writer by separating write operations into a separate log file. WAL mode is already enabled in the existing Database class (lines 137-139 of database.cpp), so the focus is on implementing a robust connection pool to support concurrent access from the ImportQueue worker thread and potential future multi-threaded operations.

Connection pooling for SQLite differs from server-based databases—the overhead of creating connections is microseconds, not milliseconds. The primary benefit is not avoiding connection creation overhead, but enabling safe concurrent access patterns. A connection pool size of 2-4 connections is recommended: 1 for main thread UI/queries, 2-3 for background workers.

The existing Database class uses serialized mode (SQLite's default), which allows sharing connections across threads with mutex protection. For connection pooling, multi-thread mode is superior—each connection is used by only one thread at a time, eliminating mutex serialization overhead. This requires setting `SQLITE_OPEN_NOMUTEX` flag when opening connections.

**Primary recommendation:** Implement a mutex-protected deque-based connection pool with RAII ScopedConnection guard. Use multi-thread mode (NOMUTEX) for pooled connections. Pool size 2-4 connections. Set busy_timeout=5000ms per connection to handle transient lock contention.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| SQLite3 | 3.45.0 | Embedded database | Already in use; WAL mode since 3.7.0 (2010) |
| Standard C++17 | - | Threading primitives | std::mutex, std::deque, std::unique_lock, std::condition_variable |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| std::lock_guard | C++11 | Scoped mutex locking | Short critical sections (acquire/release from pool) |
| std::unique_lock | C++11 | Flexible mutex locking | Condition variable support, complex locking scenarios |
| std::condition_variable | C++11 | Thread signaling | Optional: wait for available connection on pool exhaustion |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Deque-based pool | Thread-local connections | Thread-local simpler but wastes connections; pool allows dynamic allocation |
| Multi-thread mode | Serialized mode (default) | Serialized allows sharing connections but adds mutex overhead to every SQLite call |
| RAII ScopedConnection | Manual acquire/release | Manual error-prone; RAII guarantees return even on exception |

**Configuration:**
```cpp
// Open connections with NOMUTEX for multi-thread mode
sqlite3_open_v2(path.c_str(), &db,
    SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX,
    nullptr);

// Set busy timeout per connection (handle transient lock contention)
sqlite3_busy_timeout(db, 5000); // 5 seconds
```

## Architecture Patterns

### Recommended Project Structure
```
src/core/database/
├── database.h, database.cpp           # Existing: single connection wrapper
├── connection_pool.h, connection_pool.cpp  # NEW: pool management
└── *_repository.h, *_repository.cpp   # Modified: accept Database& or ConnectionPool&
```

### Pattern 1: Deque-Based Connection Pool with Mutex Protection
**What:** Store connections in std::deque protected by std::mutex. Acquire pops from front, release pushes to back (ensures cycling).
**When to use:** Default pattern for connection pooling—simple, proven, thread-safe.
**Example:**
```cpp
// Source: https://github.com/active911/connection-pool pattern adapted for SQLite
class ConnectionPool {
public:
    ConnectionPool(const Path& dbPath, size_t poolSize);
    Database* acquire();         // Blocks if pool empty, or throws
    void release(Database* conn); // Returns to pool

private:
    std::deque<std::unique_ptr<Database>> m_available;
    std::mutex m_mutex;
    Path m_dbPath;
};
```

### Pattern 2: RAII ScopedConnection Guard
**What:** RAII wrapper that acquires connection in constructor, releases in destructor.
**When to use:** Every time code needs database access—guarantees return to pool even on exception.
**Example:**
```cpp
// Source: RAII pattern from https://en.cppreference.com/w/cpp/language/raii
class ScopedConnection {
public:
    explicit ScopedConnection(ConnectionPool& pool)
        : m_pool(pool), m_conn(pool.acquire()) {}

    ~ScopedConnection() {
        if (m_conn) m_pool.release(m_conn);
    }

    // Non-copyable, movable
    ScopedConnection(const ScopedConnection&) = delete;
    ScopedConnection& operator=(const ScopedConnection&) = delete;
    ScopedConnection(ScopedConnection&&) noexcept = default;
    ScopedConnection& operator=(ScopedConnection&&) noexcept = default;

    Database* get() const { return m_conn; }
    Database* operator->() const { return m_conn; }

private:
    ConnectionPool& m_pool;
    Database* m_conn;
};
```

### Pattern 3: Repository Refactoring for Pool Support
**What:** Repositories currently store Database& reference. Refactor to accept ConnectionPool& and acquire connection per operation.
**When to use:** When transitioning from single connection to pooled connections.
**Example:**
```cpp
class ModelRepository {
public:
    // Option A: Store pool reference, acquire per-operation
    explicit ModelRepository(ConnectionPool& pool) : m_pool(pool) {}

    std::optional<i64> insert(const ModelRecord& model) {
        ScopedConnection conn(m_pool);
        auto stmt = conn->prepare("INSERT INTO models...");
        // ... use connection
    }

private:
    ConnectionPool& m_pool;
};

// Option B: Continue accepting Database&, caller manages connection
// (Preferred for phase 1.2—less invasive)
class ModelRepository {
public:
    explicit ModelRepository(Database& db) : m_db(db) {}
    // ... existing interface unchanged
private:
    Database& m_db;
};
```

### Pattern 4: Per-Thread Connection Affinity (Optional Future Optimization)
**What:** Assign connections to specific threads via thread-local storage, avoiding acquire/release overhead.
**When to use:** If profiling shows acquire/release mutex contention is bottleneck.
**Example:**
```cpp
// Future optimization—not recommended for phase 1.2
thread_local Database* t_connection = nullptr;

Database* getThreadConnection(ConnectionPool& pool) {
    if (!t_connection) {
        t_connection = pool.acquire();
        // Register thread cleanup to release connection
    }
    return t_connection;
}
```

### Anti-Patterns to Avoid
- **Sharing single connection without pool:** Current Database class uses serialized mode (safe but slow). Don't share Database* across threads without pool management.
- **Forgetting to release connections:** Always use RAII ScopedConnection—manual acquire/release is error-prone.
- **Pool exhaustion without timeout:** Decide: block until available, throw immediately, or create temporary connection? Document choice clearly.
- **Opening connections in wrong threading mode:** Pooled connections MUST use NOMUTEX flag; serialized mode adds unnecessary mutex overhead.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Thread-safe queue | Custom linked list with mutex | std::deque + std::mutex + std::lock_guard | Standard library is tested, optimized, exception-safe |
| RAII scoped locking | try/finally, manual unlock | std::lock_guard, std::unique_lock | Guarantees unlock even on exception; compiler-enforced |
| Busy retry logic | Custom sleep/retry loop | sqlite3_busy_timeout() | SQLite built-in handles exponential backoff, signals |
| Connection lifecycle | Raw pointers, manual delete | std::unique_ptr, std::shared_ptr | Automatic cleanup, move semantics, exception-safe |

**Key insight:** SQLite and C++ standard library provide robust primitives for threading and resource management. Custom solutions introduce bugs, ignore edge cases (signals, exceptions, deadlocks). Use proven patterns.

## Common Pitfalls

### Pitfall 1: Using Serialized Mode for Pooled Connections
**What goes wrong:** Opening connections without NOMUTEX flag uses serialized mode, adding mutex overhead to every sqlite3_* call.
**Why it happens:** SQLite defaults to serialized mode (SQLITE_THREADSAFE=1). Developers assume "thread-safe" means "optimal for pooling."
**How to avoid:** Explicitly pass `SQLITE_OPEN_NOMUTEX` flag when opening pooled connections. Multi-thread mode is correct when each connection is used by one thread at a time.
**Warning signs:** Profiling shows mutex contention in sqlite3_step, sqlite3_prepare_v2, etc.

### Pitfall 2: Forgetting to Enable WAL Mode on Pooled Connections
**What goes wrong:** Each connection opens with journal_mode=DELETE (default). WAL mode must be set per connection, or persisted by first connection.
**Why it happens:** Assuming WAL mode is database-global, not connection-specific.
**How to avoid:** WAL mode is persistent—once set, survives reconnection. Verify existing Database::open() already sets WAL (it does, line 137-139 of database.cpp). Pool can rely on persistence, but good practice to verify on first acquire.
**Warning signs:** SQLITE_BUSY errors despite WAL mode supposedly enabled; `PRAGMA journal_mode` returns "delete" instead of "wal".

### Pitfall 3: SQLITE_BUSY Despite Busy Timeout
**What goes wrong:** sqlite3_busy_timeout set correctly, but still getting SQLITE_BUSY immediately on contention.
**Why it happens:** BEGIN DEFERRED (default) acquires read lock, then upgrades to write lock on first write statement. Upgrade can fail with SQLITE_BUSY even with timeout. Timeout only applies to initial lock acquisition, not upgrades.
**How to avoid:** Use `BEGIN IMMEDIATE` for transactions that will write. Acquires write lock immediately, fails fast if another writer exists, but respects busy_timeout.
**Warning signs:** SQLITE_BUSY on UPDATE/INSERT mid-transaction, not on BEGIN.

### Pitfall 4: Pool Exhaustion Deadlock
**What goes wrong:** Thread A acquires connection 1, then tries to acquire connection 2 (pool exhausted, blocks). Thread B holds connection 2, waiting for A's transaction to finish. Deadlock.
**Why it happens:** Code path acquires multiple connections without realizing it (nested function calls, recursive repository access).
**How to avoid:** Design rule: each thread acquires at most one connection at a time. Repositories should operate on single connection passed in, not acquire additional connections. Document pool size and expected concurrency.
**Warning signs:** Application hangs during database operations; profiling shows threads blocked in ConnectionPool::acquire().

### Pitfall 5: Forgetting to Finalize Prepared Statements Before Closing Connection
**What goes wrong:** Statement objects hold sqlite3_stmt* from a connection. Closing connection before finalizing statements causes use-after-free or resource leaks.
**Why it happens:** Statement lifetime exceeds connection lifetime, or exceptions bypass cleanup.
**How to avoid:** Statement class already handles cleanup in destructor (line 16-18 of database.cpp). Ensure Statement objects don't outlive Database* they're prepared from. RAII helps—Statement destructor runs before ScopedConnection destructor.
**Warning signs:** Valgrind/ASan reports use-after-free in sqlite3_finalize; SQLite warnings about unclosed statements.

### Pitfall 6: Not Setting PRAGMA synchronous=NORMAL with WAL Mode
**What goes wrong:** Default PRAGMA synchronous=FULL syncs WAL on every commit, blocking writer threads on I/O.
**Why it happens:** Developers are cautious about durability, unaware WAL mode changes durability guarantees.
**How to avoid:** With WAL mode, `PRAGMA synchronous=NORMAL` is recommended for performance. Trades durability on power loss (loses last checkpoint) for avoiding fsync on every commit. For desktop app (not critical server), this is acceptable.
**Warning signs:** Write performance much slower than expected; profiling shows time spent in fsync/FlushFileBuffers.

### Pitfall 7: Mixing Database& and ConnectionPool& in Same Codebase
**What goes wrong:** Application class holds single Database connection, ImportQueue uses ConnectionPool. Concurrent access to Application's Database from main thread while worker thread uses pooled connection causes SQLITE_BUSY.
**Why it happens:** Partial migration—some code paths use old single connection, others use pool.
**How to avoid:** Phase 1.2 approach: Keep Application's Database for main thread UI operations. ConnectionPool is separate, used only by ImportQueue worker thread. Future: migrate Application to also use pool. Document which code paths use which connection strategy.
**Warning signs:** SQLITE_BUSY errors only when import is active; no errors when idle.

## Code Examples

Verified patterns adapted from official sources and established C++ patterns:

### Enable WAL Mode and Set Pragmas
```cpp
// Source: https://www.sqlite.org/wal.html official documentation
bool Database::open(const Path& path) {
    // Open with NOMUTEX for connection pool multi-thread mode
    int result = sqlite3_open_v2(
        path.string().c_str(),
        &m_db,
        SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX,
        nullptr
    );

    if (result != SQLITE_OK) {
        log::errorf("Database", "Failed to open: %s", sqlite3_errmsg(m_db));
        sqlite3_close(m_db);
        m_db = nullptr;
        return false;
    }

    // Set busy timeout (handle transient lock contention)
    sqlite3_busy_timeout(m_db, 5000); // 5 seconds

    // Enable foreign keys
    if (!execute("PRAGMA foreign_keys = ON")) {
        log::warning("Database", "Failed to enable foreign keys");
    }

    // Use WAL mode for better concurrency (persistent once set)
    if (!execute("PRAGMA journal_mode = WAL")) {
        log::warning("Database", "Failed to set WAL mode");
    }

    // Recommended for WAL mode: avoid fsync on every commit
    if (!execute("PRAGMA synchronous = NORMAL")) {
        log::warning("Database", "Failed to set synchronous mode");
    }

    return true;
}
```

### Connection Pool Implementation
```cpp
// Source: Adapted from https://github.com/active911/connection-pool pattern
class ConnectionPool {
public:
    explicit ConnectionPool(const Path& dbPath, size_t poolSize = 4)
        : m_dbPath(dbPath) {

        // Pre-allocate pool
        for (size_t i = 0; i < poolSize; ++i) {
            auto db = std::make_unique<Database>();
            if (!db->open(m_dbPath)) {
                throw std::runtime_error("Failed to open pooled connection");
            }
            m_available.push_back(std::move(db));
        }

        log::infof("ConnectionPool", "Created pool with %zu connections", poolSize);
    }

    ~ConnectionPool() {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_available.clear(); // Database destructors close connections
    }

    // Acquire connection from pool (blocks if empty—option: throw instead)
    Database* acquire() {
        std::unique_lock<std::mutex> lock(m_mutex);

        // Option A: Block until available (requires condition_variable)
        // m_cv.wait(lock, [this] { return !m_available.empty(); });

        // Option B: Throw if exhausted (simpler, fail-fast)
        if (m_available.empty()) {
            throw std::runtime_error("Connection pool exhausted");
        }

        // Pop from front (FIFO ensures cycling)
        auto conn = std::move(m_available.front());
        m_available.pop_front();

        Database* raw = conn.release();
        m_inUse.push_back(raw); // Track for debugging

        return raw;
    }

    // Release connection back to pool
    void release(Database* conn) {
        if (!conn) return;

        std::lock_guard<std::mutex> lock(m_mutex);

        // Remove from in-use tracking
        auto it = std::find(m_inUse.begin(), m_inUse.end(), conn);
        if (it != m_inUse.end()) {
            m_inUse.erase(it);
        }

        // Return to pool (push to back—FIFO cycling)
        m_available.push_back(std::unique_ptr<Database>(conn));

        // Option A: Signal waiting threads
        // m_cv.notify_one();
    }

    size_t availableCount() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_available.size();
    }

    size_t inUseCount() const {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_inUse.size();
    }

private:
    Path m_dbPath;
    std::deque<std::unique_ptr<Database>> m_available;
    std::vector<Database*> m_inUse; // Debugging: track active connections
    mutable std::mutex m_mutex;
    // std::condition_variable m_cv; // Optional: for blocking acquire
};
```

### RAII ScopedConnection Guard
```cpp
// Source: RAII pattern from https://en.cppreference.com/w/cpp/language/raii
class ScopedConnection {
public:
    explicit ScopedConnection(ConnectionPool& pool)
        : m_pool(pool), m_conn(pool.acquire()) {}

    ~ScopedConnection() {
        if (m_conn) {
            m_pool.release(m_conn);
        }
    }

    // Non-copyable
    ScopedConnection(const ScopedConnection&) = delete;
    ScopedConnection& operator=(const ScopedConnection&) = delete;

    // Movable
    ScopedConnection(ScopedConnection&& other) noexcept
        : m_pool(other.m_pool), m_conn(other.m_conn) {
        other.m_conn = nullptr;
    }

    ScopedConnection& operator=(ScopedConnection&& other) noexcept {
        if (this != &other) {
            if (m_conn) {
                m_pool.release(m_conn);
            }
            m_conn = other.m_conn;
            other.m_conn = nullptr;
        }
        return *this;
    }

    Database* get() const { return m_conn; }
    Database* operator->() const { return m_conn; }
    Database& operator*() const { return *m_conn; }

    explicit operator bool() const { return m_conn != nullptr; }

private:
    ConnectionPool& m_pool;
    Database* m_conn;
};

// Usage:
void ImportQueue::processTask(ImportTask& task) {
    ScopedConnection conn(m_pool);

    // Use connection
    ModelRepository repo(*conn);
    auto modelId = repo.insert(record);

    // Connection automatically returned to pool on scope exit
}
```

### ImportQueue Refactor to Use Pool
```cpp
// Modified ImportQueue to use ConnectionPool instead of Database&
class ImportQueue {
public:
    explicit ImportQueue(ConnectionPool& pool)
        : m_pool(pool) {}

    // ... existing interface unchanged

private:
    void workerLoop() {
        while (!m_shutdown.load()) {
            ImportTask task;

            // Grab next pending task
            {
                std::lock_guard<std::mutex> lock(m_mutex);
                if (m_pending.empty()) break;
                task = std::move(m_pending.front());
                m_pending.erase(m_pending.begin());
            }

            // Process task—acquires connection per task
            processTask(task);
        }
    }

    void processTask(ImportTask& task) {
        // Acquire connection for this task only
        ScopedConnection conn(m_pool);

        // Stage 1-2: Reading, hashing (no DB access)
        // ...

        // Stage 3: Check duplicate
        ModelRepository repo(*conn);
        auto existing = repo.findByHash(task.fileHash);
        if (existing) {
            task.isDuplicate = true;
            return;
        }

        // Stage 4: Parsing (no DB access)
        // ...

        // Stage 5: Insert
        auto modelId = repo.insert(record);

        // Connection released automatically when conn goes out of scope
    }

    ConnectionPool& m_pool;
    // Remove: Database& m_db; ModelRepository m_modelRepo;
    // ... rest unchanged
};
```

### Transaction Best Practice: BEGIN IMMEDIATE for Writes
```cpp
// Source: https://www.sqlite.org/lang_transaction.html
class Transaction {
public:
    explicit Transaction(Database& db, bool immediate = false) : m_db(db) {
        if (immediate) {
            // Acquire write lock immediately—fail fast if another writer exists
            if (!m_db.execute("BEGIN IMMEDIATE")) {
                throw std::runtime_error("Failed to begin immediate transaction");
            }
        } else {
            // Default: BEGIN DEFERRED (upgrades to write on first write statement)
            if (!m_db.beginTransaction()) {
                throw std::runtime_error("Failed to begin transaction");
            }
        }
    }

    // ... rest of Transaction class unchanged
};

// Usage:
void insertModel(Database& db, const ModelRecord& record) {
    // Use immediate=true when you know you'll write
    Transaction txn(db, /*immediate=*/true);

    auto stmt = db.prepare("INSERT INTO models...");
    // ... bind, execute

    txn.commit();
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single Database connection, shared across threads with serialized mode | Connection pool with multi-thread mode (NOMUTEX) | Phase 1.2 | Eliminates mutex overhead on every SQLite call; enables true concurrent access |
| Default journal mode (DELETE) | WAL mode | Already implemented (database.cpp line 137) | Readers don't block writers; writers don't block readers |
| BEGIN DEFERRED for all transactions | BEGIN IMMEDIATE for write transactions | Best practice since SQLite 3.7.0 | Fails fast on write contention instead of mid-transaction SQLITE_BUSY |
| synchronous=FULL | synchronous=NORMAL with WAL | Recommended since WAL introduction | Avoids fsync on every commit; checkpoint handles durability |
| Manual connection management | RAII ScopedConnection guard | Modern C++11+ pattern | Exception-safe, compiler-enforced cleanup |

**Deprecated/outdated:**
- **Rollback journal mode:** WAL mode is standard for concurrent access since SQLite 3.7.0 (2010).
- **Single connection per application:** Multi-threaded apps need connection pooling to avoid SQLITE_BUSY.
- **sqlite3_open() without flags:** Always specify threading mode explicitly (NOMUTEX for pooled connections).

## Open Questions

1. **Should ConnectionPool block or throw on exhaustion?**
   - What we know: Blocking requires std::condition_variable, throwing is simpler but requires caller retry logic.
   - What's unclear: ImportQueue is single worker thread—pool exhaustion only if main thread also acquires. Is this expected?
   - Recommendation: Throw on exhaustion for phase 1.2 (simpler). Pool size 2-4 sufficient for single worker + main thread. Future: add blocking if multi-worker threads added.

2. **Should repositories store ConnectionPool& or Database&?**
   - What we know: Current repositories store Database& reference, constructed once. Storing ConnectionPool& means acquiring connection per operation (overhead).
   - What's unclear: How often are repositories reused? If ModelRepository is per-task, no benefit to storing pool.
   - Recommendation: Phase 1.2—keep repositories accepting Database&. Caller (ImportQueue) manages ScopedConnection, passes Database* to repository. Simpler, less invasive.

3. **Should Application class also use ConnectionPool?**
   - What we know: Application currently holds single Database for UI queries. ImportQueue needs separate access. Could share pool, or keep Application's dedicated connection.
   - What's unclear: Frequency of UI queries vs background imports. Does mixing UI and worker threads on same pool cause contention?
   - Recommendation: Phase 1.2—keep Application's dedicated Database connection. Pool used only by ImportQueue. Prevents UI queries blocking on pool exhaustion during heavy imports. Future: measure if combining pools improves or hurts performance.

4. **What pool size is optimal?**
   - What we know: Common recommendation is CPU_cores * 2 for read-heavy workloads. SQLite has single writer, so write-heavy doesn't benefit from large pools. ImportQueue is single worker thread currently.
   - What's unclear: Future phases might add multiple worker threads.
   - Recommendation: Start with pool_size=2 for phase 1.2 (1 for worker, 1 spare for main thread if needed). Make configurable, easy to increase for future phases.

5. **Should ConnectionPool own Database instances or store Database*?**
   - What we know: Ownership clarifies lifecycle—pool destructor closes connections. Raw pointers require manual cleanup tracking.
   - What's unclear: None—std::unique_ptr is clearly correct.
   - Recommendation: Use std::deque<std::unique_ptr<Database>>. Ownership clear, exception-safe, move semantics efficient.

## Sources

### Primary (HIGH confidence)
- [SQLite WAL Mode Official Documentation](https://www.sqlite.org/wal.html) - How WAL enables concurrent access, PRAGMA settings, checkpointing, synchronous mode
- [SQLite Threading Modes Official Documentation](https://www.sqlite.org/threadsafe.html) - Serialized vs multi-thread vs single-thread modes, configuration methods
- [SQLite Transaction Types Official Documentation](https://www.sqlite.org/lang_transaction.html) - BEGIN DEFERRED vs IMMEDIATE vs EXCLUSIVE, locking behavior
- [SQLite busy_timeout API Documentation](https://www.sqlite.org/c3ref/busy_timeout.html) - Busy handler configuration for lock contention
- [RAII - cppreference.com](https://en.cppreference.com/w/cpp/language/raii) - Resource acquisition is initialization pattern
- [std::lock_guard - cppreference.com](https://en.cppreference.com/w/cpp/thread/lock_guard) - Scoped mutex locking

### Secondary (MEDIUM confidence)
- [A universal connection pool written in C++](https://levelup.gitconnected.com/a-universal-connection-pool-written-in-c-6f4f14a98a9e) - RAII ScopedConnection pattern, borrow/unborrow design
- [GitHub: active911/connection-pool](https://github.com/active911/connection-pool) - Deque-based pool with shared_ptr, pop from front/push to back cycling
- [Multi-threaded Access to an SQLite3 Database](https://dev.yorhel.nl/doc/sqlaccess) - Connection pool vs message queue approaches for SQLite
- [SQLite SQLITE_BUSY Error Guide - Sling Academy](https://www.slingacademy.com/article/sqlite-error-sqlite-busy-database-is-busy/) - Timeout configuration, transaction best practices, retry logic
- [SQLite User Forum: How many read connections when using concurrency?](https://sqlite.org/forum/info/a7a8ca4d88b94fd558c47c11748e4d8886992cf9973f6604025e85adb66ba6b5) - Pool size recommendation: CPU*2 for read-heavy workloads
- [SQLite Database is Locked: Complete Guide to Fixing SQLITE_BUSY Errors in 2026](https://copyprogramming.com/howto/getting-sqlite-busy-exception-sqlite-busy-the-database-file-is-locked-database-is-locked) - 2026 best practices: WAL mode, BEGIN IMMEDIATE, connection pooling

### Tertiary (LOW confidence - community wisdom, not official)
- [What to do about SQLITE_BUSY errors despite setting a timeout - Bert Hubert's writings](https://berthub.eu/articles/posts/a-brief-post-on-sqlite3-database-locked-despite-timeout/) - Practical advice on BEGIN IMMEDIATE vs DEFERRED
- [Managing Concurrent Access in SQLite Databases - Sling Academy](https://www.slingacademy.com/article/managing-concurrent-access-in-sqlite-databases/) - Connection pooling for multi-threaded applications

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - SQLite 3.45.0 already in use (cmake/Dependencies.cmake), C++17 standard library threading primitives well-established
- Architecture: HIGH - RAII and connection pool patterns verified from official C++ references and established GitHub implementations
- Pitfalls: HIGH - All pitfalls verified from official SQLite documentation (WAL mode, threading modes, transaction types, busy_timeout)
- Code examples: HIGH - Adapted from official SQLite docs and cppreference.com RAII patterns, verified against existing codebase structure

**Research date:** 2026-02-08
**Valid until:** 2026-09-08 (6 months - stable domain, SQLite infrequent breaking changes)
