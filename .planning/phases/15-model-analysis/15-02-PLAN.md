# Plan 15-02: Island Detection and Visual Annotation

**Phase**: 15 — Model Analysis
**Requirements**: DC-06, DC-07, DC-08

## Overview

Detect "island" regions in the heightmap — enclosed depressions where a tapered or ball nose bit would be fully buried, requiring a clearing pass. Islands are identified via flood-fill from the surface, classified by depth and area, and annotated on the heightmap preview.

## New Files

### `src/core/carve/island_detector.h` (~90 lines)

```cpp
namespace dw {
namespace carve {

struct Island {
    int id = 0;
    std::vector<std::pair<int, int>> cells;  // (col, row) grid positions
    f32 minZ = 0.0f;           // Deepest point in island
    f32 maxZ = 0.0f;           // Shallowest point (entry rim)
    f32 depth = 0.0f;          // maxZ - minZ
    f32 areaMm2 = 0.0f;        // Physical area in mm^2
    f32 minClearDiameter = 0.0f; // Min clearing tool diameter (mm)
    Vec2 centroid;              // Center position in world coords
    Vec2 boundsMin, boundsMax; // Bounding box in world coords
};

struct IslandResult {
    std::vector<Island> islands;
    // Grid mask: -1 = not island, >= 0 = island ID
    std::vector<int> islandMask;
    int maskCols = 0;
    int maskRows = 0;
};

// Detect islands in heightmap.
// toolAngleDeg: included angle of finishing tool (V-bit).
//   A cell is "buried" if surrounding height exceeds what
//   the taper can reach at that XY distance.
// minIslandArea: ignore islands smaller than this (mm^2)
IslandResult detectIslands(const Heightmap& heightmap,
                           f32 toolAngleDeg,
                           f32 minIslandAreaMm2 = 1.0f);

} // namespace carve
} // namespace dw
```

### `src/core/carve/island_detector.cpp` (~200 lines)

**detectIslands()** algorithm:

1. **Compute burial mask** (~40 lines helper):
   - For each cell, check if it is "reachable" by the finishing V-bit from any neighbor
   - A cell at Z is reachable if, for at least one cardinal neighbor at distance `d`:
     `neighborZ - Z <= d * tan(angle/2)` (the taper slope allows access)
   - Mark cells as buried (1) or accessible (0)

2. **Flood-fill islands** (~30 lines helper):
   - Scan buried mask for unvisited buried cells
   - 4-connected flood-fill to group contiguous buried regions
   - Each group becomes an Island with unique ID

3. **Classify islands** (~30 lines helper):
   - For each island: compute depth (rim Z - min Z), area (cell count * res^2)
   - Compute centroid and bounding box in world coordinates
   - Compute minimum clearing tool diameter: `2 * maxDistFromRim` where maxDistFromRim
     is the maximum distance from any island cell to the nearest non-island cell
   - Filter out islands below minIslandAreaMm2

4. **Build island mask** grid for visualization (same dimensions as heightmap)

**Helper: `distanceToRim()`** (~15 lines):
- BFS from island boundary inward to find maximum interior distance
- This determines the narrowest clearing tool that can reach all island cells

### `src/core/carve/analysis_overlay.h` (~40 lines)

```cpp
namespace dw {
namespace carve {

// Generate colored overlay texture data for heightmap preview.
// Returns RGBA pixel data (width x height x 4 bytes).
std::vector<u8> generateAnalysisOverlay(
    const Heightmap& heightmap,
    const IslandResult& islands,
    const CurvatureResult& curvature,
    int width, int height);

} // namespace carve
} // namespace dw
```

### `src/core/carve/analysis_overlay.cpp` (~100 lines)

**generateAnalysisOverlay()**:
1. Base: heightmap Z values mapped to grayscale (white = high, dark = low)
2. Island overlay: semi-transparent red/orange fill over island cells, distinct hue per island ID
3. Min radius annotation: bright marker at minimum curvature location
4. Returns RGBA buffer ready for OpenGL texture upload

### Tests

`src/core/carve/island_detector_test.cpp` (~120 lines):

- `TEST(IslandDetector, NoIslands)` — gentle surface with no enclosed depressions
- `TEST(IslandDetector, SinglePit)` — circular pit in flat surface detected as 1 island
- `TEST(IslandDetector, MultipleIslands)` — two separated pits detected as 2 islands
- `TEST(IslandDetector, ShallowIgnored)` — pit below minIslandArea threshold is filtered
- `TEST(IslandDetector, DepthClassification)` — island depth matches known pit depth
- `TEST(IslandDetector, ClearingDiameter)` — narrow pit returns small diameter, wide pit returns large

`src/core/carve/analysis_overlay_test.cpp` (~40 lines):

- `TEST(AnalysisOverlay, EmptyHeightmap)` — empty input returns empty buffer
- `TEST(AnalysisOverlay, CorrectDimensions)` — output buffer size matches width * height * 4

## Coding Standards Compliance

- Largest file is island_detector.cpp at ~200 lines (well within 800 limit)
- detectIslands delegates to 3 helper functions, each under 40 lines
- Free functions for stateless analysis
- Island struct holds computed results, no behavior
- Overlay is pure data (u8 buffer), no GL calls in core/carve/
