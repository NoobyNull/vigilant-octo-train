---
phase: 12-extended
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/panels/cnc_jog_panel.h
  - src/ui/panels/cnc_jog_panel.cpp
  - src/core/cnc/cnc_controller.h
  - src/core/cnc/cnc_controller.cpp
  - src/core/cnc/macro_manager.h
  - src/core/cnc/macro_manager.cpp
autonomous: true
requirements:
  - EXT-08
  - EXT-10
  - EXT-13

must_haves:
  truths:
    - "A keyboard shortcut cycles through jog step size groups (small->medium->large->small)"
    - "When M6 tool change is encountered during streaming, the job pauses and waits for operator acknowledgment before continuing"
    - "Macros support nested expansion via M98 Pxxxx with a recursion guard (max depth 16) and error reporting"
  artifacts:
    - path: "src/ui/panels/cnc_jog_panel.cpp"
      provides: "Cycle-steps keyboard shortcut handler"
      contains: "cycleStepGroup"
    - path: "src/core/cnc/cnc_controller.cpp"
      provides: "M6 tool change detection and pause during streaming"
      contains: "M6"
    - path: "src/core/cnc/macro_manager.cpp"
      provides: "M98 nested macro expansion with recursion guard"
      contains: "expandM98"
  key_links:
    - from: "src/ui/panels/cnc_jog_panel.cpp"
      to: "src/ui/panels/cnc_jog_panel.h"
      via: "m_selectedStep cycled through step group boundaries"
      pattern: "cycleStepGroup"
    - from: "src/core/cnc/cnc_controller.cpp"
      to: "src/core/cnc/cnc_types.h"
      via: "CncCallbacks for M6 tool change notification"
      pattern: "onToolChange"
    - from: "src/core/cnc/macro_manager.cpp"
      to: "src/core/cnc/macro_manager.h"
      via: "expandLines() calls parseLines recursively with depth guard"
      pattern: "expandM98"
---

<objective>
Add cycle-steps keyboard shortcut for jog, M6 tool change detection during streaming, and nested macro expansion via M98.

Purpose: Improve operator efficiency with quick jog step cycling, safe tool change handling during jobs, and advanced macro capabilities via nested expansion.
Output: Keyboard shortcut for step cycling in jog panel, M6 pause-and-acknowledge in controller, M98 expansion with recursion guard in macro manager.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/ui/panels/cnc_jog_panel.h
@src/ui/panels/cnc_jog_panel.cpp
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_controller.cpp
@src/core/cnc/macro_manager.h
@src/core/cnc/macro_manager.cpp
@src/core/cnc/cnc_types.h

<interfaces>
From src/ui/panels/cnc_jog_panel.h:
```cpp
class CncJogPanel : public Panel {
    static constexpr float STEP_SIZES[] = {0.01f, 0.1f, 1.0f, 10.0f, 100.0f};
    static constexpr int NUM_STEPS = 5;
    int m_selectedStep = 2; // Default to 1mm
    // Step groups: Small (0,1) = 0.01-0.1, Medium (2) = 1, Large (3,4) = 10-100
    void handleKeyboardJog(); // Called each frame
};
```

From src/core/cnc/cnc_controller.h:
```cpp
class CncController {
    void startStream(const std::vector<std::string>& lines);
    void stopStream();
    void feedHold();
    void cycleStart();
    bool isStreaming() const;
    // processResponse() handles each GRBL response line
    void processResponse(const std::string& line);
    void sendNextLines(); // Sends lines from m_program to GRBL
};
```

From src/core/cnc/cnc_types.h:
```cpp
struct CncCallbacks {
    std::function<void(bool connected, const std::string& version)> onConnectionChanged;
    std::function<void(const MachineStatus& status)> onStatusUpdate;
    std::function<void(const LineAck& ack)> onLineAcked;
    std::function<void(const StreamProgress& progress)> onProgressUpdate;
    std::function<void(int alarmCode, const std::string& desc)> onAlarm;
    std::function<void(const std::string& message)> onError;
    std::function<void(const StreamingError& error)> onStreamingError;
    std::function<void(const std::string& line, bool isSent)> onRawLine;
    // Will add: std::function<void(int toolNumber)> onToolChange;
};
```

From src/core/cnc/macro_manager.h:
```cpp
class MacroManager {
    std::vector<Macro> getAll() const;
    Macro getById(int id) const;
    std::vector<std::string> parseLines(const Macro& macro) const;
    // parseLines splits by newlines, removes comments/blank lines
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cycle-steps keyboard shortcut for jog step sizes</name>
  <files>
    src/ui/panels/cnc_jog_panel.h
    src/ui/panels/cnc_jog_panel.cpp
  </files>
  <action>
**Cycle-steps shortcut (EXT-08):**

The step sizes are: 0.01, 0.1, 1, 10, 100mm (indices 0-4).
Step groups: Small (0-1), Medium (2), Large (3-4).
Cycling goes: Small -> Medium -> Large -> Small.

When cycling, jump to the "representative" step in each group:
- Small: index 1 (0.1mm)
- Medium: index 2 (1mm)
- Large: index 3 (10mm)

1. In cnc_jog_panel.h, add:
```cpp
void cycleStepGroup();
```

2. In cnc_jog_panel.cpp, implement:
```cpp
void CncJogPanel::cycleStepGroup() {
    // Determine current group and advance to next
    if (m_selectedStep <= 1) {
        // Currently in Small -> go to Medium
        m_selectedStep = 2;
    } else if (m_selectedStep == 2) {
        // Currently in Medium -> go to Large
        m_selectedStep = 3;
    } else {
        // Currently in Large -> go to Small
        m_selectedStep = 1; // 0.1mm (more useful default than 0.01mm)
    }
}
```

3. In `handleKeyboardJog()` (called each frame), add detection for the cycle shortcut. Use `Tab` key or a configurable shortcut. For simplicity, use the `Tab` key when the jog panel is focused, or check globally if the CNC workspace is active:

```cpp
// In handleKeyboardJog(), add at the start:
if (ImGui::IsKeyPressed(ImGuiKey_Tab) && !ImGui::GetIO().WantTextInput) {
    cycleStepGroup();
}
```

Alternatively, if handleKeyboardJog is only called when CNC workspace is active (check the calling code in UIManager), then Tab is safe. If it's called globally, gate it on CNC workspace mode.

Check how handleKeyboardJog() is called. If it's called from UIManager::handleCncKeyboardJog(), it's already gated on CNC workspace being active. In that case, Tab is safe to use.

4. Add a tooltip to the step size selector indicating the shortcut:
```cpp
// In renderStepSizeSelector(), after the buttons:
ImGui::TextDisabled("Tab to cycle step groups");
```
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Tab key cycles through jog step groups: Small (0.1mm) -> Medium (1mm) -> Large (10mm) -> Small
- Step selector shows shortcut hint
- Shortcut only active when CNC workspace is active and no text input is focused
  </done>
</task>

<task type="auto">
  <name>Task 2: M6 tool change detection and M98 nested macro expansion</name>
  <files>
    src/core/cnc/cnc_controller.h
    src/core/cnc/cnc_controller.cpp
    src/core/cnc/cnc_types.h
    src/core/cnc/macro_manager.h
    src/core/cnc/macro_manager.cpp
  </files>
  <action>
**M6 tool change detection (EXT-10):**

When streaming a G-code program, if a line contains M6 (tool change), the controller should pause and notify the operator to acknowledge before continuing.

1. In cnc_types.h, add a tool change callback to CncCallbacks:
```cpp
std::function<void(int toolNumber)> onToolChange; // M6 detected during streaming
```

2. In cnc_controller.h, add:
```cpp
std::atomic<bool> m_toolChangePending{false}; // M6 pause waiting for ack
```

Add public method:
```cpp
void acknowledgeToolChange(); // Resume after M6 pause
```

3. In cnc_controller.cpp, modify `sendNextLines()` to detect M6 in lines before sending them:

```cpp
// In sendNextLines(), before sending a line, check for M6:
void CncController::sendNextLines() {
    std::lock_guard<std::mutex> lock(m_streamMutex);

    // If tool change pending, don't send more lines
    if (m_toolChangePending.load()) return;

    while (m_sendIndex < static_cast<int>(m_program.size()) &&
           m_bufferUsed + static_cast<int>(m_program[m_sendIndex].size()) + 1 <= cnc::RX_BUFFER_SIZE) {

        const std::string& line = m_program[m_sendIndex];

        // Check for M6 tool change (case-insensitive)
        // Parse: M6, M06, or T followed by M6
        // Simple check: look for M6 or M06 as standalone command
        std::string upper = line;
        for (auto& c : upper) c = static_cast<char>(std::toupper(c));

        // Strip comments
        auto commentPos = upper.find('(');
        if (commentPos != std::string::npos) upper = upper.substr(0, commentPos);
        commentPos = upper.find(';');
        if (commentPos != std::string::npos) upper = upper.substr(0, commentPos);

        bool hasM6 = (upper.find("M6") != std::string::npos || upper.find("M06") != std::string::npos);
        // Exclude M60+ (M60, M61, etc.)
        if (hasM6) {
            auto pos = upper.find("M6");
            if (pos == std::string::npos) pos = upper.find("M06");
            // Check it's M6 or M06, not M60+
            size_t afterM6 = pos + (upper[pos+1] == '0' ? 3 : 2);
            if (afterM6 < upper.size() && std::isdigit(upper[afterM6])) {
                hasM6 = false; // It's M60+ not M6
            }
        }

        if (hasM6) {
            // Parse tool number from T word if present
            int toolNum = 0;
            auto tPos = upper.find('T');
            if (tPos != std::string::npos) {
                toolNum = std::atoi(upper.c_str() + tPos + 1);
            }

            // Set pause flag and notify
            m_toolChangePending.store(true);
            if (m_callbacks.onToolChange) {
                m_mtq->post([this, toolNum]() {
                    m_callbacks.onToolChange(toolNum);
                });
            }
            return; // Don't send the M6 line yet — wait for ack
        }

        // Normal line sending (existing code)
        // ... (send the line, update m_bufferUsed, m_sentLengths, m_sendIndex)
    }
}
```

**IMPORTANT:** The M6 detection must happen BEFORE the line is sent to GRBL. The pause happens at the sender level (the line is held back). When the operator acknowledges, the M6 line is skipped (since GRBL doesn't implement M6 itself — it's handled by the sender), and streaming resumes.

4. Implement acknowledgeToolChange():
```cpp
void CncController::acknowledgeToolChange() {
    m_toolChangePending.store(false);
    // The next call to sendNextLines() in the IO loop will continue
}
```

5. The UI wiring for the tool change notification should happen in application.cpp. Add a note/comment: "Wire onToolChange callback to show a modal dialog with tool number and Continue/Abort buttons. Call acknowledgeToolChange() on Continue."

Since we don't modify application.cpp in this plan, the callback structure is ready. The cnc_safety_panel or gcode_panel can wire this. Add the callback field and the controller logic here — UI integration will be handled by the executor checking application.cpp wiring patterns.

Actually, let's add the tool change display to CncSafetyPanel since it already has the safety/operator notification role. But CncSafetyPanel is modified in plan 03. Instead, add it to CncJobPanel (the streaming job panel) — but that file isn't in our files_modified list.

**Better approach:** Keep the M6 detection purely in cnc_controller.cpp. The callback notifies whoever is wired. Add the callback field to CncCallbacks, the detection logic and acknowledgeToolChange() method. Then add a TODO comment that application.cpp must wire onToolChange to display a dialog.

**M98 nested macro expansion (EXT-13):**

M98 Pxxxx calls a sub-program by number. In our context, Pxxxx maps to a macro with id==xxxx. The expansion is done sender-side before sending to GRBL.

1. In macro_manager.h, add:
```cpp
// Expand M98 references in parsed lines, replacing M98 Pxxxx with the referenced macro's lines.
// Returns expanded lines. Throws std::runtime_error if recursion exceeds maxDepth.
std::vector<std::string> expandLines(const std::vector<std::string>& lines, int maxDepth = 16) const;

static constexpr int MAX_NEST_DEPTH = 16;
```

2. In macro_manager.cpp, implement expandLines():
```cpp
std::vector<std::string> MacroManager::expandLines(const std::vector<std::string>& lines, int maxDepth) const {
    return expandLinesRecursive(lines, 0, maxDepth);
}

// Private helper:
std::vector<std::string> MacroManager::expandLinesRecursive(
    const std::vector<std::string>& lines, int depth, int maxDepth) const
{
    if (depth > maxDepth) {
        throw std::runtime_error("M98 recursion depth exceeded (max " + std::to_string(maxDepth) + ")");
    }

    std::vector<std::string> result;
    result.reserve(lines.size());

    for (const auto& line : lines) {
        // Check for M98 Pxxxx
        std::string upper = line;
        for (auto& c : upper) c = static_cast<char>(std::toupper(c));

        // Strip comments
        auto commentPos = upper.find(';');
        if (commentPos != std::string::npos) upper = upper.substr(0, commentPos);
        commentPos = upper.find('(');
        if (commentPos != std::string::npos) upper = upper.substr(0, commentPos);

        auto m98Pos = upper.find("M98");
        if (m98Pos != std::string::npos) {
            // Find P parameter
            auto pPos = upper.find('P', m98Pos + 3);
            if (pPos != std::string::npos) {
                int subId = std::atoi(upper.c_str() + pPos + 1);
                if (subId > 0) {
                    try {
                        Macro sub = getById(subId);
                        auto subLines = parseLines(sub);
                        auto expanded = expandLinesRecursive(subLines, depth + 1, maxDepth);
                        result.insert(result.end(), expanded.begin(), expanded.end());
                        continue; // M98 line replaced by sub-program lines
                    } catch (const std::exception& e) {
                        // Sub-program not found — keep original line and add error comment
                        result.push_back("; ERROR: M98 P" + std::to_string(subId) + " — " + e.what());
                        result.push_back(line);
                        continue;
                    }
                }
            }
        }

        result.push_back(line);
    }

    return result;
}
```

3. In macro_manager.h, add private declaration:
```cpp
std::vector<std::string> expandLinesRecursive(
    const std::vector<std::string>& lines, int depth, int maxDepth) const;
```

4. Update the macro execution path: In CncMacroPanel::executeMacro(), the parsed lines should go through expandLines() before being sent. Since CncMacroPanel is NOT in our files_modified, add a TODO comment in macro_manager.h:
```cpp
// NOTE: Callers should call expandLines(parseLines(macro)) before sending to CncController
// to resolve M98 Pxxxx nested macro references.
```

The executor should also update CncMacroPanel::executeMacro() if that file is within reach, or it will be caught in verification.
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Tab key cycles jog step groups (Small->Medium->Large->Small)
- CncCallbacks has onToolChange callback for M6 detection
- CncController detects M6 during streaming and pauses, waiting for acknowledgeToolChange()
- MacroManager::expandLines() resolves M98 Pxxxx references with max 16 depth recursion guard
- Recursion overflow throws std::runtime_error with descriptive message
- Unreferenced M98 sub-programs produce inline error comments
  </done>
</task>

</tasks>

<verification>
- cmake --build build -j$(nproc) -- builds without errors
- ctest --test-dir build --output-on-failure -- all existing tests pass
</verification>

<success_criteria>
- Tab cycles through jog step groups without conflicts
- M6 tool change pauses streaming and waits for operator acknowledgment
- M98 expansion resolves nested macros recursively
- Recursion guard prevents infinite loops at depth 16
- Error reporting for missing sub-programs is clear
</success_criteria>

<output>
After completion, create `.planning/phases/12-extended/12-04-SUMMARY.md`
</output>
