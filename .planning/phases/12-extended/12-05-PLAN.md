---
phase: 12-extended
plan: 05
type: execute
wave: 2
depends_on: ["12-04"]
files_modified:
  - src/ui/panels/gcode_panel.h
  - src/ui/panels/gcode_panel.cpp
  - src/core/cnc/gamepad_input.h
  - src/core/cnc/gamepad_input.cpp
  - src/application.h
  - src/application.cpp
  - CMakeLists.txt
autonomous: true
requirements:
  - EXT-09
  - EXT-14

must_haves:
  truths:
    - "Toolpath visualization segments are color-coded by T-code (tool number) parsed from the G-code program"
    - "Gamepad input via SDL_GameController maps axes to jog movement and buttons to start/pause/stop/home actions"
  artifacts:
    - path: "src/ui/panels/gcode_panel.cpp"
      provides: "Per-tool color coding in toolpath visualization"
      contains: "toolColor"
    - path: "src/core/cnc/gamepad_input.h"
      provides: "GamepadInput class wrapping SDL_GameController"
      contains: "GamepadInput"
    - path: "src/core/cnc/gamepad_input.cpp"
      provides: "Gamepad polling, axis-to-jog mapping, button-to-action mapping"
      contains: "SDL_GameControllerOpen"
  key_links:
    - from: "src/ui/panels/gcode_panel.cpp"
      to: "src/core/gcode/gcode_parser.h"
      via: "T-code parsing from gcode::Command for per-tool colors"
      pattern: "toolNumber"
    - from: "src/core/cnc/gamepad_input.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "GamepadInput sends jog/start/stop/home commands to CncController"
      pattern: "sendCommand"
    - from: "src/application.cpp"
      to: "src/core/cnc/gamepad_input.h"
      via: "Application creates and polls GamepadInput each frame"
      pattern: "GamepadInput"
---

<objective>
Add per-tool color coding to toolpath visualization and gamepad input for CNC control.

Purpose: Visual tool differentiation helps operators identify tool paths in multi-tool jobs. Gamepad support provides a physical jogging interface that many CNC operators prefer.
Output: Color-coded toolpath segments by T-code in G-code panel, new GamepadInput class for SDL_GameController integration.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/ui/panels/gcode_panel.h
@src/ui/panels/gcode_panel.cpp
@src/core/cnc/cnc_controller.h
@src/application.h
@src/application.cpp
@CMakeLists.txt

<interfaces>
From src/ui/panels/gcode_panel.h:
```cpp
class GCodePanel : public Panel {
    gcode::Program m_program;

    // Path geometry — single VBO with grouped segments
    GLuint m_pathVAO = 0, m_pathVBO = 0;
    u32 m_rapidStart, m_rapidCount;
    u32 m_cutStart, m_cutCount;
    u32 m_plungeStart, m_plungeCount;
    u32 m_retractStart, m_retractCount;

    void buildPathGeometry(); // Builds VBO from parsed program
    // Currently groups by move type (rapid/cut/plunge/retract)
    // Each vertex has position + color
};

// gcode::Command contains:
// int lineNumber, MoveType type, Vec3 start, Vec3 end
// Tool number tracking would come from parsing T-codes during analysis
```

From src/core/gcode/gcode_parser.h:
```cpp
struct Command {
    MoveType type; // Rapid, Linear, Arc
    Vec3 start, end;
    float feedRate;
    int lineNumber;
    // Tool number may not be tracked yet — check
};

struct Program {
    std::vector<Command> commands;
};
```

From SDL2 (already linked):
```cpp
// SDL_GameController API (part of SDL2, already a project dependency)
SDL_GameController* SDL_GameControllerOpen(int joystick_index);
void SDL_GameControllerClose(SDL_GameController*);
Sint16 SDL_GameControllerGetAxis(SDL_GameController*, SDL_GameControllerAxis);
Uint8 SDL_GameControllerGetButton(SDL_GameController*, SDL_GameControllerButton);
int SDL_NumJoysticks();
SDL_bool SDL_IsGameController(int joystick_index);
```

From src/application.h:
```cpp
class Application {
    void run(); // Main loop
    void update(); // Called each frame
    // CNC controller and panel pointers available
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Per-tool color coding in toolpath visualization</name>
  <files>
    src/ui/panels/gcode_panel.h
    src/ui/panels/gcode_panel.cpp
  </files>
  <action>
**Per-tool color coding (EXT-09):**

Track the active tool number during G-code analysis and assign colors to each tool.

1. First, check if gcode::Command already has a toolNumber field. Read `src/core/gcode/gcode_parser.h` and `gcode_analyzer.h` to determine the current state.

If Command does NOT have a toolNumber:
- Add `int toolNumber = 0;` to the Command struct in gcode_parser.h
- In the parser, track Txx commands and apply the tool number to subsequent Commands

If Command already has toolNumber, skip this.

2. In gcode_panel.h, add a color palette for tools:
```cpp
// Tool color palette (up to 8 tools, wraps for more)
static constexpr int NUM_TOOL_COLORS = 8;
static Vec3 toolColors(int toolNum) {
    // Return distinct color for each tool number
    static const Vec3 palette[] = {
        {0.2f, 0.6f, 1.0f},  // T1: Blue
        {1.0f, 0.3f, 0.3f},  // T2: Red
        {0.3f, 0.9f, 0.3f},  // T3: Green
        {1.0f, 0.7f, 0.1f},  // T4: Orange
        {0.8f, 0.3f, 0.9f},  // T5: Purple
        {0.1f, 0.9f, 0.9f},  // T6: Cyan
        {0.9f, 0.9f, 0.2f},  // T7: Yellow
        {1.0f, 0.5f, 0.7f},  // T8: Pink
    };
    int idx = (toolNum > 0 ? toolNum - 1 : 0) % NUM_TOOL_COLORS;
    return palette[idx];
}

// Track whether tool coloring is enabled
bool m_colorByTool = false;
```

3. In buildPathGeometry(), when constructing the vertex buffer, use the tool number to assign vertex colors when m_colorByTool is true:

```cpp
// Current code assigns colors by move type:
// Rapid = gray, Cut = green, Plunge = blue, Retract = light blue
// When m_colorByTool is enabled, override cut/plunge/retract colors with tool color

for (const auto& cmd : m_program.commands) {
    Vec3 color;
    if (m_colorByTool && cmd.toolNumber > 0) {
        color = toolColors(cmd.toolNumber);
    } else {
        // Existing color logic by move type
        switch (cmd.type) {
        case MoveType::Rapid: color = Vec3{0.5f, 0.5f, 0.5f}; break;
        case MoveType::Linear:
            // ... existing plunge/retract/cut detection
            break;
        }
    }
    // Add vertices with this color
}
```

4. Add a "Color by Tool" checkbox in the toolbar area of the G-code panel:
```cpp
// In renderToolbar():
ImGui::SameLine();
if (ImGui::Checkbox("Color by Tool", &m_colorByTool)) {
    m_pathDirty = true; // Rebuild geometry with new colors
}
```

5. Rebuild path geometry when the toggle changes (m_pathDirty flag triggers rebuild).

**IMPORTANT:** Read the existing buildPathGeometry() to understand the exact vertex format (position + color? position + normal + color?). Match the existing vertex layout. The color override should happen at the point where vertex colors are assigned, not at the shader level.

If the existing code doesn't track tool numbers in commands, the simplest approach is to scan the raw G-code lines for T-codes during buildPathGeometry() and maintain a running tool number:

```cpp
// Alternative if Command doesn't have toolNumber:
int currentTool = 0;
for (size_t i = 0; i < m_program.commands.size(); ++i) {
    // Check if this line has a T-code
    if (i < rawLines.size()) {
        std::string upper = rawLines[i];
        auto tPos = upper.find('T');
        if (tPos != std::string::npos && tPos + 1 < upper.size() && std::isdigit(upper[tPos+1])) {
            currentTool = std::atoi(upper.c_str() + tPos + 1);
        }
    }
    // Use currentTool for color
}
```
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Toolpath segments are color-coded by T-code when "Color by Tool" is enabled
- Each tool number gets a distinct color from an 8-color palette
- Color toggle triggers geometry rebuild
- Rapid moves remain gray regardless of tool coloring mode
  </done>
</task>

<task type="auto">
  <name>Task 2: Gamepad input via SDL_GameController for CNC jog and actions</name>
  <files>
    src/core/cnc/gamepad_input.h
    src/core/cnc/gamepad_input.cpp
    src/application.h
    src/application.cpp
    CMakeLists.txt
  </files>
  <action>
**GamepadInput class (EXT-14):**

Create a new GamepadInput class that polls SDL_GameController state each frame and maps axes/buttons to CNC actions.

1. Create src/core/cnc/gamepad_input.h:
```cpp
#pragma once

#include <string>

struct SDL_GameController; // Forward declaration

namespace dw {

class CncController;

// Maps gamepad axes to jog movement and buttons to CNC actions.
// Polls SDL_GameController state each frame from the main loop.
class GamepadInput {
  public:
    GamepadInput();
    ~GamepadInput();

    GamepadInput(const GamepadInput&) = delete;
    GamepadInput& operator=(const GamepadInput&) = delete;

    // Set the CNC controller to send commands to
    void setCncController(CncController* cnc) { m_cnc = cnc; }

    // Poll gamepad state and send commands. Call once per frame.
    void update(float dt);

    // Check if a gamepad is connected
    bool isConnected() const { return m_controller != nullptr; }
    std::string controllerName() const;

    // Enable/disable gamepad input
    void setEnabled(bool enabled) { m_enabled = enabled; }
    bool isEnabled() const { return m_enabled; }

  private:
    void tryOpen();
    void close();
    void processAxes(float dt);
    void processButtons();

    SDL_GameController* m_controller = nullptr;
    CncController* m_cnc = nullptr;
    bool m_enabled = false;
    int m_deviceIndex = -1;

    // Axis state for jog (deadzone filtered)
    float m_axisX = 0.0f;     // Left stick X -> X jog
    float m_axisY = 0.0f;     // Left stick Y -> Y jog
    float m_axisZ = 0.0f;     // Right stick Y -> Z jog
    float m_jogTimer = 0.0f;  // Accumulator for jog command rate limiting

    // Button debounce (prevent repeated triggers)
    bool m_prevStart = false;
    bool m_prevBack = false;
    bool m_prevA = false;
    bool m_prevB = false;
    bool m_prevHome = false;

    // Tuning
    static constexpr float DEADZONE = 0.15f;        // 15% deadzone
    static constexpr float JOG_INTERVAL = 0.1f;     // Send jog every 100ms
    static constexpr float JOG_FEED_SLOW = 500.0f;  // mm/min at low stick deflection
    static constexpr float JOG_FEED_FAST = 3000.0f;  // mm/min at full stick deflection
    static constexpr float JOG_DISTANCE = 100.0f;   // mm per jog command (will be cancelled)
};

} // namespace dw
```

2. Create src/core/cnc/gamepad_input.cpp:
```cpp
#include "gamepad_input.h"
#include "cnc_controller.h"

#include <SDL2/SDL.h>
#include <cmath>
#include <cstdio>

#include "../utils/log.h"

namespace dw {

GamepadInput::GamepadInput() {
    // SDL_Init(SDL_INIT_GAMECONTROLLER) should already be called by Application
    tryOpen();
}

GamepadInput::~GamepadInput() {
    close();
}

void GamepadInput::tryOpen() {
    if (m_controller) return;

    int numJoysticks = SDL_NumJoysticks();
    for (int i = 0; i < numJoysticks; ++i) {
        if (SDL_IsGameController(i)) {
            m_controller = SDL_GameControllerOpen(i);
            if (m_controller) {
                m_deviceIndex = i;
                log::infof("GamepadInput", "Opened controller: %s",
                           SDL_GameControllerName(m_controller));
                return;
            }
        }
    }
}

void GamepadInput::close() {
    if (m_controller) {
        SDL_GameControllerClose(m_controller);
        m_controller = nullptr;
        m_deviceIndex = -1;
    }
}

std::string GamepadInput::controllerName() const {
    if (!m_controller) return "None";
    const char* name = SDL_GameControllerName(m_controller);
    return name ? name : "Unknown";
}

void GamepadInput::update(float dt) {
    if (!m_enabled) return;

    // Try to open if not connected
    if (!m_controller) {
        tryOpen();
        if (!m_controller) return;
    }

    // Check if still attached
    if (!SDL_GameControllerGetAttached(m_controller)) {
        log::info("GamepadInput", "Controller disconnected");
        close();
        return;
    }

    processAxes(dt);
    processButtons();
}

void GamepadInput::processAxes(float dt) {
    if (!m_cnc || !m_cnc->isConnected()) return;

    // Read axes (range: -32768 to 32767)
    float lx = SDL_GameControllerGetAxis(m_controller, SDL_CONTROLLER_AXIS_LEFTX) / 32767.0f;
    float ly = SDL_GameControllerGetAxis(m_controller, SDL_CONTROLLER_AXIS_LEFTY) / 32767.0f;
    float ry = SDL_GameControllerGetAxis(m_controller, SDL_CONTROLLER_AXIS_RIGHTY) / 32767.0f;

    // Apply deadzone
    auto applyDeadzone = [](float v) -> float {
        if (std::fabs(v) < DEADZONE) return 0.0f;
        float sign = v > 0 ? 1.0f : -1.0f;
        return sign * (std::fabs(v) - DEADZONE) / (1.0f - DEADZONE);
    };

    m_axisX = applyDeadzone(lx);
    m_axisY = applyDeadzone(-ly); // Invert Y (stick up = positive Y)
    m_axisZ = applyDeadzone(-ry); // Invert Y (stick up = Z+)

    // Rate-limited jog commands
    m_jogTimer += dt;
    if (m_jogTimer < JOG_INTERVAL) return;
    m_jogTimer = 0.0f;

    bool hasMotion = (m_axisX != 0.0f || m_axisY != 0.0f || m_axisZ != 0.0f);
    if (!hasMotion) return;

    // Scale feed rate by stick magnitude
    float magnitude = std::sqrt(m_axisX * m_axisX + m_axisY * m_axisY);
    if (m_axisZ != 0.0f) magnitude = std::max(magnitude, std::fabs(m_axisZ));
    float feed = JOG_FEED_SLOW + (JOG_FEED_FAST - JOG_FEED_SLOW) * std::min(magnitude, 1.0f);

    // Build jog command
    char cmd[128];
    std::snprintf(cmd, sizeof(cmd), "$J=G91 G21 X%.3f Y%.3f Z%.3f F%.0f",
                  static_cast<double>(m_axisX * JOG_DISTANCE * JOG_INTERVAL),
                  static_cast<double>(m_axisY * JOG_DISTANCE * JOG_INTERVAL),
                  static_cast<double>(m_axisZ * JOG_DISTANCE * JOG_INTERVAL),
                  static_cast<double>(feed));
    m_cnc->sendCommand(cmd);
}

void GamepadInput::processButtons() {
    if (!m_cnc) return;

    // Button mapping:
    // A = Cycle Start / Resume
    // B = Feed Hold / Pause
    // Start = Start job (if wired)
    // Back/Select = Stop / Abort
    // Home/Guide = Home ($H)

    bool a = SDL_GameControllerGetButton(m_controller, SDL_CONTROLLER_BUTTON_A);
    bool b = SDL_GameControllerGetButton(m_controller, SDL_CONTROLLER_BUTTON_B);
    bool start = SDL_GameControllerGetButton(m_controller, SDL_CONTROLLER_BUTTON_START);
    bool back = SDL_GameControllerGetButton(m_controller, SDL_CONTROLLER_BUTTON_BACK);
    bool home = SDL_GameControllerGetButton(m_controller, SDL_CONTROLLER_BUTTON_GUIDE);

    // Rising edge detection (button pressed this frame, not last)
    if (a && !m_prevA) {
        m_cnc->cycleStart();
    }
    if (b && !m_prevB) {
        m_cnc->feedHold();
    }
    if (back && !m_prevBack) {
        m_cnc->softReset();
    }
    if (home && !m_prevHome && m_cnc->isConnected()) {
        m_cnc->sendCommand("$H");
    }

    m_prevA = a;
    m_prevB = b;
    m_prevStart = start;
    m_prevBack = back;
    m_prevHome = home;
}

} // namespace dw
```

3. Add the new files to CMakeLists.txt. Find the source file list for digital_workshop target and add:
```
src/core/cnc/gamepad_input.h
src/core/cnc/gamepad_input.cpp
```

4. In application.h, add:
```cpp
#include "core/cnc/gamepad_input.h"
// ...
std::unique_ptr<GamepadInput> m_gamepadInput;
```

5. In application.cpp:
- In init (after CncController is created): Create GamepadInput and wire it:
```cpp
m_gamepadInput = std::make_unique<GamepadInput>();
m_gamepadInput->setCncController(m_cncController.get());
```

- Ensure SDL_INIT_GAMECONTROLLER is included in SDL_Init flags. Check the existing SDL_Init call — it likely uses SDL_INIT_VIDEO. Add SDL_INIT_GAMECONTROLLER:
```cpp
SDL_Init(SDL_INIT_VIDEO | SDL_INIT_GAMECONTROLLER);
```

- In the update loop, call:
```cpp
m_gamepadInput->update(deltaTime);
```

- In shutdown, the unique_ptr handles cleanup.

**SDL_Init check:** Read the existing SDL_Init call in application.cpp to confirm what flags are used. SDL_INIT_GAMECONTROLLER is needed for game controller enumeration and event processing. If SDL_INIT_JOYSTICK is already set, SDL_INIT_GAMECONTROLLER implicitly includes it.

**IMPORTANT:** Check if application.h already includes too many headers. If so, use a forward declaration in the header and include in the .cpp file:
```cpp
// In application.h:
class GamepadInput; // Forward declaration
std::unique_ptr<GamepadInput> m_gamepadInput;
```
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Toolpath segments colored by tool number when "Color by Tool" toggle is enabled
- GamepadInput class wraps SDL_GameController with deadzone, axis-to-jog, button-to-action mapping
- Left stick controls X/Y jog, right stick Y controls Z jog
- A=Resume, B=Pause, Back=Stop, Guide=Home button mappings
- Gamepad auto-detected on connection, polls each frame
- Application creates and updates GamepadInput in main loop
  </done>
</task>

</tasks>

<verification>
- cmake --build build -j$(nproc) -- builds without errors
- ctest --test-dir build --output-on-failure -- all existing tests pass
</verification>

<success_criteria>
- "Color by Tool" checkbox toggles per-tool coloring in toolpath view
- Each tool number gets a visually distinct color
- Gamepad axes produce smooth jog movement with deadzone filtering
- Gamepad buttons trigger cycle start, feed hold, stop, and home
- Gamepad hot-plugging handled (auto-detect on connection, clean up on disconnect)
</success_criteria>

<output>
After completion, create `.planning/phases/12-extended/12-05-SUMMARY.md`
</output>
