# Plan 16-01: Tool Database Query and Selection Logic

**Phase**: 16 — Tool Recommendation
**Requirements**: DC-09, DC-10, DC-11

## Overview

Query the Vectric .vtdb tool database to recommend finishing tools based on model analysis results. V-bits are preferred when taper geometry allows access to all features. Ball nose or tapered ball nose is recommended when minimum feature radius exceeds their tip radius.

## New Files

### `src/core/carve/tool_recommender.h` (~100 lines)

```cpp
namespace dw {
namespace carve {

enum class ToolRole {
    Finishing,   // Primary carving pass
    Clearing     // Island clearing pass
};

struct ToolCandidate {
    VtdbToolGeometry geometry;
    VtdbCuttingData cuttingData;
    ToolRole role = ToolRole::Finishing;
    f32 score = 0.0f;              // Higher = better match
    std::string reasoning;          // Human-readable explanation
};

struct RecommendationInput {
    CurvatureResult curvature;
    IslandResult islands;
    f32 modelDepthMm = 0.0f;
    f32 stockThicknessMm = 0.0f;
};

struct RecommendationResult {
    std::vector<ToolCandidate> finishing;  // Ranked finishing tool options
    std::vector<ToolCandidate> clearing;   // Ranked clearing tool options (empty if no islands)
    bool needsClearing = false;
};

class ToolRecommender {
public:
    // Set tool database to query from
    void setToolDatabase(ToolDatabase* db);

    // Compute recommendations
    RecommendationResult recommend(const RecommendationInput& input);

private:
    ToolDatabase* m_db = nullptr;

    f32 scoreVBit(const VtdbToolGeometry& geom,
                  const RecommendationInput& input);
    f32 scoreBallNose(const VtdbToolGeometry& geom,
                      const RecommendationInput& input);
    f32 scoreTBN(const VtdbToolGeometry& geom,
                 const RecommendationInput& input);
    std::string explainScore(const VtdbToolGeometry& geom,
                             f32 score, ToolRole role);
};

} // namespace carve
} // namespace dw
```

### `src/core/carve/tool_recommender.cpp` (~250 lines)

**recommend()**:
1. Query all tool geometries from database: `m_db->allToolGeometries()`
2. For each tool, compute score based on type:

**scoreVBit()** (~30 lines):
- Base score: high (V-bits preferred for 2.5D)
- Check included_angle vs model geometry:
  - Tool's taper slope: `tan(included_angle / 2)`
  - If taper can reach all concave features without burial: +bonus
  - If islands exist that this V-bit can't reach: -penalty per island
- Depth check: tool flute_length >= model depth, else score = 0

**scoreBallNose()** (~30 lines):
- Check tip_radius vs minimum feature radius:
  - `tip_radius <= minConcaveRadius`: eligible
  - Closer match (tip_radius approaches minRadius): higher score
  - Over-sized tip: score = 0
- Depth check: flute_length >= model depth
- Bonus: if no islands detected (no clearing needed)

**scoreTBN()** (~30 lines):
- Similar to ball nose but with taper benefit:
  - Tapered shaft reduces contact area on slopes
  - Score between V-bit and ball nose
  - Check tip_radius eligibility same as ball nose

3. Sort each category by score descending, take top 3-5
4. Set `needsClearing = !islands.empty()`

**explainScore()** (~30 lines):
- Generate human-readable string:
  - "6.2deg V-bit — taper reaches all features, no clearing needed"
  - "3mm ball nose — tip radius (1.5mm) fits 2.1mm minimum feature"
  - "Not recommended — tip radius (3mm) exceeds minimum feature radius (2.1mm)"

### Tests

`src/core/carve/tool_recommender_test.cpp` (~150 lines):

- `TEST(ToolRecommender, VBitPreferredNoIslands)` — V-bit scores highest when no islands
- `TEST(ToolRecommender, BallNoseWhenRadiusFits)` — ball nose recommended when radius matches
- `TEST(ToolRecommender, OversizedToolRejected)` — tool with tip > min radius scores 0
- `TEST(ToolRecommender, NeedsClearingWithIslands)` — needsClearing true when islands present
- `TEST(ToolRecommender, DepthLimitRejectsShortTools)` — tools with insufficient flute length rejected
- `TEST(ToolRecommender, ReasoningStrings)` — explainScore produces valid descriptions

## Coding Standards Compliance

- All files within size limits
- ToolRecommender has 4 public methods (well within 10-15 limit)
- Score functions each under 30 lines
- No hardcoded tool preferences — scoring is algorithmic from geometry
- Result structs hold data, recommender holds behavior
