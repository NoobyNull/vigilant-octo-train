# Plan 14-01: Heightmap Data Structure and Ray-Mesh Intersection

**Phase**: 14 — Heightmap Engine
**Requirements**: DC-01, DC-04

## Overview

Create a `Heightmap` class that rasterizes an STL mesh into a 2D grid of Z-height values using top-down ray-mesh intersection. The heightmap is the foundation for all subsequent analysis and toolpath generation.

## New Files

### `src/core/carve/heightmap.h` (~120 lines)

```cpp
namespace dw {
namespace carve {

struct HeightmapConfig {
    f32 resolutionMm = 0.1f;    // Grid spacing in mm
    f32 defaultZ = 0.0f;        // Z value for cells with no intersection
};

class Heightmap {
public:
    Heightmap() = default;

    // Build from mesh triangles (must be called from worker thread)
    // progress callback: [0.0, 1.0] for UI updates
    void build(const std::vector<Triangle>& triangles,
               const Vec3& boundsMin, const Vec3& boundsMax,
               const HeightmapConfig& config,
               std::function<void(f32)> progress = nullptr);

    // Accessors
    f32 at(int col, int row) const;     // Z value at grid position
    f32 atMm(f32 x, f32 y) const;      // Z value at world position (bilinear interp)
    int cols() const;
    int rows() const;
    f32 resolution() const;
    Vec3 boundsMin() const;
    Vec3 boundsMax() const;
    bool empty() const;

    // Statistics
    f32 minZ() const;
    f32 maxZ() const;

private:
    std::vector<f32> m_grid;            // Row-major [row * m_cols + col]
    int m_cols = 0;
    int m_rows = 0;
    f32 m_resolution = 0.1f;
    Vec3 m_boundsMin;
    Vec3 m_boundsMax;
    f32 m_minZ = 0.0f;
    f32 m_maxZ = 0.0f;
};

} // namespace carve
} // namespace dw
```

### `src/core/carve/heightmap.cpp` (~250 lines)

**build()** implementation:
1. Calculate grid dimensions from bounds and resolution: `cols = ceil((maxX - minX) / res)`, `rows = ceil((maxY - minY) / res)`
2. Allocate grid, fill with `defaultZ`
3. For each grid cell (col, row):
   - Compute world XY: `x = minX + col * res`, `y = minY + row * res`
   - Cast ray downward from (x, y, +INF) in -Z direction
   - Test against all triangles using Moller-Trumbore ray-triangle intersection
   - Store maximum Z intersection value (top surface)
   - Report progress every N rows
4. Compute min/max Z statistics

**Ray-triangle intersection** (Moller-Trumbore):
- Standard algorithm, ~20 lines
- Returns hit distance along ray, or -1 if no hit
- Only test triangles whose XY bounding box overlaps the ray XY position (spatial skip)

**Spatial acceleration** (simple grid binning):
- Pre-bin triangles into a 2D grid of buckets (coarser than heightmap grid)
- Each heightmap cell only tests triangles in its corresponding bucket
- Reduces O(cells * triangles) to approximately O(cells * local_triangles)

**atMm()** bilinear interpolation:
- Find 4 nearest grid cells
- Interpolate Z value based on fractional XY position
- Clamp to grid bounds

### `src/core/carve/heightmap_test.cpp` (~150 lines)

Tests:
- `TEST(Heightmap, EmptyMesh)` — empty triangle list produces empty heightmap
- `TEST(Heightmap, FlatPlane)` — single quad at Z=5 produces uniform heightmap of 5.0
- `TEST(Heightmap, SimplePeak)` — pyramid mesh has peak at center, slopes to edges
- `TEST(Heightmap, Resolution)` — higher resolution produces more grid cells
- `TEST(Heightmap, BilinearInterp)` — atMm() interpolates between grid cells
- `TEST(Heightmap, ProgressCallback)` — progress callback is invoked with increasing values

## CMake

Add `src/core/carve/heightmap.cpp` to `CMakeLists.txt` source list.
Add test file to test target.

## Coding Standards Compliance

- All files within size limits (heightmap.h ~120, heightmap.cpp ~250)
- Functions under 50 lines (build() delegates to helpers: `buildGrid`, `binTriangles`, `castRay`)
- camelCase methods, m_ prefix private members
- No hardcoded values (resolution from config, grid dims calculated)
- Background thread via std::function progress callback (caller manages threading)
