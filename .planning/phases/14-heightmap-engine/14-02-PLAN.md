# Plan 14-02: Model Fitting, Bounds Checking, and Background Computation

**Phase**: 14 — Heightmap Engine
**Requirements**: DC-02, DC-03, DC-04

## Overview

Create a `ModelFitter` that manages the relationship between an STL model, the material stock, and the machine work area. Provides uniform scaling, independent Z depth, X/Y positioning, and bounds validation. Integrates with the heightmap builder to run computation on a background thread.

## New Files

### `src/core/carve/model_fitter.h` (~100 lines)

```cpp
namespace dw {
namespace carve {

struct StockDimensions {
    f32 width = 0.0f;   // X extent in mm
    f32 height = 0.0f;  // Y extent in mm
    f32 thickness = 0.0f; // Z extent in mm
};

struct FitParams {
    f32 scale = 1.0f;          // Uniform XY scale (locked aspect)
    f32 depthMm = 0.0f;        // Z depth from top surface (0 = auto from model)
    f32 offsetX = 0.0f;        // X offset on stock (mm)
    f32 offsetY = 0.0f;        // Y offset on stock (mm)
};

struct FitResult {
    Vec3 modelMin;              // Transformed model bounds min
    Vec3 modelMax;              // Transformed model bounds max
    bool fitsStock = false;     // Model fits within stock dimensions
    bool fitsMachine = false;   // Model fits within machine travel
    std::string warning;        // Human-readable warning if !fits
};

class ModelFitter {
public:
    // Set the source model bounds (from loaded STL)
    void setModelBounds(const Vec3& min, const Vec3& max);

    // Set constraints
    void setStock(const StockDimensions& stock);
    void setMachineTravel(f32 travelX, f32 travelY, f32 travelZ);

    // Compute fitted bounds
    FitResult fit(const FitParams& params) const;

    // Auto-fit: compute scale to fill stock width/height
    f32 autoScale() const;

    // Auto-depth: model's full Z range
    f32 autoDepth() const;

    // Transform a point from model space to fitted space
    Vec3 transform(const Vec3& modelPoint,
                   const FitParams& params) const;

private:
    Vec3 m_modelMin, m_modelMax;
    StockDimensions m_stock;
    f32 m_travelX = 0, m_travelY = 0, m_travelZ = 0;
};

} // namespace carve
} // namespace dw
```

### `src/core/carve/model_fitter.cpp` (~120 lines)

**fit()**:
1. Compute model extents: `extX = (max.x - min.x) * scale`, `extY = (max.y - min.y) * scale`
2. Compute Z depth: use `depthMm` if non-zero, else model Z range * scale
3. Apply offset: `modelMin = {offsetX, offsetY, stockThickness - depth}`, `modelMax = {offsetX + extX, offsetY + extY, stockThickness}`
4. Check stock fit: `extX <= stock.width && extY <= stock.height && depth <= stock.thickness`
5. Check machine fit: `modelMax.x <= travelX && modelMax.y <= travelY && stockThickness <= travelZ`
6. Return FitResult with bounds and warnings

**autoScale()**:
- `min(stock.width / modelExtX, stock.height / modelExtY)` — fit to stock, maintaining aspect

### `src/core/carve/carve_job.h` (~80 lines)

Orchestrates heightmap generation on a background thread:

```cpp
namespace dw {
namespace carve {

enum class CarveJobState {
    Idle,
    Computing,
    Ready,
    Error
};

class CarveJob {
public:
    // Start heightmap generation (non-blocking)
    void startHeightmap(const std::vector<Triangle>& triangles,
                        const FitParams& fitParams,
                        const HeightmapConfig& hmConfig);

    // Poll state (call from main thread)
    CarveJobState state() const;
    f32 progress() const;          // [0.0, 1.0]
    const Heightmap& heightmap() const;
    std::string errorMessage() const;

    // Cancel in-progress computation
    void cancel();

private:
    std::atomic<CarveJobState> m_state{CarveJobState::Idle};
    std::atomic<f32> m_progress{0.0f};
    std::atomic<bool> m_cancelled{false};
    Heightmap m_heightmap;
    std::string m_error;
    std::future<void> m_future;
};

} // namespace carve
} // namespace dw
```

### `src/core/carve/carve_job.cpp` (~80 lines)

**startHeightmap()**:
1. Set state to Computing, progress to 0
2. Launch `std::async` with lambda:
   - Transform triangles using ModelFitter
   - Call `m_heightmap.build()` with progress callback that writes to `m_progress` atomic
   - Check `m_cancelled` in progress callback, throw if true
   - Set state to Ready on success, Error on exception

### Tests

`src/core/carve/model_fitter_test.cpp` (~120 lines):
- `TEST(ModelFitter, AutoScale)` — auto scale fits model to stock
- `TEST(ModelFitter, FitsStock)` — model within stock returns true
- `TEST(ModelFitter, ExceedsStock)` — oversized model returns warning
- `TEST(ModelFitter, MachineTravel)` — offset beyond machine travel warns
- `TEST(ModelFitter, UniformScale)` — X/Y scale locked, Z independent
- `TEST(ModelFitter, DepthControl)` — explicit depth overrides model Z

`src/core/carve/carve_job_test.cpp` (~60 lines):
- `TEST(CarveJob, ComputeSimpleMesh)` — flat plane produces ready state
- `TEST(CarveJob, CancelMidCompute)` — cancel sets state back to idle

## CMake

Add all new .cpp files to source list and test files to test target.

## Coding Standards Compliance

- All files within limits (largest is heightmap.cpp from 14-01 at ~250)
- Structs for config/results (no naked tuples or output params)
- Background thread uses std::async + atomics (no raw pthread)
- Progress reported via atomic<f32> polled from main thread
- No hardcoded values — all dimensions from params/config
