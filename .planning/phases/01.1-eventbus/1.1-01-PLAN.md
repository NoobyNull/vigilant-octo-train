---
phase: 01.1-eventbus
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/core/events/event_bus.h
  - src/core/events/event_bus.cpp
  - src/core/events/event_types.h
  - tests/test_event_bus.cpp
  - tests/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "A subsystem can subscribe to an event type and receive published events of that type"
    - "Multiple subscribers for the same event type all receive the published event"
    - "Weak reference subscribers are automatically cleaned up when owner is destroyed"
    - "Publishing an event with no subscribers does not crash"
    - "Event types are plain structs with owned data (no inheritance required)"
    - "Exception in one handler does not prevent other handlers from running"
  artifacts:
    - path: "src/core/events/event_bus.h"
      provides: "EventBus class with template subscribe/publish API"
      contains: "class EventBus"
    - path: "src/core/events/event_bus.cpp"
      provides: "Non-template implementation details"
      contains: "namespace dw"
    - path: "src/core/events/event_types.h"
      provides: "Common event struct definitions for subsystem communication"
      contains: "struct WorkspaceChanged"
    - path: "tests/test_event_bus.cpp"
      provides: "Unit tests for EventBus core API"
      contains: "TEST"
  key_links:
    - from: "src/core/events/event_bus.h"
      to: "std::type_index"
      via: "Template subscribe/publish maps event types to handler lists"
      pattern: "std::type_index"
    - from: "src/core/events/event_bus.h"
      to: "std::weak_ptr"
      via: "Handler storage uses weak_ptr for automatic lifetime management"
      pattern: "weak_ptr"
    - from: "tests/test_event_bus.cpp"
      to: "src/core/events/event_bus.h"
      via: "Tests exercise subscribe, publish, and cleanup APIs"
      pattern: "EventBus"
---

<objective>
Implement a type-safe, template-based EventBus using TDD (Red-Green-Refactor) with comprehensive unit tests covering subscribe, publish, weak reference cleanup, reentrancy safety, and exception isolation.

Purpose: The EventBus is the foundational communication mechanism for Phase 1. It enables decoupled subsystem interactions, replacing the tight callback coupling in Application.cpp. All future phases (god class decomposition, import pipeline notifications, workspace changes) depend on this working correctly.

Output: Working EventBus class with full test coverage, plus example event type definitions for future subsystem use.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-eventbus/1.1-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/TESTING.md
@src/core/types.h
@tests/CMakeLists.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED -- Create event_types.h, event_bus.h skeleton, and failing unit tests</name>
  <files>
    src/core/events/event_types.h
    src/core/events/event_bus.h
    src/core/events/event_bus.cpp
    tests/test_event_bus.cpp
    tests/CMakeLists.txt
  </files>
  <action>
**Step 1: Create directory `src/core/events/`.**

**Step 2: Create `src/core/events/event_types.h`** with example event structs. Follow project conventions (#pragma once, namespace dw, PascalCase structs). Define these event structs as plain data (no inheritance):

```cpp
struct WorkspaceChanged {
    int64_t newModelId;
    std::string modelName;  // Owns data, not string_view (Pitfall 2 from research)
};

struct ImportCompleted {
    int64_t modelId;
    std::string name;
};

struct ImportFailed {
    std::string filePath;
    std::string error;
};

struct ConfigFileChanged {};

struct ModelSelected {
    int64_t modelId;
};

struct ModelOpened {
    int64_t modelId;
};
```

**Step 3: Create `src/core/events/event_bus.h`** with the full EventBus class API as a SKELETON (declarations only, bodies can be empty/stub that compiles but does nothing useful). The API must include:

- `template<typename EventType, typename Handler> SubscriptionId subscribe(Handler&& handler)` -- Returns a `std::shared_ptr<void>` (the subscription token). Caller holds the shared_ptr; when it dies, the weak_ptr inside EventBus expires and handler is cleaned up. Internally: wrap handler in `std::shared_ptr<std::function<void(const EventType&)>>`, store a `std::weak_ptr<void>` in the handler list keyed by `std::type_index(typeid(EventType))`.
- `template<typename EventType> void publish(const EventType& event)` -- Look up handlers by type_index. Copy the handler vector before iteration (reentrancy safety per Pitfall 3). For each weak_ptr: lock, cast to concrete function type via static_pointer_cast, invoke. Erase expired entries. Wrap each invocation in try/catch (exception isolation per Open Question 3). Log errors but continue.
- Use `std::unordered_map<std::type_index, std::vector<std::weak_ptr<void>>>` for internal storage.
- Type alias: `using SubscriptionId = std::shared_ptr<void>;`
- No mutex (main-thread-only contract per research). Add a comment documenting this.

For the skeleton: provide MINIMAL stub implementations that COMPILE but produce WRONG results (e.g., subscribe stores nothing, publish does nothing). This ensures RED phase tests will compile but fail.

**Step 4: Create `src/core/events/event_bus.cpp`** with just the namespace and any non-template helpers. Most logic is template-based and lives in the header.

**Step 5: Create `tests/test_event_bus.cpp`** with these test cases:

```
TEST(EventBus, SubscribeAndReceive_SingleSubscriber)
  - Create EventBus, subscribe to WorkspaceChanged, publish one, assert handler called with correct data

TEST(EventBus, SubscribeAndReceive_MultipleSubscribers)
  - Subscribe two handlers to same event type, publish, assert both called

TEST(EventBus, SubscribeAndReceive_DifferentEventTypes)
  - Subscribe to WorkspaceChanged and ImportCompleted separately, publish each, verify only correct handler fires

TEST(EventBus, Publish_NoSubscribers_DoesNotCrash)
  - Create EventBus with no subscriptions, publish event, no crash

TEST(EventBus, WeakRefCleanup_ExpiredSubscriberRemoved)
  - Subscribe, let the SubscriptionId (shared_ptr) go out of scope, publish again, handler must NOT be called

TEST(EventBus, WeakRefCleanup_MixedAliveAndExpired)
  - Subscribe two handlers. Let one's SubscriptionId expire. Publish. Only the alive one fires.

TEST(EventBus, ReentrancySafety_SubscribeDuringPublish)
  - Handler subscribes a new handler to the SAME event type during publish. Must not crash or invalidate iterators. The new subscription may or may not fire for the current event (either is acceptable), but the next publish must include it.

TEST(EventBus, ExceptionIsolation_HandlerThrowDoesNotBlockOthers)
  - Subscribe two handlers. First throws std::runtime_error. Second must still be called.

TEST(EventBus, EmptyEvent_WorksWithNoFields)
  - Subscribe to ConfigFileChanged (empty struct), publish it, handler fires.

TEST(EventBus, SubscriptionId_KeepsHandlerAlive)
  - Store SubscriptionId in a variable. Publish multiple times. Handler called each time.
```

Write full test implementations using GoogleTest TEST() macros. Include event_bus.h and event_types.h. Use counters (int variables incremented in handlers) to verify invocation. Use EXPECT_EQ, ASSERT_TRUE per project conventions.

**Step 6: Update `tests/CMakeLists.txt`:**
- Add `test_event_bus.cpp` to DW_TEST_SOURCES (after the Tier 1 section, add a comment `# Tier 1 â€” EventBus`)
- Add `${CMAKE_SOURCE_DIR}/src/core/events/event_bus.cpp` to DW_TEST_DEPS

**Step 7: Build tests and verify they FAIL (RED phase):**
```bash
cmake --build build --target dw_tests 2>&1
./build/dw_tests --gtest_filter=EventBus.* 2>&1
```
Tests must COMPILE but FAIL (since EventBus skeleton does nothing). This confirms the RED phase.

**IMPORTANT:** Do NOT implement EventBus logic yet. The skeleton must compile but all behavioral tests must fail. Commit after confirming RED.

Commit message: `test(1.1-01): add failing tests for EventBus subscribe/publish/cleanup`
  </action>
  <verify>
Run: `cmake --build build --target dw_tests 2>&1` -- must compile successfully.
Run: `./build/dw_tests --gtest_filter=EventBus.* 2>&1` -- tests must compile and run, but FAIL (RED phase). At minimum SubscribeAndReceive_SingleSubscriber should fail because the stub does not actually dispatch events.
  </verify>
  <done>
All 10 EventBus tests compile and execute. At least 8 of 10 tests fail (the "no crash" tests may pass with stubs). RED phase confirmed. Committed.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN + REFACTOR -- Implement EventBus to pass all tests</name>
  <files>
    src/core/events/event_bus.h
    src/core/events/event_bus.cpp
  </files>
  <action>
**Step 1: Implement the full EventBus in `src/core/events/event_bus.h`.**

Replace the skeleton stubs with working template implementations. Key implementation details:

**subscribe():**
```cpp
template<typename EventType, typename Handler>
SubscriptionId subscribe(Handler&& handler) {
    auto handlerFunc = std::make_shared<std::function<void(const EventType&)>>(
        std::forward<Handler>(handler)
    );
    auto typeIndex = std::type_index(typeid(EventType));
    m_handlers[typeIndex].push_back(handlerFunc);
    return handlerFunc;  // Caller holds shared_ptr; EventBus holds weak_ptr
}
```

**publish():**
```cpp
template<typename EventType>
void publish(const EventType& event) {
    auto typeIndex = std::type_index(typeid(EventType));
    auto it = m_handlers.find(typeIndex);
    if (it == m_handlers.end()) return;

    // Copy handler list before iteration (reentrancy safety - Pitfall 3)
    auto handlersCopy = it->second;

    // Track indices to erase after iteration
    std::vector<size_t> expired;

    for (size_t i = 0; i < handlersCopy.size(); ++i) {
        auto locked = handlersCopy[i].lock();
        if (locked) {
            auto typedHandler = std::static_pointer_cast<
                std::function<void(const EventType&)>>(locked);
            try {
                (*typedHandler)(event);
            } catch (const std::exception& e) {
                dw::log::errorf("event_bus", "Handler exception: {}", e.what());
            } catch (...) {
                dw::log::error("event_bus", "Handler threw unknown exception");
            }
        } else {
            expired.push_back(i);
        }
    }

    // Clean up expired from the ORIGINAL list (not the copy)
    // Iterate in reverse to maintain index validity
    auto& originalList = it->second;
    for (auto rit = expired.rbegin(); rit != expired.rend(); ++rit) {
        if (*rit < originalList.size()) {
            originalList.erase(originalList.begin() + static_cast<ptrdiff_t>(*rit));
        }
    }
}
```

**IMPORTANT notes for implementation:**
- The internal map stores `std::weak_ptr<void>`. Subscribe stores a `std::shared_ptr<std::function<void(const EventType&)>>` but returns it as `std::shared_ptr<void>` (SubscriptionId). The weak_ptr stored in the map is created from this shared_ptr before it's type-erased.
- Actually, the simplest approach: store the `std::shared_ptr<void>` returned from subscribe as a weak_ptr. The subscribe method creates a `shared_ptr<function<void(const T&)>>`, pushes a `weak_ptr<void>` made from it into the map, and returns the shared_ptr (implicitly converted to shared_ptr<void> via SubscriptionId typedef).
- For the lazy cleanup approach: instead of tracking expired indices from the copy, do a simpler post-dispatch cleanup by erasing expired entries from the original list using erase-remove idiom:
  ```cpp
  auto& list = it->second;
  list.erase(
      std::remove_if(list.begin(), list.end(),
          [](const std::weak_ptr<void>& wp) { return wp.expired(); }),
      list.end()
  );
  ```
  Do this AFTER the dispatch loop on the copy completes.

- Use `#include <typeindex>`, `<any>` (if needed), `<functional>`, `<memory>`, `<unordered_map>`, `<vector>`, `<algorithm>`.
- Include `"core/utils/log.h"` for error logging.
- Follow project conventions: `#pragma once`, `namespace dw { ... } // namespace dw`, `m_` prefix for members, camelCase methods.

**Step 2: Update `src/core/events/event_bus.cpp`** if any non-template helper functions are needed. If all logic is in the header templates, event_bus.cpp can just contain the namespace with a comment noting this.

**Step 3: Build and run ALL tests:**
```bash
cmake --build build --target dw_tests 2>&1
./build/dw_tests --gtest_filter=EventBus.* 2>&1
```
All 10 tests must PASS (GREEN phase).

**Step 4: Run full test suite to verify no regressions:**
```bash
./build/dw_tests 2>&1
```
All existing tests must still pass.

**Step 5: REFACTOR (if needed).** Review the implementation for:
- Code clarity (are template methods readable?)
- Naming consistency (matches project conventions?)
- File size compliance (event_bus.h under 400 lines, event_bus.cpp under 800 lines)
- Remove any unnecessary includes

If refactoring is done, re-run tests to confirm they still pass.

**Step 6: Commit GREEN (and REFACTOR if done):**
- GREEN commit: `feat(1.1-01): implement EventBus with type-safe pub/sub and weak_ptr cleanup`
- REFACTOR commit (if separate): `refactor(1.1-01): clean up EventBus implementation`
  </action>
  <verify>
Run: `cmake --build build --target dw_tests 2>&1` -- compiles with no errors.
Run: `./build/dw_tests --gtest_filter=EventBus.* 2>&1` -- all 10 EventBus tests pass.
Run: `./build/dw_tests 2>&1` -- full test suite passes (no regressions).
  </verify>
  <done>
All 10 EventBus tests pass. Full test suite has zero regressions. EventBus implementation is clean, follows project conventions, and is under file size limits. GREEN phase confirmed. Committed.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `cmake --build build --target dw_tests` compiles without errors or warnings
2. `./build/dw_tests --gtest_filter=EventBus.*` -- all 10 tests pass
3. `./build/dw_tests` -- full suite passes, zero regressions
4. `src/core/events/event_bus.h` exists, is under 400 lines, contains `class EventBus`
5. `src/core/events/event_bus.cpp` exists, is under 800 lines
6. `src/core/events/event_types.h` exists, contains at least 6 event struct definitions
7. No memory leaks detectable (weak_ptr cleanup verified by WeakRefCleanup tests)
</verification>

<success_criteria>
- EventBus subscribe/publish works with type-safe dispatch
- Multiple subscribers per event type work correctly
- Weak reference cleanup prevents memory leaks
- Reentrancy during publish is safe (no iterator invalidation)
- Exception in one handler does not block others
- All existing tests continue to pass
- TDD RED-GREEN-REFACTOR cycle followed with atomic commits
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-eventbus/1.1-01-SUMMARY.md`
</output>
