# Phase 1.1: EventBus for Decoupled Communication - Research

**Researched:** 2026-02-08
**Domain:** C++17 Event-Driven Architecture, Observer Pattern, Type-Safe Event Dispatch
**Confidence:** HIGH

## Summary

A C++17 EventBus provides type-safe publish/subscribe communication between subsystems without direct coupling. The standard implementation uses template-based type registration with `std::type_index` for event type mapping, `std::function` for callback storage, and `std::weak_ptr` for automatic subscriber lifetime management. The existing codebase heavily uses `std::function` callbacks in a point-to-point manner (Application sets callbacks on panels, panels set callbacks on Application), creating tight coupling that the EventBus will eliminate.

The recommended approach is a dependency-injected EventBus instance (not a singleton) stored in Application, using `std::any` for type erasure, template-based subscribe/publish APIs for compile-time type safety, and lazy cleanup of expired weak_ptr subscribers during event dispatch. Lambda-based subscription is preferred over `std::bind` for clarity and performance.

**Primary recommendation:** Implement template-based EventBus with `std::type_index` mapping, `std::any` storage, `std::weak_ptr<std::function>` subscriber storage, and lazy cleanup during publish. Store as Application member (dependency injection), not singleton. Support lambda and member function binding via templated subscribe API.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `std::type_index` | C++11+ | Event type identification | Standard way to use types as map keys, enables template-based dispatch |
| `std::any` | C++17 | Type-erased event storage | Standard type erasure, allows heterogeneous event storage without inheritance |
| `std::function` | C++11+ | Callback storage | Standard callable wrapper, supports lambdas, free functions, member functions |
| `std::weak_ptr` | C++11+ | Subscriber lifetime management | Non-owning reference, enables automatic cleanup when subscriber dies |
| `std::unordered_map` | C++11+ | Event type to handlers mapping | Fast O(1) lookup by type_index |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `std::shared_ptr` | C++11+ | Handler ownership (internal) | Wrap std::function instances for weak_ptr support |
| `std::vector` | STL | Handler list storage | Store multiple subscribers per event type |
| `std::remove_if` | STL | Expired handler cleanup | Lazy cleanup of dead weak_ptr during dispatch |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| `std::any` | `std::variant` | Variant requires knowing all event types upfront (closed set), Any supports open extension (better for plugins/future events) |
| `std::any` | Inheritance-based polymorphism (Event base class) | Virtual dispatch overhead, forces event types to inherit from base, Any is more flexible |
| Dependency injection | Singleton pattern | Singleton creates hidden dependency, harder to test, but simpler access. DI makes dependency explicit, testable |
| Lambda subscription | `std::bind` | bind is harder to read, deprecated in favor of lambdas in modern C++ |

**Installation:**
```bash
# No external dependencies - uses C++17 standard library only
# Requires compiler: g++8+, clang++7+, MSVC 2017+
```

## Architecture Patterns

### Recommended Project Structure
```
src/core/events/
├── event_bus.h          # EventBus class template API
├── event_bus.cpp        # Implementation (if needed for non-template parts)
└── event_types.h        # Common event struct definitions (future)

tests/
└── test_event_bus.cpp   # Unit tests
```

### Pattern 1: Template-Based Type Registration
**What:** Use templates at subscribe/publish points, internally map to `std::type_index`
**When to use:** Always - provides compile-time type safety
**Example:**
```cpp
// Event definition (plain struct, no inheritance required)
struct WorkspaceChanged {
    int64_t newModelId;
    std::string modelName;
};

// Subscribe with lambda
eventBus.subscribe<WorkspaceChanged>([this](const WorkspaceChanged& e) {
    updateViewport(e.newModelId);
});

// Publish
eventBus.publish(WorkspaceChanged{modelId, name});
```

### Pattern 2: Weak Pointer Subscriber Storage with Lazy Cleanup
**What:** Store `std::weak_ptr<std::function>` to handlers, clean up expired on dispatch
**When to use:** Always - prevents memory leaks when subscribers die
**Example:**
```cpp
// Internal storage (simplified)
std::unordered_map<std::type_index, std::vector<std::weak_ptr<HandlerFunc>>> handlers_;

// During publish - lazy cleanup algorithm:
void publish(const Event& event) {
    auto& handlerList = handlers_[typeid(Event)];

    // Lock and invoke, build cleanup list
    for (auto it = handlerList.begin(); it != handlerList.end(); ) {
        if (auto handler = it->lock()) {
            (*handler)(event);
            ++it;
        } else {
            it = handlerList.erase(it); // Remove expired during iteration
        }
    }
}
```
**Source:** [Automatic event cleanup in C++](http://nercury.github.io/c++/interesting/2016/02/22/weak_ptr-and-event-cleanup.html)

### Pattern 3: RAII Subscription Handles
**What:** Return handle object from subscribe() that auto-unsubscribes on destruction
**When to use:** Optional but recommended - provides explicit lifetime control
**Example:**
```cpp
class SubscriptionHandle {
    std::weak_ptr<void> token_;
public:
    SubscriptionHandle(std::weak_ptr<void> token) : token_(token) {}
    ~SubscriptionHandle() { /* token destruction auto-unsubscribes */ }
};

auto handle = eventBus.subscribe<Event>([](const Event& e) { ... });
// handle goes out of scope -> automatic unsubscribe
```

### Pattern 4: Dependency Injection (Not Singleton)
**What:** Store EventBus as Application member, pass by reference to subsystems
**When to use:** Always - avoids hidden dependencies, testable
**Example:**
```cpp
// In Application.h
class Application {
    EventBus m_eventBus;
    std::unique_ptr<LibraryPanel> m_libraryPanel;

    bool init() {
        m_libraryPanel = std::make_unique<LibraryPanel>(m_eventBus);
        m_eventBus.subscribe<ImportCompleted>([this](auto& e) {
            onImportCompleted(e);
        });
    }
};

// In LibraryPanel constructor
LibraryPanel(EventBus& bus) : m_eventBus(bus) {
    m_eventBus.subscribe<ModelDeleted>([this](auto& e) { refresh(); });
}
```
**Source:** [The Singleton: The Alternatives](https://www.modernescpp.com/index.php/the-singleton-the-alternatives/)

### Anti-Patterns to Avoid
- **Storing raw pointers to handlers:** Memory leaks when subscribers die. Always use weak_ptr.
- **Cleaning up subscribers in separate pass:** Adds complexity and risk of iterator invalidation. Clean during dispatch.
- **Using std::bind for lambdas:** Harder to read, worse performance. Prefer lambda syntax.
- **Event inheritance hierarchy:** Over-engineering. Plain structs work fine, std::any handles type erasure.
- **Thread-safe EventBus for main-thread-only app:** Unnecessary mutex overhead. Document main-thread-only contract.
- **Synchronous event dispatch during critical sections:** Can cause reentrancy issues. Document when events fire.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Event type identification | String-based event names | `std::type_index` from `typeid()` | Compile-time safety, no typos, O(1) hash lookup |
| Type erasure | Custom `void*` casting | `std::any` | Type-safe, standard, handles RTTI automatically |
| Callback storage | Function pointer + void* context | `std::function` | Supports lambdas with captures, member functions, standard |
| Subscriber lifetime tracking | Manual subscribe/unsubscribe pairs | `std::weak_ptr` + lazy cleanup | Automatic, no memory leaks if unsubscribe forgotten |
| Handler collection cleanup | Explicit cleanup API | Lazy removal during dispatch | Simpler, no extra API surface, naturally thread-safe (if needed) |

**Key insight:** C++17 standard library provides all the building blocks for type-safe event systems. Custom solutions reimplement worse versions of `std::any`, `std::function`, and `std::weak_ptr`. The only custom code needed is the mapping from `type_index` to handler lists and the dispatch loop.

## Common Pitfalls

### Pitfall 1: Forgetting to std::move() Event Objects
**What goes wrong:** Large event objects copied multiple times during publish
**Why it happens:** Publish API takes `const Event&`, but internal `std::any` storage copies by default
**How to avoid:** Provide both `publish(const T&)` for lvalues and `publish(T&&)` for rvalues with std::move
**Warning signs:** Performance degradation with large event payloads, profiler shows std::any copy overhead

### Pitfall 2: Dangling References in Event Data
**What goes wrong:** Event contains `std::string_view` or raw pointer, references deleted data after publish returns
**Why it happens:** Events are dispatched synchronously, but subscribers might store event for later
**How to avoid:** Event structs should own their data (std::string, not string_view). Document synchronous dispatch contract.
**Warning signs:** Crashes in event handlers accessing string/pointer fields, use-after-free in sanitizers

### Pitfall 3: Modifying Subscriber List During Dispatch (Reentrancy)
**What goes wrong:** Iterator invalidation if subscribe/unsubscribe called from within event handler
**Why it happens:** Event handler triggers another event that adds/removes subscriber to same event type
**How to avoid:** Two options: (1) Defer subscription changes until after dispatch, (2) Copy handler list before iterating
**Warning signs:** Crashes during event dispatch, handlers mysteriously not called, double-firing
**Recommendation:** Use approach (2) - copy handler vector before iteration. Simple, safe, small overhead.

### Pitfall 4: Circular Event Chains
**What goes wrong:** Event A fires Event B which fires Event A -> infinite recursion, stack overflow
**Why it happens:** No cycle detection in event chains, easy to create feedback loops
**How to avoid:** Document event flows, avoid bidirectional event dependencies, add recursion depth check
**Warning signs:** Stack overflow, infinite loop in event dispatch, same event firing repeatedly

### Pitfall 5: Assuming Thread Safety
**What goes wrong:** Concurrent publish from worker thread + subscribe from main thread = data race
**Why it happens:** EventBus has no mutexes in main-thread-only design
**How to avoid:** Document main-thread-only contract clearly. For worker threads, use separate queue (MainThreadQueue already exists in this project)
**Warning signs:** Intermittent crashes, TSAN data race warnings, corrupted handler lists

### Pitfall 6: Storing Event References Instead of Copies
**What goes wrong:** Handler stores `const Event&`, reference dangles after publish() returns
**Why it happens:** Events are stack-allocated at call site, destroyed after dispatch
**How to avoid:** Handlers must copy event data if storing for later. Document this in API.
**Warning signs:** Use-after-scope, dangling reference warnings, ASAN failures

## Code Examples

### Basic EventBus API (Header Interface)
```cpp
// Source: Synthesized from multiple C++ event bus implementations
// https://github.com/DeveloperPaul123/eventbus
// https://bastian.rieck.me/blog/2015/event_system_cxx11/

class EventBus {
public:
    // Subscribe to event type with callable (lambda, function, member function)
    template<typename EventType, typename Handler>
    void subscribe(Handler&& handler);

    // Publish event to all subscribers (lvalue)
    template<typename EventType>
    void publish(const EventType& event);

    // Publish event to all subscribers (rvalue, moved)
    template<typename EventType>
    void publish(EventType&& event);

private:
    using HandlerList = std::vector<std::weak_ptr<void>>;
    std::unordered_map<std::type_index, HandlerList> handlers_;
};
```

### Subscribe Implementation with weak_ptr
```cpp
// Source: Pattern from https://nercury.github.io/c++/interesting/2016/02/22/weak_ptr-and-event-cleanup.html

template<typename EventType, typename Handler>
void EventBus::subscribe(Handler&& handler) {
    // Wrap handler in shared_ptr for weak_ptr support
    auto handlerFunc = std::make_shared<std::function<void(const EventType&)>>(
        std::forward<Handler>(handler)
    );

    // Store as weak_ptr (type-erased to void for heterogeneous storage)
    auto typeIndex = std::type_index(typeid(EventType));
    handlers_[typeIndex].push_back(handlerFunc);
}
```

### Publish with Lazy Cleanup
```cpp
// Source: Lazy cleanup pattern from https://nercury.github.io/c++/interesting/2016/02/22/weak_ptr-and-event-cleanup.html

template<typename EventType>
void EventBus::publish(const EventType& event) {
    auto typeIndex = std::type_index(typeid(EventType));
    auto it = handlers_.find(typeIndex);
    if (it == handlers_.end()) return;

    auto& handlerList = it->second;

    // Iterate and clean up expired handlers
    for (auto handlerIt = handlerList.begin(); handlerIt != handlerList.end(); ) {
        // Cast type-erased void* back to concrete function type
        auto handler = std::static_pointer_cast<std::function<void(const EventType&)>>(
            handlerIt->lock()
        );

        if (handler) {
            (*handler)(event);  // Invoke
            ++handlerIt;
        } else {
            handlerIt = handlerList.erase(handlerIt);  // Remove expired
        }
    }
}
```

### Existing Callback Pattern to Replace
```cpp
// BEFORE (tight coupling via std::function callbacks)
// From Application.cpp lines 219-226
m_libraryPanel->setOnModelSelected([this](int64_t modelId) {
    if (!m_libraryManager) return;
    auto record = m_libraryManager->getModel(modelId);
    if (record && m_propertiesPanel) {
        m_propertiesPanel->setModelRecord(*record);
    }
});

// AFTER (decoupled via EventBus)
// In LibraryPanel - publish when selection changes
struct ModelSelected {
    int64_t modelId;
};
m_eventBus.publish(ModelSelected{modelId});

// In Application - subscribe to ModelSelected
m_eventBus.subscribe<ModelSelected>([this](const ModelSelected& e) {
    if (!m_libraryManager) return;
    auto record = m_libraryManager->getModel(e.modelId);
    if (record && m_propertiesPanel) {
        m_propertiesPanel->setModelRecord(*record);
    }
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `std::bind` for callbacks | Lambdas with capture | C++11 | Clearer syntax, better optimization, std::bind considered deprecated |
| Inheritance-based events (Event base class) | std::any type erasure | C++17 | No forced inheritance, simpler event definitions |
| Manual subscribe/unsubscribe pairs | weak_ptr automatic cleanup | C++11 | Prevents memory leaks from forgotten unsubscribe calls |
| String-based event names | std::type_index | C++11 | Compile-time safety, no string typos, better performance |

**Deprecated/outdated:**
- **boost::signals2**: Pre-C++11 solution, now redundant with std::function and modern patterns
- **Qt signals/slots**: MOC preprocessor required, not suitable for non-Qt projects
- **String-based event dispatch**: Popular in scripting languages, but C++ has type_index for type-safe alternative

## Open Questions

1. **Should EventBus support priority/ordering of handlers?**
   - What we know: Multiple handlers subscribe to same event, execution order matters for some use cases
   - What's unclear: Do we need priority levels, or is registration order sufficient?
   - Recommendation: Start with registration order (FIFO). Add priority only if needed (YAGNI principle)

2. **Should unsubscribe return bool indicating success?**
   - What we know: weak_ptr auto-cleanup means explicit unsubscribe may not be needed
   - What's unclear: Is there value in knowing if unsubscribe found/removed a handler?
   - Recommendation: No explicit unsubscribe API initially. Use weak_ptr + RAII only. Simpler.

3. **How to handle exceptions in event handlers?**
   - What we know: If one handler throws, should other handlers still run?
   - What's unclear: Best practice for exception isolation in event systems
   - Recommendation: Wrap each handler invocation in try/catch, log error, continue to next handler. Don't propagate exception to publisher.

## Existing Codebase Coupling Analysis

### Current Callback Pattern Usage
The Application class currently uses 9 `std::function` callbacks to communicate with panels:

| Callback | Set In | Called From | Event Equivalent |
|----------|--------|-------------|------------------|
| `setOnModelSelected` | Application → LibraryPanel | LibraryPanel | `ModelSelected{modelId}` |
| `setOnModelOpened` | Application → LibraryPanel | LibraryPanel | `ModelOpened{modelId}` |
| `setOnMeshModified` | Application → PropertiesPanel | PropertiesPanel | `MeshTransformed{meshId}` |
| `setOnColorChanged` | Application → PropertiesPanel | PropertiesPanel | `RenderSettingChanged{color}` |
| `setOnComplete` | Application → ImportQueue | ImportQueue | `ImportCompleted{task}` |
| `setOnChanged` | Application → ConfigWatcher | ConfigWatcher | `ConfigFileChanged{}` |
| `setOnNewProject` | Application → StartPage | StartPage | `NewProjectRequested{}` |
| `setOnOpenProject` | Application → StartPage | StartPage | `OpenProjectRequested{}` |
| `setOnImportModel` | Application → StartPage | StartPage | `ImportModelRequested{}` |

**Coupling smell:** Application must know about every panel's callback interface. Adding new UI component requires modifying Application.

### Recommended Initial Events
Based on Application.cpp analysis (lines 219-266), these events would provide immediate value:

```cpp
// Core workspace events
struct ModelSelected { int64_t modelId; };
struct ModelOpened { int64_t modelId; };
struct WorkspaceChanged { int64_t newModelId; std::string modelName; };

// Import pipeline events
struct ImportCompleted {
    int64_t modelId;
    std::shared_ptr<Mesh> mesh;
    std::string name;
};
struct ImportFailed { Path filePath; std::string error; };

// Configuration events
struct ConfigFileChanged {};
struct ThemeChanged { int themeIndex; };

// UI request events (from StartPage to Application)
struct NewProjectRequested {};
struct OpenProjectRequested {};
struct ImportModelRequested {};
```

**Migration strategy:** Don't replace all callbacks immediately. Start with one event type (e.g., `ImportCompleted`), prove the pattern, then migrate others incrementally.

## Sources

### Primary (HIGH confidence)
- C++ Standard Library Documentation - `<any>`, `<functional>`, `<memory>`, `<typeindex>` - Standard library APIs verified from cppreference.com
- [Automatic event cleanup in C++](http://nercury.github.io/c++/interesting/2016/02/22/weak_ptr-and-event-cleanup.html) - weak_ptr lazy cleanup pattern with algorithm details
- [Implementing a simple event system in C++11](https://bastian.rieck.me/blog/2015/event_system_cxx11/) - Template-based type-safe event system pattern
- [GitHub - DeveloperPaul123/eventbus](https://github.com/DeveloperPaul123/eventbus) - C++17 header-only implementation using std::any

### Secondary (MEDIUM confidence)
- [Avoiding Race Conditions in C++ Observer Pattern with std::weak_ptr](https://medium.com/@tkxa7064/avoiding-race-conditions-in-c-observer-pattern-with-std-weak_ptr-13ca0f90cc77) - Thread safety patterns (not directly applicable to main-thread-only, but informative)
- [C++ Type Erasure and std::function](https://uvdn7.github.io/type-erasure/) - Type erasure overview for event systems
- [The Singleton: The Alternatives](https://www.modernescpp.com/index.php/the-singleton-the-alternatives/) - Dependency injection vs singleton for event bus
- [Improving Your Callback Game](https://embeddedartistry.com/blog/2017/02/01/improving-your-callback-game/) - Lambda vs std::bind recommendations
- [abseil / Tip of the Week #108: Avoid std::bind](https://abseil.io/tips/108) - Modern C++ prefers lambdas over bind

### Tertiary (LOW confidence)
- Multiple GitHub event bus implementations (gelldur/EventBus, skypjack/eventpp, mmcshane/eventbus) - Scanned for patterns but not deeply verified
- Stack Overflow discussions on std::type_index and std::any usage - General patterns, not authoritative

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All components are C++17 standard library, well-documented, stable
- Architecture: HIGH - Patterns verified across multiple independent sources, proven in production systems
- Pitfalls: MEDIUM-HIGH - Based on documented common mistakes and personal experience (some are hypothetical for this specific implementation)
- Existing codebase analysis: HIGH - Directly examined Application.cpp and related headers

**Research date:** 2026-02-08
**Valid until:** 2026-09-08 (6 months - C++17 patterns are stable, unlikely to change)

**What might I have missed:**
- Performance benchmarks of std::any vs std::variant for this specific use case (would need profiling)
- Whether to support immediate/deferred event dispatch modes (current design assumes synchronous)
- Integration with ImGui's immediate mode rendering (event handlers may need to defer work to next frame)
- Whether to expose EventBus to scripting/plugin system in future (affects API design)
