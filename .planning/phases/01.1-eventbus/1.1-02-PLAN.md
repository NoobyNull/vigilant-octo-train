---
phase: 01.1-eventbus
plan: 02
type: execute
wave: 2
depends_on: ["1.1-01"]
files_modified:
  - src/app/application.h
  - src/app/application.cpp
autonomous: true

must_haves:
  truths:
    - "Application owns an EventBus instance accessible for subsystem wiring"
    - "EventBus is initialized before panels and managers that will use it"
    - "EventBus is destroyed after panels and managers during shutdown"
    - "Existing application behavior is unchanged (NR1 compliance)"
  artifacts:
    - path: "src/app/application.h"
      provides: "EventBus member declaration and forward declaration"
      contains: "EventBus"
    - path: "src/app/application.cpp"
      provides: "EventBus initialization in init() and inclusion in shutdown order"
      contains: "m_eventBus"
  key_links:
    - from: "src/app/application.h"
      to: "src/core/events/event_bus.h"
      via: "Forward declaration of EventBus, unique_ptr member"
      pattern: "class EventBus"
    - from: "src/app/application.cpp"
      to: "src/core/events/event_bus.h"
      via: "Include and construction of EventBus instance"
      pattern: "#include.*event_bus"
---

<objective>
Integrate EventBus into the Application class as a member, establishing the wiring point for future subsystem decoupling (Phase 1.4 god class decomposition).

Purpose: Application must own the EventBus so it can be passed by reference to panels and managers during construction. This plan adds the member and ensures correct initialization/shutdown order without changing any existing behavior.

Output: Application.h with EventBus member, Application.cpp with EventBus initialization in the correct lifecycle position.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-eventbus/1.1-01-SUMMARY.md
@src/app/application.h
@src/app/application.cpp
@src/core/events/event_bus.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventBus member to Application and wire lifecycle</name>
  <files>
    src/app/application.h
    src/app/application.cpp
  </files>
  <action>
**Step 1: Modify `src/app/application.h`:**

- Add forward declaration for EventBus in the forward declarations block (alongside Database, LibraryManager, etc.):
  ```cpp
  class EventBus;
  ```
- Add EventBus member in the "Core systems" section, BEFORE Database (EventBus has no dependencies and should be available first):
  ```cpp
  // Core systems
  std::unique_ptr<EventBus> m_eventBus;
  std::unique_ptr<Database> m_database;
  // ... rest unchanged
  ```
- Add a public accessor method for subsystems that will need the EventBus reference:
  ```cpp
  // Accessors
  auto isRunning() const -> bool { return m_running; }
  auto getWindow() const -> SDL_Window* { return m_window; }
  auto eventBus() -> EventBus& { return *m_eventBus; }
  ```

**Step 2: Modify `src/app/application.cpp`:**

- Add include at the top of the project headers section:
  ```cpp
  #include "core/events/event_bus.h"
  ```
  Place it alphabetically among the `core/` includes, after `core/database/schema.h` and before `core/export/model_exporter.h`.

- In `Application::init()`, create the EventBus BEFORE database initialization (approximately line 158, before `m_database = std::make_unique<Database>()`):
  ```cpp
  // Initialize EventBus (foundation for decoupled communication)
  m_eventBus = std::make_unique<EventBus>();
  ```

- In `Application::shutdown()`, destroy EventBus AFTER all panels and managers are destroyed (it should be the last core system destroyed, since managers may still hold subscription handles). Add after `m_database.reset();`:
  ```cpp
  m_eventBus.reset();  // Destroy after all subscribers
  ```

**Step 3: Verify compilation of the full application (not just tests):**
```bash
cmake --build build 2>&1
```
The full application must compile. This confirms EventBus integrates cleanly with the Application dependency tree.

**Step 4: Run the full test suite to confirm no regressions:**
```bash
cmake --build build --target dw_tests 2>&1
./build/dw_tests 2>&1
```
All tests must pass, including the EventBus tests from Plan 01.

**IMPORTANT:**
- Do NOT add any event subscriptions or change any existing callbacks. That is Phase 1.4 work.
- Do NOT modify any panel constructors to accept EventBus. That is also Phase 1.4.
- This plan ONLY establishes the EventBus member and its lifecycle. The goal is minimal, safe integration.

Commit message: `feat(1.1-02): add EventBus member to Application with correct lifecycle ordering`
  </action>
  <verify>
Run: `cmake --build build 2>&1` -- full application compiles without errors.
Run: `cmake --build build --target dw_tests 2>&1 && ./build/dw_tests 2>&1` -- all tests pass (including EventBus tests from Plan 01).
Verify: `grep -n "m_eventBus" src/app/application.h` shows the member declaration.
Verify: `grep -n "m_eventBus" src/app/application.cpp` shows init and shutdown usage.
  </verify>
  <done>
Application compiles with EventBus member. EventBus is created in init() before other systems, destroyed in shutdown() after all subscribers. All tests pass. No behavioral changes to existing functionality.
  </done>
</task>

</tasks>

<verification>
After task completes:
1. `cmake --build build` succeeds (full application compiles)
2. `./build/dw_tests` passes all tests including EventBus tests
3. `src/app/application.h` contains `std::unique_ptr<EventBus> m_eventBus`
4. `src/app/application.cpp` constructs EventBus before Database, destroys after Database
5. No existing callbacks or panel constructors are modified
6. Application behavior is identical to before (NR1: No Behavioral Changes)
</verification>

<success_criteria>
- EventBus member exists in Application
- Initialization order: EventBus before Database, managers, panels
- Shutdown order: EventBus after Database, managers, panels
- Full application compiles and runs
- All tests pass with zero regressions
- No behavioral changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-eventbus/1.1-02-SUMMARY.md`
</output>
