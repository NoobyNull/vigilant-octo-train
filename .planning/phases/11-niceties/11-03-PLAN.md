---
phase: 11-niceties
plan: 03
type: execute
wave: 2
depends_on:
  - 11-01
  - 11-02
files_modified:
  - src/core/config/config.h
  - src/core/config/config.cpp
  - src/core/config/input_binding.h
  - src/core/config/input_binding.cpp
  - src/ui/panels/gcode_panel.h
  - src/ui/panels/gcode_panel.cpp
  - src/app/application_wiring.cpp
autonomous: true
requirements:
  - NIC-05
  - NIC-06
  - NIC-08

must_haves:
  truths:
    - "Recent G-code files (last 10) appear in the GCode panel for quick re-loading"
    - "Keyboard shortcuts adjust feed override (plus/minus 10%) and spindle override (plus/minus 10%)"
    - "When a streaming job completes, the operator receives a visible toast notification and an optional status bar flash"
  artifacts:
    - path: "src/core/config/config.h"
      provides: "Recent G-code file list and job notification config"
      contains: "getRecentGCodeFiles"
    - path: "src/core/config/input_binding.h"
      provides: "BindAction entries for feed and spindle override shortcuts"
      contains: "FeedOverridePlus"
    - path: "src/ui/panels/gcode_panel.cpp"
      provides: "Recent files dropdown and job completion notification with status bar flash"
      contains: "recentGcode"
    - path: "src/app/application_wiring.cpp"
      provides: "Job completion toast in onProgressUpdate callback"
      contains: "Job Complete"
  key_links:
    - from: "src/ui/panels/gcode_panel.cpp"
      to: "src/core/config/config.h"
      via: "Config::instance().getRecentGCodeFiles() for recent file list"
      pattern: "getRecentGCodeFiles"
    - from: "src/app/application_wiring.cpp"
      to: "src/ui/widgets/toast.h"
      via: "ToastManager::instance().show() for job completion notification"
      pattern: "ToastManager.*Job"
    - from: "src/ui/panels/gcode_panel.cpp"
      to: "src/core/config/input_binding.h"
      via: "BindAction::FeedOverridePlus/Minus for keyboard shortcut handling"
      pattern: "FeedOverridePlus"
---

<objective>
Add recent G-code files list, keyboard shortcuts for feed/spindle overrides, and job completion notification with status bar flash.

Purpose: Speed up repeated workflows by providing quick access to recently used G-code files, enable hands-free override adjustments via keyboard, and give clear visual feedback when a job completes so the operator doesn't have to watch the screen continuously.
Output: Recent files in GCode panel toolbar, bindable keyboard shortcuts for overrides, toast + status bar flash on job completion.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/core/config/config.h
@src/core/config/config.cpp
@src/core/config/input_binding.h
@src/core/config/input_binding.cpp
@src/ui/panels/gcode_panel.h
@src/ui/panels/gcode_panel.cpp
@src/app/application_wiring.cpp
@src/ui/widgets/toast.h

<interfaces>
From src/core/config/config.h:
```cpp
class Config {
    // Existing patterns:
    const std::vector<Path>& getRecentProjects() const;
    void addRecentProject(const Path& path);
    void removeRecentProject(const Path& path);
    static constexpr int MAX_RECENT_PROJECTS = 10;

    // Existing CNC settings:
    int getStatusPollIntervalMs() const;
    int getJogFeedSmall() const;
    // ...
};
```

From src/core/config/input_binding.h:
```cpp
enum class BindAction : int {
    LightDirDrag = 0,
    LightIntensityDrag,
    COUNT,
};

const char* bindActionName(BindAction action);
InputBinding defaultBinding(BindAction action);
```

From src/ui/panels/gcode_panel.h:
```cpp
class GCodePanel : public Panel {
    bool loadFile(const std::string& path);
    void onGrblProgress(const StreamProgress& progress);
    FileDialog* m_fileDialog = nullptr;
    std::string m_filePath;
    CncController* m_cnc = nullptr;
    StreamProgress m_streamProgress;
    void renderToolbar();
};
```

From src/ui/panels/gcode_panel.cpp (completion detection):
```cpp
void GCodePanel::onGrblProgress(const StreamProgress& progress) {
    m_streamProgress = progress;
    if (progress.ackedLines >= progress.totalLines && progress.totalLines > 0) {
        addConsoleLine("Stream complete", ConsoleLine::Info);
        ToastManager::instance().show(ToastType::Success, "Done",
                                      "G-code streaming finished");
    }
}
```

From src/app/application_wiring.cpp (progress callback):
```cpp
cncCb.onProgressUpdate = [gcp, jobp, safetyp](const StreamProgress& progress) {
    gcp->onGrblProgress(progress);
    bool streaming = (progress.totalLines > 0 &&
                      progress.ackedLines < progress.totalLines);
    if (jobp) {
        jobp->onProgressUpdate(progress);
        jobp->setStreaming(streaming);
    }
    // ...
};
```

From src/ui/widgets/toast.h:
```cpp
enum class ToastType { Info, Warning, Error, Success };
class ToastManager {
    static ToastManager& instance();
    void show(ToastType type, const std::string& title,
              const std::string& message = "");
    void render(); // Call each frame
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Recent G-code files in Config and GCode panel, override keyboard shortcuts</name>
  <files>
    src/core/config/config.h
    src/core/config/config.cpp
    src/core/config/input_binding.h
    src/core/config/input_binding.cpp
    src/ui/panels/gcode_panel.h
    src/ui/panels/gcode_panel.cpp
  </files>
  <action>
**Recent G-code files (NIC-05):**

1. In config.h, add a recent G-code file list following the existing `recentProjects` pattern:

```cpp
// Recent G-code files (most recent first, max 10)
const std::vector<Path>& getRecentGCodeFiles() const { return m_recentGCodeFiles; }
void addRecentGCodeFile(const Path& path);
void clearRecentGCodeFiles();
```

Add private members:
```cpp
std::vector<Path> m_recentGCodeFiles;
static constexpr int MAX_RECENT_GCODE = 10;
```

Also add a config key for job completion notification:
```cpp
bool getJobCompletionNotify() const { return m_jobCompletionNotify; }
void setJobCompletionNotify(bool v) { m_jobCompletionNotify = v; }

bool getJobCompletionFlash() const { return m_jobCompletionFlash; }
void setJobCompletionFlash(bool v) { m_jobCompletionFlash = v; }
```

Add private members:
```cpp
bool m_jobCompletionNotify = true;
bool m_jobCompletionFlash = true;
```

2. In config.cpp:

Implement `addRecentGCodeFile()` following the same pattern as `addRecentProject()`:
```cpp
void Config::addRecentGCodeFile(const Path& path) {
    // Remove if already present
    m_recentGCodeFiles.erase(
        std::remove(m_recentGCodeFiles.begin(), m_recentGCodeFiles.end(), path),
        m_recentGCodeFiles.end());
    // Insert at front
    m_recentGCodeFiles.insert(m_recentGCodeFiles.begin(), path);
    // Trim to max
    if (static_cast<int>(m_recentGCodeFiles.size()) > MAX_RECENT_GCODE)
        m_recentGCodeFiles.resize(MAX_RECENT_GCODE);
}
```

Implement `clearRecentGCodeFiles()`:
```cpp
void Config::clearRecentGCodeFiles() {
    m_recentGCodeFiles.clear();
}
```

Add INI persistence in the [GCode] section (or [CNC] section, follow existing pattern). Save recent files as numbered keys: `recent_gcode_0`, `recent_gcode_1`, etc. In load(), read them back into the vector. Also persist `job_completion_notify` and `job_completion_flash` as booleans in the [CNC] section.

3. In gcode_panel.h, add:
```cpp
private:
    void renderRecentFiles();
```

4. In gcode_panel.cpp:

Call `Config::instance().addRecentGCodeFile(m_filePath)` inside `loadFile()` after a successful load.

Implement `renderRecentFiles()` as a dropdown combo or popup menu in the toolbar area:
```cpp
void GCodePanel::renderRecentFiles() {
    auto& cfg = Config::instance();
    const auto& recent = cfg.getRecentGCodeFiles();
    if (recent.empty()) return;

    if (ImGui::BeginMenu("Recent")) {
        for (const auto& path : recent) {
            // Show just the filename, tooltip shows full path
            std::string filename = path;
            auto lastSlash = filename.find_last_of("/\\");
            if (lastSlash != std::string::npos)
                filename = filename.substr(lastSlash + 1);

            if (ImGui::MenuItem(filename.c_str())) {
                loadFile(path);
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("%s", path.c_str());
            }
        }
        ImGui::Separator();
        if (ImGui::MenuItem("Clear Recent")) {
            cfg.clearRecentGCodeFiles();
            cfg.save();
        }
        ImGui::EndMenu();
    }
}
```

Call `renderRecentFiles()` from `renderToolbar()`. Look at how the existing toolbar is structured — if it uses a menu bar, add a "Recent" menu item. If it uses buttons, add a dropdown button. The toolbar likely has an "Open" button for file dialog. Place the Recent menu right after the Open button. If the toolbar doesn't use a menu bar, use `ImGui::BeginPopup`/`ImGui::EndPopup` triggered by a "Recent" button instead of `ImGui::BeginMenu`.

Check how renderToolbar() is currently structured and adapt. If it's just buttons, use:
```cpp
if (ImGui::Button("Recent")) {
    ImGui::OpenPopup("RecentGCodePopup");
}
if (ImGui::BeginPopup("RecentGCodePopup")) {
    // same menu items as above
    ImGui::EndPopup();
}
```

**Keyboard shortcuts for overrides (NIC-06):**

5. In input_binding.h, add new BindAction entries before COUNT:
```cpp
enum class BindAction : int {
    LightDirDrag = 0,
    LightIntensityDrag,
    FeedOverridePlus,
    FeedOverrideMinus,
    SpindleOverridePlus,
    SpindleOverrideMinus,
    COUNT,
};
```

6. In input_binding.cpp, update `bindActionName()` and `defaultBinding()`:

```cpp
// In bindActionName():
case BindAction::FeedOverridePlus:    return "Feed Override +10%";
case BindAction::FeedOverrideMinus:   return "Feed Override -10%";
case BindAction::SpindleOverridePlus: return "Spindle Override +10%";
case BindAction::SpindleOverrideMinus: return "Spindle Override -10%";

// In defaultBinding():
case BindAction::FeedOverridePlus:
    return {Mod_Ctrl, InputType::Key, ImGuiKey_Equal};  // Ctrl+= (plus)
case BindAction::FeedOverrideMinus:
    return {Mod_Ctrl, InputType::Key, ImGuiKey_Minus};  // Ctrl+-
case BindAction::SpindleOverridePlus:
    return {Mod_Ctrl | Mod_Shift, InputType::Key, ImGuiKey_Equal};  // Ctrl+Shift+=
case BindAction::SpindleOverrideMinus:
    return {Mod_Ctrl | Mod_Shift, InputType::Key, ImGuiKey_Minus};  // Ctrl+Shift+-
```

7. In gcode_panel.cpp (or wherever keyboard input is processed), add override shortcut handling. The GCodePanel already has a CncController pointer. Add a method or inline check in the render loop:

Look for where keyboard input is processed in the GCode panel or UIManager. If no central place exists, add to gcode_panel.cpp `render()` after the mode check:

```cpp
// Keyboard shortcuts for overrides (only when connected)
if (m_cnc && m_cncConnected) {
    auto& cfg = Config::instance();
    auto feedPlus = cfg.getBinding(BindAction::FeedOverridePlus);
    auto feedMinus = cfg.getBinding(BindAction::FeedOverrideMinus);
    auto spindlePlus = cfg.getBinding(BindAction::SpindleOverridePlus);
    auto spindleMinus = cfg.getBinding(BindAction::SpindleOverrideMinus);

    // Check for key presses (not held — single press per trigger)
    // InputBinding::isHeld() checks current frame state, so we need IsKeyPressed
    // Use ImGui::IsKeyPressed with the binding's key value
    if (feedPlus.isValid() && feedPlus.type == InputType::Key) {
        bool modsMatch = true;
        if ((feedPlus.modifiers & Mod_Ctrl) && !ImGui::GetIO().KeyCtrl) modsMatch = false;
        if ((feedPlus.modifiers & Mod_Shift) && !ImGui::GetIO().KeyShift) modsMatch = false;
        if ((feedPlus.modifiers & Mod_Alt) && !ImGui::GetIO().KeyAlt) modsMatch = false;
        if (modsMatch && ImGui::IsKeyPressed(static_cast<ImGuiKey>(feedPlus.value), false)) {
            m_cnc->setFeedOverride(std::min(200, m_machineStatus.feedOverride + 10));
        }
    }
    // Repeat for feedMinus, spindlePlus, spindleMinus
    if (feedMinus.isValid() && feedMinus.type == InputType::Key) {
        bool modsMatch = true;
        if ((feedMinus.modifiers & Mod_Ctrl) && !ImGui::GetIO().KeyCtrl) modsMatch = false;
        if ((feedMinus.modifiers & Mod_Shift) && !ImGui::GetIO().KeyShift) modsMatch = false;
        if ((feedMinus.modifiers & Mod_Alt) && !ImGui::GetIO().KeyAlt) modsMatch = false;
        if (modsMatch && ImGui::IsKeyPressed(static_cast<ImGuiKey>(feedMinus.value), false)) {
            m_cnc->setFeedOverride(std::max(10, m_machineStatus.feedOverride - 10));
        }
    }
    if (spindlePlus.isValid() && spindlePlus.type == InputType::Key) {
        bool modsMatch = true;
        if ((spindlePlus.modifiers & Mod_Ctrl) && !ImGui::GetIO().KeyCtrl) modsMatch = false;
        if ((spindlePlus.modifiers & Mod_Shift) && !ImGui::GetIO().KeyShift) modsMatch = false;
        if ((spindlePlus.modifiers & Mod_Alt) && !ImGui::GetIO().KeyAlt) modsMatch = false;
        if (modsMatch && ImGui::IsKeyPressed(static_cast<ImGuiKey>(spindlePlus.value), false)) {
            m_cnc->setSpindleOverride(std::min(200, m_machineStatus.spindleOverride + 10));
        }
    }
    if (spindleMinus.isValid() && spindleMinus.type == InputType::Key) {
        bool modsMatch = true;
        if ((spindleMinus.modifiers & Mod_Ctrl) && !ImGui::GetIO().KeyCtrl) modsMatch = false;
        if ((spindleMinus.modifiers & Mod_Shift) && !ImGui::GetIO().KeyShift) modsMatch = false;
        if ((spindleMinus.modifiers & Mod_Alt) && !ImGui::GetIO().KeyAlt) modsMatch = false;
        if (modsMatch && ImGui::IsKeyPressed(static_cast<ImGuiKey>(spindleMinus.value), false)) {
            m_cnc->setSpindleOverride(std::max(10, m_machineStatus.spindleOverride - 10));
        }
    }
}
```

Consider extracting a helper lambda `checkBinding(const InputBinding& b)` to reduce repetition.

Include `"core/config/input_binding.h"` in gcode_panel.cpp if not already present.
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Recent G-code files (last 10) stored in Config and persisted to INI
- Loading a G-code file adds it to recent list
- Recent files dropdown in GCode panel toolbar for quick re-load
- BindAction entries for FeedOverridePlus/Minus and SpindleOverridePlus/Minus
- Default bindings: Ctrl+=/Ctrl+- for feed, Ctrl+Shift+=/Ctrl+Shift+- for spindle
- Keyboard shortcuts send override commands when CNC is connected
- Config keys for job completion notification and flash added
  </done>
</task>

<task type="auto">
  <name>Task 2: Job completion notification with toast and status bar flash</name>
  <files>
    src/ui/panels/gcode_panel.cpp
    src/app/application_wiring.cpp
  </files>
  <action>
**Job completion notification (NIC-08):**

The existing code in `gcode_panel.cpp:onGrblProgress()` already shows a toast on completion:
```cpp
if (progress.ackedLines >= progress.totalLines && progress.totalLines > 0) {
    addConsoleLine("Stream complete", ConsoleLine::Info);
    ToastManager::instance().show(ToastType::Success, "Done",
                                  "G-code streaming finished");
}
```

This needs to be enhanced with:
1. Respecting the Config toggle for notification
2. Adding a status bar flash effect
3. Including elapsed time in the notification

1. In gcode_panel.cpp, modify `onGrblProgress()`:

```cpp
void GCodePanel::onGrblProgress(const StreamProgress& progress) {
    m_streamProgress = progress;

    // Check completion
    if (progress.ackedLines >= progress.totalLines && progress.totalLines > 0) {
        addConsoleLine("Stream complete", ConsoleLine::Info);

        auto& cfg = Config::instance();
        if (cfg.getJobCompletionNotify()) {
            // Format elapsed time
            int totalSec = static_cast<int>(progress.elapsedSeconds);
            int min = totalSec / 60;
            int sec = totalSec % 60;
            char msg[128];
            std::snprintf(msg, sizeof(msg), "G-code streaming finished in %d:%02d", min, sec);
            ToastManager::instance().show(ToastType::Success, "Job Complete", msg);
        }

        if (cfg.getJobCompletionFlash()) {
            m_jobFlashTimer = 3.0f; // Flash for 3 seconds
        }
    }
}
```

2. In gcode_panel.h, add:
```cpp
private:
    float m_jobFlashTimer = 0.0f; // Countdown timer for status bar flash
```

3. In gcode_panel.cpp `render()`, add a flashing status bar at the bottom of the panel when the timer is active. Decrement the timer by delta time each frame:

```cpp
// At the top of render(), after Begin:
if (m_jobFlashTimer > 0.0f) {
    m_jobFlashTimer -= ImGui::GetIO().DeltaTime;

    // Draw a flashing green bar at the top of the panel
    ImVec2 cursorPos = ImGui::GetCursorScreenPos();
    float width = ImGui::GetContentRegionAvail().x;
    float height = 4.0f;

    // Pulse alpha between 0.3 and 1.0
    float alpha = 0.5f + 0.5f * std::sin(m_jobFlashTimer * 6.0f); // ~1Hz pulse
    ImU32 flashColor = ImGui::ColorConvertFloat4ToU32(
        ImVec4(0.2f, 0.8f, 0.2f, alpha));
    ImGui::GetWindowDrawList()->AddRectFilled(
        cursorPos, ImVec2(cursorPos.x + width, cursorPos.y + height),
        flashColor);
    ImGui::Dummy(ImVec2(width, height));
}
```

Include `<cmath>` for `std::sin` if not already included.

4. In application_wiring.cpp, the `onProgressUpdate` callback already calls `gcp->onGrblProgress(progress)`. The toast is now inside `onGrblProgress()` which already runs. No changes needed to application_wiring for the toast itself.

However, we should also ensure the status bar flash works even when the GCode panel is docked but not focused. Since the flash is rendered inside the panel's render() method, it will show whenever the panel is visible. This is sufficient — if the panel is hidden, the toast notification alone provides feedback.

5. **Optional enhancement for application_wiring.cpp:** Add the job completion notification to the wiring layer as well, so it triggers even if the GCode panel's onGrblProgress isn't called (edge case if panel is destroyed). Since the panel always exists in current architecture, this is optional. Skip if not needed — the gcode_panel.cpp change is the primary implementation.

Remove the old toast call from `onGrblProgress()` (replace it with the new Config-aware version above). Do NOT duplicate the toast by keeping both the old and new code.
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Job completion triggers a toast notification showing "Job Complete" with elapsed time
- Toast notification respects Config toggle (can be disabled)
- Status bar flash provides visual pulsing green indicator for 3 seconds
- Status bar flash respects separate Config toggle
- Flash works as a pulsing effect visible in the GCode panel
- No duplicate toast calls
  </done>
</task>

</tasks>

<verification>
- cmake --build build -j$(nproc) — builds without errors
- ctest --test-dir build --output-on-failure — all existing tests pass
</verification>

<success_criteria>
- Recent G-code files list shows last 10 loaded files in GCode panel
- Loading a file adds it to the recent list (persisted in Config)
- Keyboard shortcuts for feed/spindle override (plus/minus 10%) work when connected
- Override shortcuts are bindable via the existing input binding system
- Job completion shows toast with elapsed time (configurable)
- Status bar flashes green on job completion (configurable)
- Both notification features can be individually toggled in Config
</success_criteria>

<output>
After completion, create `.planning/phases/11-niceties/11-03-SUMMARY.md`
</output>
