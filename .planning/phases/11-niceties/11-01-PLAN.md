---
phase: 11-niceties
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/panels/cnc_status_panel.h
  - src/ui/panels/cnc_status_panel.cpp
  - src/ui/panels/cnc_jog_panel.h
  - src/ui/panels/cnc_jog_panel.cpp
autonomous: true
requirements:
  - NIC-01
  - NIC-02
  - NIC-03

must_haves:
  truths:
    - "Double-clicking a DRO axis value zeros that axis by sending G10 L20 P0 for the clicked axis"
    - "A Move-To dialog allows entering explicit XYZ coordinates and sends G0 to the target position"
    - "Four diagonal XY jog buttons (+X+Y, +X-Y, -X+Y, -X-Y) send simultaneous two-axis jog commands"
  artifacts:
    - path: "src/ui/panels/cnc_status_panel.cpp"
      provides: "DRO click-to-zero and Move-To dialog rendering"
      contains: "G10 L20"
    - path: "src/ui/panels/cnc_jog_panel.cpp"
      provides: "Diagonal jog buttons sending combined XY jog commands"
      contains: "jogDiagonal"
  key_links:
    - from: "src/ui/panels/cnc_status_panel.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "CncController::sendCommand() for G10 L20 zero and G0 move-to"
      pattern: "sendCommand.*G10"
    - from: "src/ui/panels/cnc_jog_panel.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "CncController::sendCommand() for diagonal $J jog commands"
      pattern: "sendCommand.*\\$J"
---

<objective>
Add DRO click-to-zero, move-to dialog, and diagonal XY jog buttons to the CNC UI panels.

Purpose: Enable faster operator workflows for zeroing axes (double-click instead of navigating menus), positioning the machine at specific coordinates, and diagonal XY jog movement.
Output: Interactive DRO with click-to-zero, modal move-to dialog, four diagonal jog buttons in the jog panel.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/ui/panels/cnc_status_panel.h
@src/ui/panels/cnc_status_panel.cpp
@src/ui/panels/cnc_jog_panel.h
@src/ui/panels/cnc_jog_panel.cpp
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_types.h

<interfaces>
From src/ui/panels/cnc_status_panel.h:
```cpp
class CncStatusPanel : public Panel {
    void render() override;
    void setCncController(CncController* cnc) { m_cnc = cnc; }
    void onStatusUpdate(const MachineStatus& status);
    void onConnectionChanged(bool connected, const std::string& version);
    void onAlarm(int alarmCode, const std::string& desc);

    // Existing render methods:
    void renderStateIndicator();
    void renderDRO();             // Currently display-only
    void renderFeedSpindle();
    void renderOverrideControls();
    void renderCoolantControls();
    void renderAlarmBanner();
    void renderWcsSelector();

    CncController* m_cnc = nullptr;
    MachineStatus m_status{};
    bool m_connected = false;
};
```

From src/ui/panels/cnc_jog_panel.h:
```cpp
class CncJogPanel : public Panel {
    void render() override;
    void setCncController(CncController* cnc) { m_cnc = cnc; }
    void renderStepSizeSelector();
    void renderJogButtons();       // Currently XY cross + Z up/down
    void renderHomingSection();
    void jogAxis(int axis, float direction);

    static constexpr float STEP_SIZES[] = {0.01f, 0.1f, 1.0f, 10.0f, 100.0f};
    int m_selectedStep = 2; // Default to 1mm
};
```

From src/core/cnc/cnc_controller.h:
```cpp
class CncController {
    void sendCommand(const std::string& cmd); // Queue arbitrary G-code
    bool isStreaming() const;
};
```

From src/core/cnc/cnc_types.h:
```cpp
struct MachineStatus {
    MachineState state;
    Vec3 machinePos{0.0f};
    Vec3 workPos{0.0f};
    f32 feedRate = 0.0f;
    // ...
};
```

DRO rendering in cnc_status_panel.cpp currently:
```cpp
void CncStatusPanel::renderDRO() {
    ImGui::SeparatorText("Position");
    static const char* axisNames[] = {"X", "Y", "Z"};
    // Large work position display (SetWindowFontScale 2.0f)
    for (int i = 0; i < 3; ++i) {
        ImGui::TextColored(axisColors[i], "%s", axisNames[i]);
        ImGui::SameLine();
        ImGui::Text("%+10.3f", static_cast<double>(workPos[i]));
    }
    // Machine position below
}
```

Jog buttons in cnc_jog_panel.cpp:
```cpp
void CncJogPanel::renderJogButtons() {
    // Cross pattern: Y+ top, X-/X+ middle row, Y- bottom
    // Then Z+/Z- side by side below separator
    // Uses jogButton lambda calling jogAxis(axis, dir)
    // Button size = 48x48, centered in available width
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: DRO click-to-zero and move-to dialog in CncStatusPanel</name>
  <files>
    src/ui/panels/cnc_status_panel.h
    src/ui/panels/cnc_status_panel.cpp
  </files>
  <action>
**DRO click-to-zero (NIC-01):**

Modify `renderDRO()` to make each axis value clickable. Replace the plain `ImGui::Text("%+10.3f", ...)` with an `ImGui::Selectable` or `ImGui::InvisibleButton` overlaid on the text so double-click is detectable.

For each axis (i=0,1,2), after rendering the axis label and value text:

```cpp
// Render the work position value as a selectable for click interaction
char posLabel[32];
std::snprintf(posLabel, sizeof(posLabel), "%+10.3f##DRO%d", static_cast<double>(workPos[i]), i);
ImGui::SetWindowFontScale(2.0f);
if (ImGui::Selectable(posLabel, false, ImGuiSelectableFlags_AllowDoubleClick, ImVec2(0, 0))) {
    if (ImGui::IsMouseDoubleClicked(0)) {
        // Zero this axis: G10 L20 P0 Xn0 (where n is axis letter)
        if (m_cnc && m_connected && m_status.state == MachineState::Idle) {
            char cmd[64];
            static const char axisLetters[] = {'X', 'Y', 'Z'};
            std::snprintf(cmd, sizeof(cmd), "G10 L20 P0 %c0", axisLetters[i]);
            m_cnc->sendCommand(cmd);
        }
    }
}
ImGui::SetWindowFontScale(1.0f);
if (ImGui::IsItemHovered()) {
    ImGui::SetTooltip("Double-click to zero %s axis", axisNames[i]);
}
```

Important: The DRO currently uses `ImGui::SetWindowFontScale(2.0f)` for large digits. The Selectable must be rendered at the same scale. Keep the existing colored axis label (`ImGui::TextColored(...)`) separate, then use `ImGui::SameLine()` before the Selectable value.

The full renderDRO() replacement should preserve the existing layout (colored axis labels, large font work position, small machine position below) but make the work position values interactive. Ensure the `ImGuiStyleVar_ItemSpacing` push/pop is maintained.

**Move-To dialog (NIC-02):**

1. In cnc_status_panel.h, add members for the move-to dialog:
```cpp
private:
    void renderMoveToDialog();
    bool m_moveToOpen = false;
    float m_moveToX = 0.0f;
    float m_moveToY = 0.0f;
    float m_moveToZ = 0.0f;
    bool m_moveToUseG0 = true; // true=G0 rapid, false=G1 feed move
```

2. Add a "Move To" button below the machine position in renderDRO():
```cpp
// After machine position display
bool canMove = m_cnc && m_connected && m_status.state == MachineState::Idle;
if (!canMove) ImGui::BeginDisabled();
if (ImGui::SmallButton("Move To...")) {
    m_moveToX = m_status.workPos.x;
    m_moveToY = m_status.workPos.y;
    m_moveToZ = m_status.workPos.z;
    m_moveToOpen = true;
}
if (!canMove) ImGui::EndDisabled();
if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled)) {
    ImGui::SetTooltip("Move machine to specific coordinates");
}
```

3. Implement renderMoveToDialog() as an ImGui popup modal:
```cpp
void CncStatusPanel::renderMoveToDialog() {
    if (!m_moveToOpen) return;

    ImGui::OpenPopup("Move To Position");
    m_moveToOpen = false; // Only open once, popup manages itself

    // Note: actual popup rendering below
}
```

Actually, use the standard ImGui::BeginPopupModal pattern. In render(), after ImGui::End() check... No, the popup must be rendered within the same window context. Add the popup rendering at the end of render(), before ImGui::End():

```cpp
// In render(), before ImGui::End():
if (m_moveToOpen) {
    ImGui::OpenPopup("Move To Position");
    m_moveToOpen = false;
}
if (ImGui::BeginPopupModal("Move To Position", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
    ImGui::Text("Enter target work coordinates:");
    ImGui::Spacing();

    ImGui::SetNextItemWidth(120);
    ImGui::InputFloat("X##moveto", &m_moveToX, 0.1f, 1.0f, "%.3f");
    ImGui::SetNextItemWidth(120);
    ImGui::InputFloat("Y##moveto", &m_moveToY, 0.1f, 1.0f, "%.3f");
    ImGui::SetNextItemWidth(120);
    ImGui::InputFloat("Z##moveto", &m_moveToZ, 0.1f, 1.0f, "%.3f");

    ImGui::Spacing();
    ImGui::Checkbox("Rapid (G0)", &m_moveToUseG0);
    if (!m_moveToUseG0) {
        ImGui::SameLine();
        ImGui::TextDisabled("(uses current feed rate)");
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    bool canGo = m_cnc && m_connected && m_status.state == MachineState::Idle;
    if (!canGo) ImGui::BeginDisabled();
    if (ImGui::Button("Go", ImVec2(80, 0))) {
        char cmd[128];
        const char* moveCmd = m_moveToUseG0 ? "G0" : "G1";
        std::snprintf(cmd, sizeof(cmd), "G90 %s X%.3f Y%.3f Z%.3f",
                      moveCmd,
                      static_cast<double>(m_moveToX),
                      static_cast<double>(m_moveToY),
                      static_cast<double>(m_moveToZ));
        m_cnc->sendCommand(cmd);
        ImGui::CloseCurrentPopup();
    }
    if (!canGo) ImGui::EndDisabled();
    ImGui::SameLine();
    if (ImGui::Button("Cancel", ImVec2(80, 0))) {
        ImGui::CloseCurrentPopup();
    }
    ImGui::EndPopup();
}
```
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Double-clicking a DRO axis value sends G10 L20 P0 to zero that axis
- Tooltip on DRO values indicates double-click-to-zero functionality
- Move To button opens modal dialog with XYZ coordinate inputs
- Dialog pre-fills with current work position
- Go button sends G0 (or G1 if unchecked) to target coordinates
- Controls are disabled when not connected or not in Idle state
  </done>
</task>

<task type="auto">
  <name>Task 2: Diagonal XY jog buttons in CncJogPanel</name>
  <files>
    src/ui/panels/cnc_jog_panel.h
    src/ui/panels/cnc_jog_panel.cpp
  </files>
  <action>
**Diagonal jog buttons (NIC-03):**

Add four diagonal jog buttons to the existing XY cross layout. The diagonal buttons go in the corners of the 3x3 grid that currently has Y+ at top, X-/X+ on sides, Y- at bottom.

1. In cnc_jog_panel.h, add a private method:
```cpp
void jogDiagonal(float xDir, float yDir);
```

2. In cnc_jog_panel.cpp, implement `jogDiagonal()`:
```cpp
void CncJogPanel::jogDiagonal(float xDir, float yDir) {
    if (!m_cnc) return;

    float step = STEP_SIZES[m_selectedStep];
    float xStep = step * xDir;
    float yStep = step * yDir;

    // Per-step-group feedrate from Config (same logic as jogAxis)
    auto& cfg = Config::instance();
    float feed;
    if (m_selectedStep <= 1) {
        feed = static_cast<float>(cfg.getJogFeedSmall());
    } else if (m_selectedStep == 2) {
        feed = static_cast<float>(cfg.getJogFeedMedium());
    } else {
        feed = static_cast<float>(cfg.getJogFeedLarge());
    }

    char cmd[128];
    std::snprintf(cmd, sizeof(cmd), "$J=G91 G21 X%.3f Y%.3f F%.0f",
                  static_cast<double>(xStep), static_cast<double>(yStep),
                  static_cast<double>(feed));
    m_cnc->sendCommand(cmd);
}
```

3. Modify `renderJogButtons()` to add diagonal buttons in the corners of the cross layout. The current layout is a 3x3 grid with only the cross positions filled. Add diagonal buttons in the four corner cells:

The current layout with buttonSize=48:
```
Row 1:  [empty]  [Y+]   [empty]
Row 2:  [X-]     [empty] [X+]
Row 3:  [empty]  [Y-]   [empty]
```

New layout:
```
Row 1:  [-X+Y]   [Y+]   [+X+Y]
Row 2:  [X-]     [empty] [X+]
Row 3:  [-X-Y]   [Y-]   [+X-Y]
```

Modify the renderJogButtons() function. Replace the current row rendering with the full 3x3 grid:

```cpp
void CncJogPanel::renderJogButtons() {
    ImGui::SeparatorText("Jog");

    bool canJog = m_cnc && (m_status.state == MachineState::Idle ||
                            m_status.state == MachineState::Jog);

    ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 12));
    float buttonSize = 48.0f;

    auto jogButton = [&](const char* label, int axis, float dir) {
        if (!canJog) ImGui::BeginDisabled();
        if (ImGui::Button(label, ImVec2(buttonSize, buttonSize))) {
            jogAxis(axis, dir);
        }
        if (!canJog) ImGui::EndDisabled();
    };

    auto diagButton = [&](const char* label, float xDir, float yDir) {
        if (!canJog) ImGui::BeginDisabled();
        if (ImGui::Button(label, ImVec2(buttonSize, buttonSize))) {
            jogDiagonal(xDir, yDir);
        }
        if (!canJog) ImGui::EndDisabled();
    };

    float availWidth = ImGui::GetContentRegionAvail().x;
    float crossWidth = buttonSize * 3 + ImGui::GetStyle().ItemSpacing.x * 2;
    float offsetX = (availWidth - crossWidth) * 0.5f;
    if (offsetX < 0) offsetX = 0;

    // Row 1: -X+Y, Y+, +X+Y
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + offsetX);
    diagButton("\\##NW", -1.0f, +1.0f);  // NW diagonal: -X, +Y
    ImGui::SameLine();
    jogButton("Y+", 1, +1.0f);
    ImGui::SameLine();
    diagButton("/##NE", +1.0f, +1.0f);   // NE diagonal: +X, +Y

    // Row 2: X-, [gap], X+
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + offsetX);
    jogButton("X-", 0, -1.0f);
    ImGui::SameLine();
    ImGui::Dummy(ImVec2(buttonSize, buttonSize));
    ImGui::SameLine();
    jogButton("X+", 0, +1.0f);

    // Row 3: -X-Y, Y-, +X-Y
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + offsetX);
    diagButton("/##SW", -1.0f, -1.0f);   // SW diagonal: -X, -Y
    ImGui::SameLine();
    jogButton("Y-", 1, -1.0f);
    ImGui::SameLine();
    diagButton("\\##SE", +1.0f, -1.0f);  // SE diagonal: +X, -Y

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    // Z axis — side by side (unchanged)
    float zGroupWidth = buttonSize * 2 + ImGui::GetStyle().ItemSpacing.x;
    float zOffsetX = (availWidth - zGroupWidth) * 0.5f;
    if (zOffsetX < 0) zOffsetX = 0;

    ImGui::TextDisabled("Z Axis");
    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + zOffsetX);
    jogButton("Z+", 2, +1.0f);
    ImGui::SameLine();
    jogButton("Z-", 2, -1.0f);

    ImGui::PopStyleVar(); // FramePadding
}
```

Use diagonal slash/backslash characters as button labels to visually indicate diagonal direction. The `##NW` etc. suffixes make ImGui IDs unique.

Add tooltips to the diagonal buttons so operators know what direction they move:
- After each diagButton call, add: `if (ImGui::IsItemHovered()) ImGui::SetTooltip("-X +Y");` (with appropriate directions).

Alternatively, use arrow-like Unicode or just use compact labels like "-X+Y" if the button size allows. Given 48x48 buttons, short labels like the slash characters are more visually clean. Add tooltips for clarity.
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Four diagonal jog buttons appear in the corners of the XY jog grid
- Each diagonal button sends a combined $J command with both X and Y axis components
- Diagonal jog uses the same per-step-group feedrate as single-axis jog
- Buttons are disabled when machine is not in Idle or Jog state
- Tooltips show the direction (e.g. "-X +Y") on hover
  </done>
</task>

</tasks>

<verification>
- cmake --build build -j$(nproc) — builds without errors
- ctest --test-dir build --output-on-failure — all existing tests pass
</verification>

<success_criteria>
- Double-clicking DRO axis value sends G10 L20 P0 to zero that axis
- Move-To dialog accepts XYZ coordinates and sends G0/G1 move command
- Four diagonal jog buttons send combined XY jog commands
- All controls respect machine state (disabled when not Idle)
- All controls require CNC connection to be active
</success_criteria>

<output>
After completion, create `.planning/phases/11-niceties/11-01-SUMMARY.md`
</output>
