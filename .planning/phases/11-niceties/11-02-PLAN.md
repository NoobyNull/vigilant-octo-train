---
phase: 11-niceties
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ui/panels/cnc_console_panel.h
  - src/ui/panels/cnc_console_panel.cpp
  - src/ui/panels/cnc_macro_panel.h
  - src/ui/panels/cnc_macro_panel.cpp
autonomous: true
requirements:
  - NIC-04
  - NIC-07

must_haves:
  truths:
    - "Console messages are visually tagged by source type ([JOB], [MDI], [MACRO], [SYS]) with distinct colors for each"
    - "Macro list supports drag-and-drop reordering with sort_order persisted to the database"
  artifacts:
    - path: "src/ui/panels/cnc_console_panel.h"
      provides: "MessageSource enum and tagged ConsoleLine type"
      contains: "MessageSource"
    - path: "src/ui/panels/cnc_console_panel.cpp"
      provides: "Color-coded source tags in console output rendering"
      contains: "JOB"
    - path: "src/ui/panels/cnc_macro_panel.cpp"
      provides: "ImGui drag-and-drop reorder for macro list items"
      contains: "DragDropTarget"
  key_links:
    - from: "src/ui/panels/cnc_console_panel.cpp"
      to: "src/ui/panels/cnc_console_panel.h"
      via: "ConsoleLine::source field determines prefix and color"
      pattern: "source"
    - from: "src/ui/panels/cnc_macro_panel.cpp"
      to: "src/core/cnc/macro_manager.h"
      via: "MacroManager::reorder() persists new sort_order"
      pattern: "reorder"
---

<objective>
Add source-type tags to console messages and drag-and-drop reordering to the macro list.

Purpose: Improve console readability by visually distinguishing message origins (job streaming, MDI commands, macros, system events), and allow operators to organize macros via intuitive drag-and-drop instead of up/down buttons.
Output: Color-coded tagged console output, drag-and-drop macro reordering.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/ui/panels/cnc_console_panel.h
@src/ui/panels/cnc_console_panel.cpp
@src/ui/panels/cnc_macro_panel.h
@src/ui/panels/cnc_macro_panel.cpp
@src/core/cnc/macro_manager.h

<interfaces>
From src/ui/panels/cnc_console_panel.h:
```cpp
class CncConsolePanel : public Panel {
    void onRawLine(const std::string& line, bool isSent);
    void onError(const std::string& message);
    void onAlarm(int code, const std::string& desc);

    struct ConsoleLine {
        std::string text;
        enum Type { Sent, Received, Error, Info } type;
    };
    std::deque<ConsoleLine> m_lines;
    static constexpr size_t MAX_LINES = 500;
};
```

Current console line rendering (cnc_console_panel.cpp):
```cpp
for (const auto& line : m_lines) {
    ImVec4 color;
    const char* prefix = "";
    switch (line.type) {
    case ConsoleLine::Sent:     color = cyan;   prefix = "> "; break;
    case ConsoleLine::Received: color = white;  break;
    case ConsoleLine::Error:    color = red;    break;
    case ConsoleLine::Info:     color = yellow; break;
    }
    ImGui::TextColored(color, "%s%s", prefix, line.text.c_str());
}
```

From src/ui/panels/cnc_macro_panel.h:
```cpp
class CncMacroPanel : public Panel {
    void renderMacroList();
    void executeMacro(const Macro& macro);
    std::vector<Macro> m_macros;
    bool m_needsRefresh = true;
    MacroManager* m_macroManager = nullptr;
};
```

Current macro list rendering has up/down arrow buttons for reordering:
```cpp
if (ImGui::SmallButton(Icons::ArrowUp)) {
    std::vector<int> ids;
    for (const auto& m : m_macros) ids.push_back(m.id);
    std::swap(ids[i], ids[i - 1]);
    m_macroManager->reorder(ids);
    m_needsRefresh = true;
}
```

From src/core/cnc/macro_manager.h:
```cpp
struct Macro {
    int id = -1;
    std::string name;
    std::string gcode;
    std::string shortcut;
    int sortOrder = 0;
    bool builtIn = false;
};

class MacroManager {
    void reorder(const std::vector<int>& ids); // Already exists
};
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Console message source tags with distinct colors</name>
  <files>
    src/ui/panels/cnc_console_panel.h
    src/ui/panels/cnc_console_panel.cpp
  </files>
  <action>
**Console source tags (NIC-04):**

The goal is to tag each console line with a source identifier so operators can quickly see where a message came from.

1. In cnc_console_panel.h, add a `MessageSource` enum and update the `ConsoleLine` struct:

```cpp
// Source of a console message
enum class MessageSource { MDI, JOB, MACRO, SYS };

struct ConsoleLine {
    std::string text;
    enum Type { Sent, Received, Error, Info } type;
    MessageSource source = MessageSource::SYS;
};
```

2. Add a new public method to accept source-tagged lines:
```cpp
void addLine(const std::string& text, ConsoleLine::Type type, MessageSource source);
```

3. Add a private method to get the source tag prefix and color:
```cpp
// In anonymous namespace in .cpp:
static const char* sourceTag(MessageSource source) {
    switch (source) {
    case MessageSource::JOB:   return "[JOB] ";
    case MessageSource::MDI:   return "[MDI] ";
    case MessageSource::MACRO: return "[MACRO] ";
    case MessageSource::SYS:   return "[SYS] ";
    }
    return "";
}

static ImVec4 sourceColor(MessageSource source) {
    switch (source) {
    case MessageSource::JOB:   return ImVec4(0.3f, 0.7f, 1.0f, 1.0f);   // Blue
    case MessageSource::MDI:   return ImVec4(0.4f, 0.8f, 1.0f, 1.0f);   // Cyan
    case MessageSource::MACRO: return ImVec4(0.8f, 0.6f, 1.0f, 1.0f);   // Purple
    case MessageSource::SYS:   return ImVec4(1.0f, 0.8f, 0.2f, 1.0f);   // Yellow
    }
    return ImVec4(1.0f, 1.0f, 1.0f, 1.0f);
}
```

4. Implement `addLine()`:
```cpp
void CncConsolePanel::addLine(const std::string& text, ConsoleLine::Type type, MessageSource source) {
    ConsoleLine cl;
    cl.text = text;
    cl.type = type;
    cl.source = source;
    m_lines.push_back(std::move(cl));
    if (m_lines.size() > MAX_LINES)
        m_lines.pop_front();
    m_scrollToBottom = true;
}
```

5. Update existing callbacks to set source:

- `onRawLine()`: When `isSent` and the command came from user input (MDI), use `MessageSource::MDI`. For received lines, use `MessageSource::SYS`. Since we can't distinguish job vs MDI from raw lines alone, default sent lines to `MDI` and received to `SYS`:
  ```cpp
  cl.source = isSent ? MessageSource::MDI : MessageSource::SYS;
  ```

- `onError()`: Use `MessageSource::SYS`.
- `onAlarm()`: Use `MessageSource::SYS`.
- `onConnectionChanged()`: Use `MessageSource::SYS`.

6. Update the render loop in `render()` to display the source tag before the message text. Render the tag in the source color, then the message in the type color:

```cpp
for (const auto& line : m_lines) {
    // Source tag in source-specific color
    ImVec4 tagColor = sourceColor(line.source);
    ImGui::TextColored(tagColor, "%s", sourceTag(line.source));
    ImGui::SameLine(0, 0); // No gap between tag and text

    // Message text in type-specific color
    ImVec4 color;
    const char* prefix = "";
    switch (line.type) {
    case ConsoleLine::Sent:     color = ImVec4(0.4f, 0.8f, 1.0f, 1.0f); prefix = "> "; break;
    case ConsoleLine::Received: color = ImVec4(0.9f, 0.9f, 0.9f, 1.0f); break;
    case ConsoleLine::Error:    color = ImVec4(1.0f, 0.3f, 0.3f, 1.0f); break;
    case ConsoleLine::Info:     color = ImVec4(1.0f, 0.8f, 0.2f, 1.0f); break;
    }
    ImGui::TextColored(color, "%s%s", prefix, line.text.c_str());
}
```

7. The console panel also needs to be callable with source from the wiring code. However, wiring code changes are NOT in this plan (different files). For now, all existing callbacks default to appropriate sources. The `addLine()` public method enables future wiring to specify source explicitly (e.g., `MessageSource::JOB` from streaming callbacks, `MessageSource::MACRO` from macro execution). Document this in a comment:

```cpp
// NOTE: Application wiring can call addLine() with explicit source to tag
// JOB (streaming) and MACRO (macro execution) messages. Current callbacks
// default: sent=MDI, received/error/alarm/connection=SYS.
```
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Console lines display source tags: [JOB], [MDI], [MACRO], [SYS]
- Each source tag has a distinct color (blue, cyan, purple, yellow)
- Source tag appears before the message text on the same line
- Existing message type colors (sent, received, error, info) are preserved
- Public addLine() method accepts explicit MessageSource for external callers
  </done>
</task>

<task type="auto">
  <name>Task 2: Drag-and-drop macro reordering in CncMacroPanel</name>
  <files>
    src/ui/panels/cnc_macro_panel.h
    src/ui/panels/cnc_macro_panel.cpp
  </files>
  <action>
**Drag-and-drop macro reordering (NIC-07):**

Replace the up/down arrow buttons with ImGui drag-and-drop reordering. The existing `MacroManager::reorder()` method already handles persisting the new order.

1. In cnc_macro_panel.h, add a drag state member:
```cpp
int m_dragSourceIdx = -1; // Index of macro being dragged
```

2. In cnc_macro_panel.cpp, modify `renderMacroList()`. Replace the entire up/down button section with drag-and-drop:

For each macro in the list, wrap the row in a drag source/target pair. The ImGui drag-and-drop API works like this:
- Each item is both a potential drag source and a drop target
- When dragging starts, store the source index
- When dropping on a target, reorder the vector and call `reorder()`

Replace the macro list loop. For each macro `i`:

```cpp
for (size_t i = 0; i < m_macros.size(); ++i) {
    auto& macro = m_macros[i];
    ImGui::PushID(macro.id);

    // Drag handle — the entire row is draggable
    // Use a small drag indicator on the left
    ImGui::TextDisabled("%s", Icons::Grip);  // Or use "=" as grip handle
    if (ImGui::BeginDragDropSource(ImGuiDragDropFlags_SourceAllowNullID)) {
        m_dragSourceIdx = static_cast<int>(i);
        ImGui::SetDragDropPayload("MACRO_REORDER", &m_dragSourceIdx, sizeof(int));
        ImGui::Text("Move: %s", macro.name.c_str());
        ImGui::EndDragDropSource();
    }

    // Drop target — reorder when dropped
    if (ImGui::BeginDragDropTarget()) {
        if (const ImGuiPayload* payload = ImGui::AcceptDragDropPayload("MACRO_REORDER")) {
            int srcIdx = *static_cast<const int*>(payload->Data);
            int dstIdx = static_cast<int>(i);
            if (srcIdx != dstIdx && srcIdx >= 0 && srcIdx < static_cast<int>(m_macros.size())) {
                // Move the macro from srcIdx to dstIdx
                // Build new ID order
                std::vector<int> ids;
                for (const auto& m : m_macros) ids.push_back(m.id);
                int movedId = ids[srcIdx];
                ids.erase(ids.begin() + srcIdx);
                ids.insert(ids.begin() + dstIdx, movedId);
                m_macroManager->reorder(ids);
                m_needsRefresh = true;
            }
        }
        ImGui::EndDragDropTarget();
    }

    ImGui::SameLine();

    // Run button (unchanged)
    if (!canRun) ImGui::BeginDisabled();
    if (ImGui::SmallButton(Icons::Play)) {
        executeMacro(macro);
    }
    if (!canRun) ImGui::EndDisabled();
    // ... (existing tooltip logic)

    ImGui::SameLine();

    // Macro name (unchanged)
    if (macro.builtIn) {
        ImGui::TextDisabled("%s", Icons::Settings);
        ImGui::SameLine();
    }
    ImGui::Text("%s", macro.name.c_str());

    // Shortcut hint (unchanged)
    if (!macro.shortcut.empty()) {
        ImGui::SameLine();
        ImGui::TextDisabled("(%s)", macro.shortcut.c_str());
    }

    // Edit button (unchanged)
    ImGui::SameLine(ImGui::GetContentRegionAvail().x - 50);
    if (ImGui::SmallButton("Edit")) {
        // ... existing edit logic
    }

    // Delete button (unchanged)
    if (!macro.builtIn) {
        ImGui::SameLine();
        // ... existing delete logic
    }

    // REMOVE the old up/down arrow buttons entirely

    ImGui::PopID();
}
```

Check if the Icons namespace has a grip/drag handle icon. Search for available icons. If no grip icon exists, use a simple "≡" text or ImGui::TextDisabled("::") as the drag handle. Keep it minimal.

**Important:** The `ImGui::BeginDragDropSource()` call must be placed right after the drag handle widget (the grip text/button). The `ImGui::BeginDragDropTarget()` must be placed right after the same widget to define the drop zone. Use `ImGuiDragDropFlags_SourceAllowNullID` since we're using TextDisabled which doesn't have a built-in ID for drag.

Alternative approach if TextDisabled doesn't work as a drag source (it might not since it's not interactive): Use an `ImGui::InvisibleButton` as the drag handle, or use `ImGui::Selectable` with the macro name as the draggable item. The Selectable approach is cleaner:

```cpp
// Use Selectable for the entire row to make it draggable
char selectLabel[256];
std::snprintf(selectLabel, sizeof(selectLabel), "%s%s%s",
              macro.builtIn ? Icons::Settings " " : "",
              macro.name.c_str(),
              macro.shortcut.empty() ? "" : "");
if (ImGui::Selectable(selectLabel, false, ImGuiSelectableFlags_None)) {
    // Click to edit? Or leave edit button separate
}

// Drag source on the selectable
if (ImGui::BeginDragDropSource()) {
    // ...
}
// Drop target on the selectable
if (ImGui::BeginDragDropTarget()) {
    // ...
}
```

Choose whichever approach compiles cleanly. The key requirement is: the user can drag a macro row up or down in the list, and after dropping, `m_macroManager->reorder(newOrder)` is called to persist the change.
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- Macro list items are draggable for reordering
- Dropping a macro at a new position reorders the list
- sort_order is persisted to the database via MacroManager::reorder()
- Old up/down arrow buttons are removed
- All other macro list functionality (run, edit, delete) is preserved
  </done>
</task>

</tasks>

<verification>
- cmake --build build -j$(nproc) — builds without errors
- ctest --test-dir build --output-on-failure — all existing tests pass
</verification>

<success_criteria>
- Console messages display [JOB], [MDI], [MACRO], [SYS] source tags with distinct colors
- Macros can be reordered via drag-and-drop
- Macro reorder persists to database
- No regressions in existing console or macro functionality
</success_criteria>

<output>
After completion, create `.planning/phases/11-niceties/11-02-SUMMARY.md`
</output>
