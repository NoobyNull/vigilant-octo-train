---
phase: 02-status-display
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/managers/ui_manager.h
  - src/managers/ui_manager.cpp
  - src/app/application_wiring.cpp
  - CMakeLists.txt
autonomous: true
requirements: [CUI-01, CUI-02, CUI-03]

must_haves:
  truths:
    - "CNC Status panel appears in the View menu and can be toggled"
    - "CNC Status panel receives live MachineStatus updates from CncController"
    - "CNC Status panel receives connection/disconnection events"
    - "Workspace mode can be switched between Model and CNC"
    - "CNC mode shows CNC Status and G-Code panels, hides Library/Materials"
    - "Model mode restores Library/Properties panels"
  artifacts:
    - path: "src/managers/ui_manager.h"
      provides: "CncStatusPanel ownership, workspace mode enum and setter"
      contains: "CncStatusPanel"
    - path: "src/managers/ui_manager.cpp"
      provides: "CncStatusPanel creation and workspace mode implementation"
      contains: "m_cncStatusPanel"
    - path: "src/app/application_wiring.cpp"
      provides: "CNC callback fan-out to both GCodePanel and CncStatusPanel"
      contains: "csp->onStatusUpdate"
  key_links:
    - from: "src/app/application_wiring.cpp"
      to: "src/ui/panels/cnc_status_panel.h"
      via: "CNC callback wiring"
      pattern: "cncStatusPanel"
    - from: "src/managers/ui_manager.h"
      to: "src/ui/panels/cnc_status_panel.h"
      via: "unique_ptr ownership"
      pattern: "unique_ptr<CncStatusPanel>"
---

<objective>
Wire CncStatusPanel into the application: register it in UIManager, connect it to CncController callbacks, add workspace mode switching, and update the build system.

Purpose: The panel from Plan 01 needs to receive live data and be visible in the application. This plan connects it to the existing CNC infrastructure and adds the workspace mode concept from CONTEXT.md.
Output: CncStatusPanel appears in the running application, receives live CNC updates, and workspace mode toggles panel visibility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-status-display/02-RESEARCH.md
@.planning/phases/02-status-display/02-CONTEXT.md
@.planning/phases/02-status-display/02-01-SUMMARY.md
@src/managers/ui_manager.h
@src/managers/ui_manager.cpp
@src/app/application_wiring.cpp
@src/ui/panels/cnc_status_panel.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register CncStatusPanel in UIManager and add workspace mode</name>
  <files>src/managers/ui_manager.h, src/managers/ui_manager.cpp</files>
  <action>
**In `ui_manager.h`:**

1. Add forward declaration: `class CncStatusPanel;`
2. Add workspace mode enum before the class:
```cpp
enum class WorkspaceMode { Model, CNC };
```
3. Add private members:
   - `std::unique_ptr<CncStatusPanel> m_cncStatusPanel;`
   - `bool m_showCncStatus = false;`
   - `WorkspaceMode m_workspaceMode = WorkspaceMode::Model;`
4. Add public accessors:
   - `CncStatusPanel* cncStatusPanel() { return m_cncStatusPanel.get(); }`
   - `bool& showCncStatus() { return m_showCncStatus; }`
   - `WorkspaceMode workspaceMode() const { return m_workspaceMode; }`
   - `void setWorkspaceMode(WorkspaceMode mode);`

**In `ui_manager.cpp`:**

1. Add include: `#include "ui/panels/cnc_status_panel.h"`
2. In `init()`: Create the panel: `m_cncStatusPanel = std::make_unique<CncStatusPanel>();`
3. In `renderPanels()`: Add rendering block (follow existing pattern):
   ```cpp
   if (m_showCncStatus && m_cncStatusPanel) {
       m_cncStatusPanel->render();
       m_showCncStatus = m_cncStatusPanel->isOpen();
   }
   ```
4. In `renderViewMenu()`: Add menu item for CNC Status panel (alongside existing items):
   ```cpp
   ImGui::MenuItem("CNC Status", nullptr, &m_showCncStatus);
   ```
   Also add a separator and workspace mode toggle:
   ```cpp
   ImGui::Separator();
   if (ImGui::MenuItem("Model Mode", "Ctrl+1", m_workspaceMode == WorkspaceMode::Model)) {
       setWorkspaceMode(WorkspaceMode::Model);
   }
   if (ImGui::MenuItem("CNC Mode", "Ctrl+2", m_workspaceMode == WorkspaceMode::CNC)) {
       setWorkspaceMode(WorkspaceMode::CNC);
   }
   ```
5. Implement `setWorkspaceMode()`:
   ```cpp
   void UIManager::setWorkspaceMode(WorkspaceMode mode) {
       m_workspaceMode = mode;
       if (mode == WorkspaceMode::CNC) {
           m_showCncStatus = true;
           m_showGCode = true;
           m_showLibrary = false;
           m_showProperties = false;
           m_showMaterials = false;
           m_showToolBrowser = false;
           m_showCostEstimator = false;
           m_showCutOptimizer = false;
       } else {
           m_showCncStatus = false;
           m_showGCode = false;
           m_showLibrary = true;
           m_showProperties = true;
       }
   }
   ```
6. In `handleKeyboardShortcuts()`: Add Ctrl+1/Ctrl+2 shortcuts for workspace mode switching:
   ```cpp
   if (ImGui::GetIO().KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_1)) setWorkspaceMode(WorkspaceMode::Model);
   if (ImGui::GetIO().KeyCtrl && ImGui::IsKeyPressed(ImGuiKey_2)) setWorkspaceMode(WorkspaceMode::CNC);
   ```
7. In `shutdown()`: Reset: `m_cncStatusPanel.reset();`

**NOTE:** The `m_showCncStatus` visibility flag follows exactly the same pattern as `m_showGCode`, `m_showToolBrowser`, etc. Look at how those are wired and follow identically.
  </action>
  <verify>
Verify UIManager compiles with the new panel and workspace mode:
1. CncStatusPanel accessor exists
2. Workspace mode enum and setter exist
3. Panel renders in renderPanels()
4. Menu items exist in View menu
5. Keyboard shortcuts registered
  </verify>
  <done>UIManager owns and renders CncStatusPanel, supports workspace mode switching via View menu and Ctrl+1/Ctrl+2 shortcuts</done>
</task>

<task type="auto">
  <name>Task 2: Wire CNC callbacks and update build system</name>
  <files>src/app/application_wiring.cpp, CMakeLists.txt</files>
  <action>
**In `application_wiring.cpp`:**

1. Add include: `#include "ui/panels/cnc_status_panel.h"`
2. Find the existing CNC callback wiring block (search for `cncCb.onStatusUpdate`). This is inside the `if (auto* gcp = m_uiManager->gcodePanel())` block.
3. Get the CncStatusPanel pointer: `auto* csp = m_uiManager->cncStatusPanel();`
4. Modify the callback lambdas to fan out to BOTH panels. The key callbacks to update:

   **onConnectionChanged:** Currently calls `gcp->onGrblConnected()`. Add `csp->onConnectionChanged()`:
   ```cpp
   cncCb.onConnectionChanged = [gcp, csp](bool connected, const std::string& version) {
       gcp->onGrblConnected(connected, version);
       if (csp) csp->onConnectionChanged(connected, version);
   };
   ```

   **onStatusUpdate:** Currently calls `gcp->onGrblStatus()`. Add `csp->onStatusUpdate()`:
   ```cpp
   cncCb.onStatusUpdate = [gcp, csp](const MachineStatus& status) {
       gcp->onGrblStatus(status);
       if (csp) csp->onStatusUpdate(status);
   };
   ```

   NOTE: Only these two callbacks need fan-out. The other callbacks (onLineAcked, onProgressUpdate, onAlarm, onError, onRawLine) are streaming/console specific and belong to GCodePanel only. CncStatusPanel gets all the data it needs from onStatusUpdate (which includes feed rate, spindle, state, position).

5. IMPORTANT: Keep all existing callback wiring intact. This is additive only â€” do NOT remove or modify the existing GCodePanel callbacks, just extend the lambdas to also call the CncStatusPanel.

**In `CMakeLists.txt`:**

1. Find the source file list (search for `tool_browser_panel.cpp` to find the right section).
2. Add `src/ui/panels/cnc_status_panel.cpp` to the source list, maintaining alphabetical order within the panels section.

**Build verification:**
After both changes, the project should compile. Run `cmake --build build` (or the project's build command) to verify.
  </action>
  <verify>
1. Build compiles successfully with the new source file
2. CNC callbacks fan out to both GCodePanel and CncStatusPanel
3. Existing GCodePanel callbacks are unchanged (no regression)
4. CncStatusPanel is null-checked before calling (defensive)
  </verify>
  <done>
CncStatusPanel receives live CncController callbacks (connection state and status updates). The build system includes the new source file. The panel appears in the running application and updates in real time when a CNC machine is connected.
  </done>
</task>

</tasks>

<verification>
- [ ] UIManager creates and owns CncStatusPanel
- [ ] CncStatusPanel appears in View menu
- [ ] View menu has Model Mode / CNC Mode items
- [ ] Ctrl+1 switches to Model mode, Ctrl+2 to CNC mode
- [ ] CNC mode shows CNC Status + GCode panels, hides Library/Materials/Properties
- [ ] Model mode restores Library/Properties panels
- [ ] CNC callbacks deliver MachineStatus to CncStatusPanel
- [ ] CNC callbacks deliver connection changes to CncStatusPanel
- [ ] Existing GCodePanel callbacks still work (no regression)
- [ ] CMakeLists.txt includes cnc_status_panel.cpp
- [ ] Project compiles
</verification>

<success_criteria>
The CncStatusPanel is fully integrated into the application. It appears in the View menu, can be toggled, receives live CNC data via callbacks, and participates in workspace mode switching. The operator can press Ctrl+2 to switch to CNC mode and see the status display alongside the G-code panel.
</success_criteria>

<output>
After completion, create `.planning/phases/02-status-display/02-02-SUMMARY.md`
</output>
