# Plan 19-01: On-the-Fly G-code Generation and Streaming Adapter

**Phase**: 19 — Streaming Integration
**Requirements**: DC-26, DC-29

## Overview

Create a streaming adapter that feeds toolpath points to the CncController as G-code commands on-the-fly, using the existing character-counting protocol. Commands are generated from the toolpath buffer without building a complete file in memory.

## New Files

### `src/core/carve/carve_streamer.h` (~80 lines)

```cpp
namespace dw {

class CncController;

namespace carve {

// Streams toolpath to CncController point-by-point.
// Implements the same interface pattern as GcodeStreamer
// but generates G-code from toolpath data on demand.
class CarveStreamer {
public:
    CarveStreamer() = default;

    // Set dependencies
    void setCncController(CncController* cnc);

    // Start streaming a toolpath
    void start(const MultiPassToolpath& toolpath,
               const ToolpathConfig& config);

    // Called by CncController when ready for next line
    // Returns empty string when complete
    std::string nextLine();

    // Job control
    void pause();
    void resume();
    void abort();

    // State
    bool isRunning() const;
    bool isPaused() const;
    bool isComplete() const;

    // Progress
    int currentLine() const;
    int totalLines() const;
    f32 progressFraction() const;  // [0.0, 1.0]

private:
    CncController* m_cnc = nullptr;

    // Toolpath data (copied on start)
    MultiPassToolpath m_toolpath;
    ToolpathConfig m_config;

    // Current position in toolpath
    enum class Pass { Clearing, Finishing, Complete };
    Pass m_currentPass = Pass::Clearing;
    size_t m_pointIndex = 0;
    int m_lineNumber = 0;
    int m_totalLines = 0;

    // State
    std::atomic<bool> m_running{false};
    std::atomic<bool> m_paused{false};
    std::atomic<bool> m_aborted{false};

    // G-code generation helpers
    std::string formatRapid(const Vec3& pos) const;
    std::string formatLinear(const Vec3& pos,
                             f32 feedRate) const;
    std::string preamble() const;
    std::string postamble() const;
};

} // namespace carve
} // namespace dw
```

### `src/core/carve/carve_streamer.cpp` (~200 lines)

**start()**:
1. Copy toolpath and config
2. Set m_currentPass based on whether clearing exists
3. Compute m_totalLines (clearing points + finishing points + preamble/postamble)
4. Set m_running = true, m_pointIndex = 0

**nextLine()** (~35 lines):
1. If first call: return preamble() — `G90 G21\nS{spindle} M3`
2. If m_currentPass == Clearing:
   - Get point from m_toolpath.clearing.points[m_pointIndex]
   - Format as G0 or G1 based on point.rapid flag
   - Increment m_pointIndex
   - If past end: switch to Finishing pass, reset index, add tool change comment
3. If m_currentPass == Finishing:
   - Same as clearing but from m_toolpath.finishing.points
   - If past end: switch to Complete, return postamble() — `G0 Z{safeZ}\nM5\nM30`
4. If Complete: return empty string
5. Increment m_lineNumber

**formatRapid()** (~8 lines):
```cpp
std::string formatRapid(const Vec3& pos) const {
    char buf[64];
    snprintf(buf, sizeof(buf), "G0 X%.3f Y%.3f Z%.3f",
             static_cast<double>(pos.x),
             static_cast<double>(pos.y),
             static_cast<double>(pos.z));
    return buf;
}
```

**formatLinear()** (~10 lines):
- Same format but `G1` with `F{feedRate}` appended
- Only include F when feed rate changes from previous line

**pause()** / **resume()** / **abort()**:
- Set atomic flags
- abort() sends feed hold then soft reset via CncController

### Integration with CncController

The existing CncController::streamLine() / onLineComplete() pattern is used. CarveStreamer acts as a line source similar to how GcodeStreamer provides lines from a loaded file.

### `src/core/carve/carve_job.h` — Add streaming orchestration

```cpp
// Start streaming the generated toolpath
void startStreaming(CncController* cnc);

// Streaming state accessors
CarveStreamer* streamer();
```

### Tests

`src/core/carve/carve_streamer_test.cpp` (~150 lines):

- `TEST(CarveStreamer, PreambleFirst)` — first line contains G90 G21
- `TEST(CarveStreamer, RapidFormat)` — rapid point generates G0 command
- `TEST(CarveStreamer, LinearFormat)` — cut point generates G1 with F
- `TEST(CarveStreamer, FeedRateOptimization)` — F only emitted on change
- `TEST(CarveStreamer, ClearingThenFinishing)` — clearing pass completes before finishing starts
- `TEST(CarveStreamer, PostambleLast)` — final lines contain M5 M30
- `TEST(CarveStreamer, EmptyAfterComplete)` — returns empty after all points consumed
- `TEST(CarveStreamer, ProgressTracking)` — progressFraction increases monotonically
- `TEST(CarveStreamer, AbortStopsStream)` — abort sets complete, stops returning lines

## Coding Standards Compliance

- carve_streamer.cpp ~200 lines (within 800)
- nextLine() under 35 lines with pass-based dispatch
- Format helpers under 10 lines each
- Atomic flags for thread-safe state (CncController IO thread reads, main thread writes)
- No memory allocation during streaming (toolpath copied once at start)
