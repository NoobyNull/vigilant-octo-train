---
phase: 02-import-pipeline
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/loaders/gcode_loader.h
  - src/core/loaders/gcode_loader.cpp
  - src/core/loaders/loader_factory.h
  - src/core/loaders/loader_factory.cpp
  - src/core/import/file_handler.h
  - src/core/import/file_handler.cpp
autonomous: true

must_haves:
  truths:
    - "G-code files (.gcode, .nc, .ngc) are recognized as importable formats"
    - "G-code files produce toolpath geometry (line segments as mesh) on import"
    - "G-code metadata (bounds, distance, time, feed rates, tools) is extracted during loading"
    - "Files can be copied or moved to a managed library directory after import"
  artifacts:
    - path: "src/core/loaders/gcode_loader.h"
      provides: "MeshLoader implementation for G-code files with metadata extraction"
      contains: "class GCodeLoader"
    - path: "src/core/import/file_handler.h"
      provides: "File copy/move/leave-in-place operations"
      contains: "class FileHandler"
    - path: "src/core/loaders/loader_factory.cpp"
      provides: "G-code extension registration"
      contains: "gcode"
  key_links:
    - from: "src/core/loaders/gcode_loader.h"
      to: "src/core/gcode/gcode_parser.h"
      via: "GCodeLoader uses Parser to parse G-code content"
      pattern: "gcode::Parser"
    - from: "src/core/loaders/gcode_loader.h"
      to: "src/core/gcode/gcode_analyzer.h"
      via: "GCodeLoader uses Analyzer for metadata extraction"
      pattern: "gcode::Analyzer"
    - from: "src/core/loaders/loader_factory.cpp"
      to: "src/core/loaders/gcode_loader.h"
      via: "Factory creates GCodeLoader for .gcode/.nc/.ngc extensions"
      pattern: "GCodeLoader"
---

<objective>
Create G-code loader (integrates with existing LoaderFactory) and file handler for copy/move/leave-in-place modes.

Purpose: G-code files must be importable through the same pipeline as mesh files. The GCodeLoader parses G-code, extracts metadata, and converts toolpath to mesh geometry for viewport rendering. FileHandler manages post-import file placement.

Output: GCodeLoader registered in LoaderFactory for .gcode/.nc/.ngc, FileHandler with three file modes, toolpath-to-mesh conversion.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-import-pipeline/02-CONTEXT.md
@.planning/phases/02-import-pipeline/02-RESEARCH.md
@src/core/loaders/loader.h
@src/core/loaders/loader_factory.h
@src/core/loaders/loader_factory.cpp
@src/core/gcode/gcode_parser.h
@src/core/gcode/gcode_types.h
@src/core/gcode/gcode_analyzer.h
@src/core/mesh/mesh.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement GCodeLoader with toolpath-to-mesh conversion and metadata</name>
  <files>
    src/core/loaders/gcode_loader.h
    src/core/loaders/gcode_loader.cpp
    src/core/loaders/loader_factory.h
    src/core/loaders/loader_factory.cpp
  </files>
  <action>
**GCodeLoader class (gcode_loader.h):**
Extend `MeshLoader` interface. Also hold extracted metadata for the import pipeline to access.

```cpp
struct GCodeMetadata {
    Vec3 boundsMin;
    Vec3 boundsMax;
    f32 totalDistance = 0.0f;
    f32 estimatedTime = 0.0f;
    std::vector<f32> feedRates;    // Unique feed rates found
    std::vector<int> toolNumbers;  // Unique tool numbers found
};

class GCodeLoader : public MeshLoader {
public:
    LoadResult load(const Path& path) override;
    LoadResult loadFromBuffer(const ByteBuffer& data) override;
    bool supports(const std::string& extension) const override;
    std::vector<std::string> extensions() const override;

    // Access metadata from last successful load
    const GCodeMetadata& lastMetadata() const { return m_lastMetadata; }

private:
    LoadResult processProgram(const gcode::Program& program);
    MeshPtr toolpathToMesh(const std::vector<gcode::PathSegment>& path);
    GCodeMetadata extractMetadata(const gcode::Program& program, const gcode::Statistics& stats);

    GCodeMetadata m_lastMetadata;
};
```

**Toolpath-to-mesh conversion (toolpathToMesh):**
Per research recommendation: convert lines to degenerate triangles for the existing renderer.

For each PathSegment (start -> end):
- Create a thin extruded quad (two triangles) along the segment direction
- Width: ~0.5mm for cutting moves (G1), ~0.2mm for rapid moves (G0)
- Use the segment's cross-product with an up vector to get the perpendicular direction for extrusion
- Handle degenerate case (vertical segments) by using a fallback perpendicular direction
- Set vertex normals pointing outward from the quad

Color encoding via vertex attributes (per discretion):
- Use vertex normal Y component as a signal: positive = cutting move, negative = rapid move (the viewport shader can differentiate based on this, or we just use different widths for visual distinction)
- Alternatively, store isRapid as a flag in vertex color if mesh supports it. Check Vertex struct — if it has texcoord, encode rapid flag in texcoord.u (0.0 = cutting, 1.0 = rapid)

**Metadata extraction:**
- Use existing `gcode::Analyzer` to get Statistics
- From Statistics: totalPathLength, estimatedTime, boundsMin, boundsMax
- Collect unique feed rates from Commands with hasF()
- Collect unique tool numbers from Commands with hasT()
- Sort and deduplicate both collections

**LoaderFactory registration:**
In `getLoaderByExtension()`, add:
```cpp
if (ext == "gcode" || ext == "nc" || ext == "ngc" || ext == "tap") {
    return std::make_unique<GCodeLoader>();
}
```
In `isSupported()` and `supportedExtensions()`, add the same extensions.

**Important:** The existing parser already handles G90/G91 positioning modes and builds PathSegments. Leverage that — do NOT reimplement path generation. Just convert the parsed path to mesh geometry and extract metadata.
  </action>
  <verify>
Build: `cd /data/DW && cmake --build build --target dw 2>&1 | tail -10` — compiles cleanly. Verify `LoaderFactory::isSupported("gcode")` returns true by checking the implementation.
  </verify>
  <done>
GCodeLoader loads .gcode/.nc/.ngc/.tap files, parses with existing gcode::Parser, converts toolpath segments to mesh geometry (degenerate triangles), extracts metadata (bounds, distance, time, feed rates, tool numbers). LoaderFactory recognizes G-code extensions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement FileHandler for copy/move/leave-in-place modes</name>
  <files>
    src/core/import/file_handler.h
    src/core/import/file_handler.cpp
  </files>
  <action>
**FileHandler class (file_handler.h):**

```cpp
enum class FileHandlingMode { LeaveInPlace = 0, CopyToLibrary = 1, MoveToLibrary = 2 };

class FileHandler {
public:
    // Handle an imported file according to mode.
    // Returns the final file path (original if leave-in-place, new path if copy/move).
    // On error, returns empty path and sets error string.
    static Path handleImportedFile(
        const Path& source,
        FileHandlingMode mode,
        const Path& libraryRoot,
        std::string& error);

    // Ensure library directory exists (creates if needed)
    static bool ensureLibraryDir(const Path& libraryRoot);

    // Get default library directory (appDataDir / "library")
    static Path defaultLibraryDir();

private:
    // Generate unique destination path (avoids overwrite)
    static Path uniqueDestination(const Path& dir, const Path& filename);
};
```

**Implementation (file_handler.cpp):**

1. `handleImportedFile`:
   - If `LeaveInPlace`: return source unchanged
   - If `CopyToLibrary`:
     - `ensureLibraryDir(libraryRoot)`
     - Generate unique dest with `uniqueDestination(libraryRoot, source.filename())`
     - `std::filesystem::copy(source, dest, std::filesystem::copy_options::overwrite_existing)`
     - On error catch `std::filesystem::filesystem_error`, set error string, return empty path
     - Return dest
   - If `MoveToLibrary`:
     - `ensureLibraryDir(libraryRoot)`
     - Generate unique dest
     - Try `std::filesystem::rename(source, dest)` first (atomic, same filesystem)
     - On rename failure (cross-filesystem), fallback: copy, verify size matches, then remove source
     - On error catch exception, set error string, return empty path
     - Return dest

2. `uniqueDestination`:
   - If `dir / filename` does not exist, return it
   - Otherwise try `stem_1.ext`, `stem_2.ext`, etc. until finding unused name
   - Cap at 10000 attempts, return empty on exhaustion

3. `defaultLibraryDir`:
   - Use `dw::paths::appDataDir() / "library"` (check existing paths module for app data directory function)
   - If paths module doesn't have this, use a reasonable default based on platform

4. `ensureLibraryDir`:
   - `std::filesystem::create_directories(libraryRoot)` — creates all intermediate dirs
   - Return true on success, false on error

**Important:** Cross-filesystem move fallback per research Pitfall 4. Use `std::filesystem` throughout (NOT POSIX calls). The code must be cross-platform.
  </action>
  <verify>
Build: `cd /data/DW && cmake --build build --target dw 2>&1 | tail -10` — compiles cleanly. Verify file_handler.cpp is included in CMakeLists.txt build.
  </verify>
  <done>
FileHandler handles all three file modes: leave-in-place (no-op), copy to library (with unique naming), move to library (with cross-filesystem fallback). Error handling returns empty path + error string. Library directory auto-created.
  </done>
</task>

</tasks>

<verification>
1. `cd /data/DW && cmake --build build 2>&1 | grep -i error` — no compilation errors
2. GCodeLoader registered for .gcode, .nc, .ngc, .tap in LoaderFactory
3. Toolpath-to-mesh produces valid Mesh with vertices and indices
4. FileHandler handles all three modes with cross-filesystem move fallback
5. Existing tests pass
</verification>

<success_criteria>
- GCodeLoader parses G-code files and produces mesh geometry from toolpath
- Metadata extracted: bounding box, total distance, estimated time, feed rates, tool numbers
- LoaderFactory::isSupported("gcode") returns true
- FileHandler copy/move/leave-in-place all work correctly
- Cross-filesystem move falls back to copy+delete
- Both compile cleanly with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-pipeline/02-03-SUMMARY.md`
</output>
