---
phase: 02-import-pipeline
plan: 06
type: execute
wave: 3
depends_on: ["02-02", "02-04"]
files_modified:
  - src/core/import/import_queue.cpp
  - src/core/library/library_manager.h
  - src/core/library/library_manager.cpp
  - src/app/application.h
  - src/app/application.cpp
  - src/managers/file_io_manager.h
  - src/managers/file_io_manager.cpp
autonomous: true

must_haves:
  truths:
    - "G-code imports persist to gcode_files table with full metadata"
    - "G-code files appear in library alongside mesh models"
    - "Operation groups can be created for models with template support"
    - "Application wires ImportQueue batch callbacks to UI (status bar, summary, toasts)"
    - "Auto-detect associates G-code with a model on confident single-match"
  artifacts:
    - path: "src/core/library/library_manager.h"
      provides: "G-code library operations alongside mesh operations"
      contains: "GCodeRecord"
    - path: "src/app/application.cpp"
      provides: "Import pipeline fully wired: enqueue -> parallel process -> UI feedback"
      contains: "setOnBatchComplete"
  key_links:
    - from: "src/core/import/import_queue.cpp"
      to: "src/core/database/gcode_repository.h"
      via: "processTask inserts G-code records via GCodeRepository"
      pattern: "GCodeRepository"
    - from: "src/app/application.cpp"
      to: "src/managers/ui_manager.h"
      via: "Application wires batch complete to UIManager summary dialog"
      pattern: "showImportSummary"
    - from: "src/core/library/library_manager.cpp"
      to: "src/core/database/gcode_repository.h"
      via: "LibraryManager delegates G-code CRUD to GCodeRepository"
      pattern: "GCodeRepository"
---

<objective>
Wire G-code imports to database persistence via GCodeRepository, extend LibraryManager for G-code operations, and wire the full import pipeline from Application through to UI feedback.

Purpose: This plan connects the database layer (Plan 02) with the import pipeline (Plan 04) and the UI layer (Plan 05). G-code records persist with metadata, LibraryManager provides unified access, and Application orchestrates the complete flow from file drop to summary dialog.

Output: End-to-end G-code import persisting to DB, LibraryManager G-code API, Application fully wiring import -> UI.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-import-pipeline/02-CONTEXT.md
@.planning/phases/02-import-pipeline/02-02-SUMMARY.md
@.planning/phases/02-import-pipeline/02-04-SUMMARY.md
@src/core/import/import_queue.h
@src/core/import/import_queue.cpp
@src/core/library/library_manager.h
@src/core/library/library_manager.cpp
@src/app/application.h
@src/app/application.cpp
@src/managers/file_io_manager.h
@src/managers/file_io_manager.cpp
@src/core/database/gcode_repository.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend LibraryManager with G-code operations and auto-detect association</name>
  <files>
    src/core/library/library_manager.h
    src/core/library/library_manager.cpp
    src/core/import/import_queue.cpp
  </files>
  <action>
**LibraryManager G-code extensions (library_manager.h/cpp):**

Add G-code methods to LibraryManager alongside existing mesh methods:

```cpp
// G-code operations
std::vector<GCodeRecord> getAllGCodeFiles();
std::optional<GCodeRecord> getGCodeFile(i64 id);
bool deleteGCodeFile(i64 id);

// Hierarchy operations
std::optional<i64> createOperationGroup(i64 modelId, const std::string& name, int sortOrder = 0);
std::vector<OperationGroup> getOperationGroups(i64 modelId);
bool addGCodeToGroup(i64 groupId, i64 gcodeId, int sortOrder = 0);
bool removeGCodeFromGroup(i64 groupId, i64 gcodeId);
std::vector<GCodeRecord> getGroupGCodeFiles(i64 groupId);
bool deleteOperationGroup(i64 groupId);

// Template operations
std::vector<GCodeTemplate> getTemplates();
bool applyTemplate(i64 modelId, const std::string& templateName);

// Auto-detect: try to match G-code filename to model name
std::optional<i64> autoDetectModelMatch(const std::string& gcodeFilename);
```

LibraryManager will need access to GCodeRepository. Add a GCodeRepository member or create it on-demand from the Database reference LibraryManager already holds. Follow whichever pattern LibraryManager uses for ModelRepository.

**Auto-detect filename matching (per user decision: "Auto-detect attempts to match G-code to models by filename"):**
- Strip extension from G-code filename
- Strip common suffixes like "_roughing", "_finishing", "_profile", "_drill", "_contour", etc.
- Search ModelRepository::findByName for the base name
- If exactly ONE match found: return its model ID (confident single match)
- If zero or multiple matches: return nullopt (ambiguous, do not auto-associate)

**ImportQueue G-code persistence with auto-association (import_queue.cpp):**

In `processTask()`, after Stage 5 (Inserting) for G-code files:
- Call autoDetectModelMatch with the G-code filename
- If a confident match is returned (single model found):
  - Auto-associate the G-code file with the matched model by adding it to the model's default operation group
  - If the model has no operation groups yet, create a default "Imported" group (sort_order 0) and add the G-code file to it
  - Log: "Auto-associated [gcode_name] with model [model_name]"
- If no match (nullopt): G-code stays standalone in the library (general G-code area)
  - Log: "No model match for [gcode_name], imported as standalone"

This behavior fulfills the user decision that auto-detect "attempts to match" — it succeeds on confident matches and gracefully falls back to standalone for ambiguous cases. Templates are NOT auto-applied (per user decision: templates are opt-in).

**Important:** The auto-association only adds to a generic "Imported" group. It does NOT apply templates. Templates remain opt-in for the user to apply manually later.
  </action>
  <verify>
Build: `cd /data/DW && cmake --build build --target dw 2>&1 | tail -10` — compiles cleanly.
  </verify>
  <done>
LibraryManager provides G-code CRUD, hierarchy management (operation groups), template application, and auto-detect filename matching. ImportQueue persists G-code records via GCodeRepository with full metadata. On confident single-match auto-detect, G-code is auto-associated with the matched model in a default "Imported" group. Ambiguous/no matches result in standalone import. Templates remain opt-in.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Application import pipeline to UI feedback (status bar, toasts, summary)</name>
  <files>
    src/app/application.h
    src/app/application.cpp
    src/managers/file_io_manager.h
    src/managers/file_io_manager.cpp
  </files>
  <action>
**Application wiring (application.h/cpp):**

In Application::init() or wherever ImportQueue is set up:

1. **ConnectionPool sizing:** Increase pool size to accommodate parallel workers. Current pool is likely size 2. Change to `max(4, calculateThreadCount(Config::instance().getParallelismTier()) + 2)` to ensure enough connections for workers plus main thread. This may require making pool size configurable or recreating the pool. Check how ConnectionPool is constructed in Application — modify the construction call.

2. **Wire batch complete callback:**
```cpp
m_importQueue.setOnBatchComplete([this](const ImportBatchSummary& summary) {
    // This callback may fire from a worker thread — post to main thread
    m_mainThreadQueue.post([this, summary]() {
        m_uiManager.showImportSummary(summary);
        m_uiManager.clearImportProgress();
    });
});
```

3. **Wire per-error toast notifications:**
Add a callback or check in processCompletedImports / batch-error handling:
```cpp
// In import error handling (called from main thread after processing):
if (Config::instance().getShowImportErrorToasts()) {
    ToastManager::instance().show(ToastType::Error, "Import Failed", task.error);
}
```

4. **Wire status bar progress:**
When import starts (in the enqueue flow from FileIOManager or Application):
```cpp
m_uiManager.setImportProgress(&m_importQueue.progress());
```

5. **Remove any existing modal import progress UI:**
Search for existing import progress rendering in Application::render() or update(). The current code likely has something in Application::update() that shows import progress via a modal or overlay. Replace it with the StatusBar approach. Specifically look for patterns like:
- `ImGui::OpenPopup("Importing")`
- `if (m_importQueue.isActive()) { ... ImGui::ProgressBar ... }`
- Any modal rendering during import

Remove the old modal. The StatusBar (from Plan 05) handles this now.

**FileIOManager wiring (file_io_manager.h/cpp):**

FileIOManager handles the import initiation (drag-drop, file dialog). Update it to:
1. Accept G-code file extensions in drag-drop and file dialog filters
2. When starting import, call the UIManager status bar setup (via callback)
3. Ensure the enqueue path works for both mesh and G-code files

Check existing FileIOManager methods:
- `processImport` or similar — add .gcode/.nc/.ngc/.tap to accepted extensions
- Update file dialog filter strings if they exist
- The actual enqueue to ImportQueue should already work since ImportQueue handles both types

**Important per user decision:**
- After batch completes, viewport focus does NOT change
- Tags assigned after import only, not during — do NOT add any tag UI to import flow
- Import runs in background — no blocking UI at any point
  </action>
  <verify>
Build: `cd /data/DW && cmake --build build --target dw 2>&1 | tail -10` — compiles cleanly. Run the application briefly to verify no crash on startup (the wiring changes should not affect initialization).
  </verify>
  <done>
Application wires ImportQueue -> StatusBar progress, batch complete -> ImportSummaryDialog, per-error -> ToastManager. ConnectionPool sized for parallel workers. FileIOManager accepts G-code extensions. Old modal import overlay removed. Complete import lifecycle: file drop -> parallel processing -> background progress -> summary dialog.
  </done>
</task>

</tasks>

<verification>
1. `cd /data/DW && cmake --build build 2>&1 | grep -i error` — no errors
2. G-code files dropped on the app will be processed by ImportQueue and stored in gcode_files table
3. LibraryManager provides G-code CRUD and hierarchy management
4. Application wires batch callbacks to UI (status bar, toasts, summary)
5. Old modal import overlay is removed
6. ConnectionPool sized for thread count + overhead
7. Auto-detect associates G-code with models on confident single-match
8. Ambiguous/no-match G-code imported as standalone
9. All existing tests pass
</verification>

<success_criteria>
- G-code imports persist to database with all metadata fields
- LibraryManager provides unified mesh + G-code library access
- Operation groups and templates accessible via LibraryManager
- Auto-detect associates G-code on confident filename match, standalone otherwise
- Application fully wires import pipeline to UI feedback loop
- No modal import overlay — replaced by background StatusBar
- File drop accepts .gcode/.nc/.ngc/.tap alongside mesh formats
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-pipeline/02-06-SUMMARY.md`
</output>
