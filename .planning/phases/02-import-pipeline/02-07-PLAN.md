---
phase: 02-import-pipeline
plan: 07
type: execute
wave: 4
depends_on: ["02-03", "02-06"]
files_modified:
  - src/render/renderer.h
  - src/render/renderer.cpp
  - src/ui/panels/viewport_panel.h
  - src/ui/panels/viewport_panel.cpp
  - src/app/workspace.h
  - src/app/workspace.cpp
  - src/ui/panels/library_panel.h
  - src/ui/panels/library_panel.cpp
autonomous: true

must_haves:
  truths:
    - "G-code toolpath is visible in the viewport as 3D lines"
    - "Rapid moves and cutting moves are visually distinguishable"
    - "User can select a G-code file in library and see its toolpath"
    - "Library panel shows G-code files alongside mesh models"
  artifacts:
    - path: "src/render/renderer.cpp"
      provides: "Toolpath rendering (mesh-based line geometry)"
      contains: "renderToolpath"
    - path: "src/ui/panels/viewport_panel.cpp"
      provides: "Viewport renders focused G-code toolpath"
      contains: "toolpath"
    - path: "src/ui/panels/library_panel.cpp"
      provides: "Library shows both mesh models and G-code files"
      contains: "GCodeRecord"
  key_links:
    - from: "src/ui/panels/viewport_panel.cpp"
      to: "src/app/workspace.h"
      via: "ViewportPanel reads focused G-code from Workspace"
      pattern: "getFocusedGCode|m_gcodeFile"
    - from: "src/ui/panels/library_panel.cpp"
      to: "src/core/library/library_manager.h"
      via: "LibraryPanel calls getAllGCodeFiles for display"
      pattern: "getAllGCodeFiles"
    - from: "src/render/renderer.cpp"
      to: "src/core/mesh/mesh.h"
      via: "Toolpath mesh uploaded and rendered like any other mesh"
      pattern: "uploadMesh|renderMesh"
---

<objective>
Implement toolpath visualization in the viewport and integrate G-code files into the library panel.

Purpose: Users need to see imported G-code toolpaths as 3D lines in the viewport and browse/select G-code files in the library alongside mesh models. This completes the visual feedback loop for G-code import.

Output: Toolpath rendering in viewport with rapid/cutting distinction, library panel showing G-code files, workspace G-code focus support.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-import-pipeline/02-CONTEXT.md
@.planning/phases/02-import-pipeline/02-03-SUMMARY.md
@.planning/phases/02-import-pipeline/02-06-SUMMARY.md
@src/render/renderer.h
@src/render/renderer.cpp
@src/ui/panels/viewport_panel.h
@src/ui/panels/viewport_panel.cpp
@src/app/workspace.h
@src/app/workspace.cpp
@src/ui/panels/library_panel.h
@src/ui/panels/library_panel.cpp
@src/core/gcode/gcode_types.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add toolpath rendering to Renderer and ViewportPanel</name>
  <files>
    src/render/renderer.h
    src/render/renderer.cpp
    src/ui/panels/viewport_panel.h
    src/ui/panels/viewport_panel.cpp
    src/app/workspace.h
    src/app/workspace.cpp
  </files>
  <action>
**Workspace G-code focus (workspace.h/cpp):**

The Workspace already has `m_gcodeFile` (a GCodeFile shared_ptr) from the architecture. Verify this exists. If not, add:
- `std::shared_ptr<Mesh> m_toolpathMesh` — the mesh representation of the G-code toolpath (generated by GCodeLoader)
- `void setFocusedToolpath(std::shared_ptr<Mesh> mesh)` / `const MeshPtr& getFocusedToolpath() const`
- Alternatively, if the existing GCode focus already holds a mesh, use that

Check what Workspace currently stores for G-code (the existing `m_gcodeFile` field). The GCodeLoader produces a Mesh from toolpath segments. We need to store that mesh so ViewportPanel can render it.

**Renderer toolpath support (renderer.h/cpp):**

The toolpath is already a Mesh (from GCodeLoader). The existing renderer should handle it via `uploadMesh()` and `renderMesh()`. However, we want visual distinction between rapid and cutting moves.

Option A (simple — recommended for this phase): The GCodeLoader already encodes move type in vertex data (texcoord.u: 0.0 = cutting, 1.0 = rapid from Plan 03). Add a rendering mode or shader uniform to the existing shader that uses texcoord.u to blend between two colors:
- Cutting moves: blue/green color
- Rapid moves: red/orange color, thinner or dashed appearance

Check the current shader in `src/render/shader_sources.h`. If it already uses texcoord, add a `uniform bool u_isToolpath` flag. When true, the fragment shader reads texcoord.u and interpolates between cutting color (e.g., vec3(0.2, 0.6, 1.0)) and rapid color (e.g., vec3(1.0, 0.3, 0.1)).

If modifying the shader is too invasive, Option B: Just render the toolpath mesh with a different object color (e.g., blue) set via the existing uniform. Rapid/cutting distinction deferred to a future rendering phase.

Add to Renderer:
```cpp
void renderToolpath(const Mesh& toolpathMesh, const Mat4& viewMatrix, const Mat4& projMatrix);
```

This can simply call the existing renderMesh with a toolpath-specific color/mode flag, or be a thin wrapper that sets the isToolpath uniform before calling the standard render path.

**ViewportPanel integration (viewport_panel.h/cpp):**

In ViewportPanel::render():
- After rendering the focused mesh (existing behavior), check if Workspace has a focused toolpath mesh
- If yes, call `m_renderer.renderToolpath(toolpathMesh, viewMatrix, projMatrix)`
- The toolpath renders in the same 3D space as the model (so if both a model and its associated G-code are focused, both are visible)

Add to ViewportPanel:
- Check for toolpath: `if (auto toolpath = m_workspace.getFocusedToolpath()) { ... }`
- Camera should auto-fit to toolpath bounds when a new toolpath is focused (same logic as mesh focus)

**Important per discretion:** Toolpath rendering style (colors, line widths) is Claude's choice. Use:
- Cutting moves (G1): Solid blue/teal, medium width (0.5mm extrusion from GCodeLoader)
- Rapid moves (G0): Semi-transparent red/orange, thinner (0.2mm extrusion from GCodeLoader)
- The color distinction comes from the shader reading texcoord.u or from rendering two separate passes
  </action>
  <verify>
Build: `cd /data/DW && cmake --build build --target dw 2>&1 | tail -10` — compiles cleanly. Run existing tests to verify no regressions.
  </verify>
  <done>
Toolpath mesh renders in viewport with visual distinction between rapid and cutting moves. Workspace stores focused toolpath. Camera auto-fits to toolpath bounds. Renderer has toolpath rendering mode.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate G-code files into library panel</name>
  <files>
    src/ui/panels/library_panel.h
    src/ui/panels/library_panel.cpp
  </files>
  <action>
**LibraryPanel G-code display (library_panel.h/cpp):**

The LibraryPanel currently shows mesh models from LibraryManager::getAllModels(). Extend to also show G-code files.

**Approach — Tabbed or unified view:**
Add tabs to the library panel: "Models" | "G-code" | "All"

- "Models" tab: existing behavior (mesh models only)
- "G-code" tab: shows G-code files from LibraryManager::getAllGCodeFiles()
- "All" tab: shows both interleaved, sorted by import date

For the G-code tab, each item shows:
- Name (filename without extension)
- File format indicator ("G-code" badge)
- Metadata: estimated time, total distance (compact format)
- Thumbnail (if generated) or a default G-code icon/placeholder

**Selection behavior:**
When user clicks a G-code file:
- Invoke a new callback `m_onGCodeSelected(gcodeId)` (same pattern as m_onModelSelected)
- Application handles this callback by:
  - Loading the G-code file from GCodeRepository
  - Parsing it to get toolpath mesh
  - Setting workspace focused toolpath
  - ViewportPanel then renders it

Add to LibraryPanel:
```cpp
using GCodeCallback = std::function<void(i64 gcodeId)>;
void setOnGCodeSelected(GCodeCallback cb);
```

**G-code item rendering:**
Use the same card/grid layout as mesh models (existing pattern). For items without thumbnails, render a placeholder:
- A simple "GC" text badge or toolpath icon
- Or generate a simple top-down view of the toolpath bounding box as placeholder

**Important:** Keep the existing model display working exactly as before. G-code is additive.

**LibraryPanel data refresh:**
Add `m_gcodeFiles` vector member, refresh alongside m_models when library changes:
```cpp
void refreshGCodeFiles() {
    m_gcodeFiles = m_libraryManager.getAllGCodeFiles();
}
```
  </action>
  <verify>
Build: `cd /data/DW && cmake --build build --target dw 2>&1 | tail -10` — compiles cleanly. Run tests.
  </verify>
  <done>
LibraryPanel shows G-code files alongside mesh models with tabbed view. G-code items show name, format badge, and metadata. Clicking a G-code file triggers onGCodeSelected callback. Existing model display unchanged.
  </done>
</task>

</tasks>

<verification>
1. `cd /data/DW && cmake --build build 2>&1 | grep -i error` — no errors
2. Workspace can hold focused toolpath mesh
3. ViewportPanel renders toolpath when focused
4. Cutting vs rapid moves have different visual appearance
5. LibraryPanel shows G-code files in dedicated tab
6. Clicking G-code in library triggers selection callback
7. All existing tests pass
</verification>

<success_criteria>
- G-code toolpath visible in viewport as 3D geometry
- Rapid and cutting moves visually distinguishable (color/width)
- Camera auto-fits to toolpath bounds on focus
- Library panel shows G-code files with metadata
- Selecting G-code in library focuses it in viewport
- All existing mesh model functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-import-pipeline/02-07-SUMMARY.md`
</output>
