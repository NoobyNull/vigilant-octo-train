---
phase: 02-content-addressable-storage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/paths/app_paths.h
  - src/core/paths/app_paths.cpp
  - src/core/storage/storage_manager.h
  - src/core/storage/storage_manager.cpp
  - tests/test_storage_manager.cpp
  - CMakeLists.txt
autonomous: true
requirements: [STOR-01, STOR-02, STOR-03]

must_haves:
  truths:
    - "StorageManager can compute a blob path from hash+extension without any I/O"
    - "Storing a file writes to temp first, verifies hash, then atomically renames to final blob path"
    - "If a blob already exists at the hash path, storeFile returns success without copying (dedup)"
    - "Orphaned temp files from prior crashes are cleaned up on startup via cleanupOrphanedTempFiles()"
    - "getBlobStoreDir() returns getDataDir() / 'blobs'"
  artifacts:
    - path: "src/core/storage/storage_manager.h"
      provides: "StorageManager class declaration"
      contains: "class StorageManager"
    - path: "src/core/storage/storage_manager.cpp"
      provides: "StorageManager implementation with atomic write pattern"
      min_lines: 80
    - path: "src/core/paths/app_paths.h"
      provides: "getBlobStoreDir() and getTempStoreDir() declarations"
      contains: "getBlobStoreDir"
    - path: "tests/test_storage_manager.cpp"
      provides: "Unit tests for blob path computation, store, dedup, orphan cleanup"
      min_lines: 80
  key_links:
    - from: "src/core/storage/storage_manager.cpp"
      to: "src/core/paths/app_paths.h"
      via: "paths::getBlobStoreDir() for default blob root"
      pattern: "paths::getBlobStoreDir"
    - from: "src/core/storage/storage_manager.cpp"
      to: "src/core/mesh/hash.h"
      via: "hash::computeFile() to verify temp file hash before rename"
      pattern: "hash::computeFile"
---

<objective>
Create the StorageManager component and extend app_paths to support content-addressable blob storage with atomic writes and orphan cleanup.

Purpose: This is the core CAS infrastructure that all subsequent import pipeline changes depend on. StorageManager owns the blob store on disk -- computing hash-based paths, writing files atomically (temp+verify+rename), deduplicating by hash, and cleaning up orphaned temp files from crashes.

Output: `src/core/storage/storage_manager.h/.cpp`, updated `app_paths.h/.cpp`, unit tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
@src/core/paths/app_paths.h
@src/core/paths/app_paths.cpp
@src/core/mesh/hash.h
@src/core/mesh/hash.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add blob store paths to app_paths and create StorageManager</name>
  <files>
    src/core/paths/app_paths.h
    src/core/paths/app_paths.cpp
    src/core/storage/storage_manager.h
    src/core/storage/storage_manager.cpp
  </files>
  <action>
1. In `src/core/paths/app_paths.h`, add two new functions:
   - `Path getBlobStoreDir();` -- returns `getDataDir() / "blobs"`
   - `Path getTempStoreDir();` -- returns `getBlobStoreDir() / ".tmp"` (co-located with CAS root for atomic rename)

2. In `src/core/paths/app_paths.cpp`, implement both functions. Also add both directories to `ensureDirectoriesExist()`.

3. Create `src/core/storage/storage_manager.h` with class `StorageManager` in namespace `dw`:
   ```cpp
   class StorageManager {
   public:
       explicit StorageManager(const Path& blobRoot);

       // Pure path computation -- no I/O. hash[0..1]/hash[2..3]/hash.ext
       Path blobPath(const std::string& hash, const std::string& ext) const;

       // Copy source into blob store via temp+verify+rename. Idempotent (no-op if blob exists).
       // Returns final blob path on success, empty path + sets error on failure.
       Path storeFile(const Path& source, const std::string& hash,
                      const std::string& ext, std::string& error);

       // Move source into blob store. Falls back to copy+delete if cross-filesystem.
       Path moveFile(const Path& source, const std::string& hash,
                     const std::string& ext, std::string& error);

       // Check if blob exists at hash path
       bool exists(const std::string& hash, const std::string& ext) const;

       // Remove blob file. Returns true if removed or didn't exist.
       bool remove(const std::string& hash, const std::string& ext);

       // Clean up orphaned temp files from prior crashes. Call on startup.
       // Returns count of files cleaned.
       int cleanupOrphanedTempFiles();

       // Default root: paths::getBlobStoreDir()
       static Path defaultBlobRoot();

   private:
       Path m_blobRoot;
       Path m_tempDir;
   };
   ```

4. Create `src/core/storage/storage_manager.cpp`:

   - `blobPath()`: Pure function. Given hash "abcdef1234567890" and ext "stl", returns `m_blobRoot / "ab" / "cd" / "abcdef1234567890.stl"`. Use `hash.substr(0,2)` for first dir, `hash.substr(2,2)` for second dir, `hash + "." + ext` for filename. Validate hash length >= 4, return empty + error if not.

   - `storeFile()`:
     a. Check if blob already exists via `exists()` -- if yes, return blobPath (dedup, no-op).
     b. Create temp dir if needed: `fs::create_directories(m_tempDir)`.
     c. Generate temp file path: `m_tempDir / ("import_" + hash + "." + ext)`.
     d. Copy source to temp: `fs::copy_file(source, tmpPath, fs::copy_options::overwrite_existing)`.
     e. Verify: call `hash::computeFile(tmpPath)` and compare with expected hash. If mismatch, remove temp file, set error "Hash verification failed", return empty.
     f. Create destination directories: `fs::create_directories(destDir)` where destDir is the parent of `blobPath()`.
     g. Atomic rename: `fs::rename(tmpPath, finalPath)`.
     h. Return finalPath.
     i. Wrap everything in try/catch for `fs::filesystem_error`, set error string on catch.

   - `moveFile()`: Same as storeFile but after successful rename, attempt `fs::remove(source)`. If remove fails (cross-filesystem or permissions), log warning but don't fail -- the blob is stored correctly.

   - `exists()`: `return fs::exists(blobPath(hash, ext))`.

   - `remove()`: `return fs::remove(blobPath(hash, ext))` in try/catch. Return true if file didn't exist.

   - `cleanupOrphanedTempFiles()`: If `m_tempDir` exists, iterate all files in it via `fs::directory_iterator`, remove each, count removed. Log count. Return count. Wrap in try/catch.

   - `defaultBlobRoot()`: `return paths::getBlobStoreDir()`.

   IMPORTANT: Use `#include "../mesh/hash.h"` for hash verification. Use `#include "../paths/app_paths.h"` for default blob root.
   IMPORTANT: The extension parameter should NOT include the leading dot. blobPath adds the dot.
   IMPORTANT: All filesystem operations wrapped in try/catch.
  </action>
  <verify>
    Files compile: add them to CMakeLists.txt source list and run `cmake --build build --target dw_core` (or equivalent core target).
  </verify>
  <done>
    StorageManager.h declares all 7 public methods. StorageManager.cpp implements atomic write-to-temp-verify-rename pattern. app_paths.h has getBlobStoreDir() and getTempStoreDir(). Both compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add StorageManager to CMake and write unit tests</name>
  <files>
    CMakeLists.txt
    tests/test_storage_manager.cpp
  </files>
  <action>
1. Add `src/core/storage/storage_manager.cpp` to the appropriate source list in CMakeLists.txt (find where other core sources are listed, add this one alphabetically in the storage section -- create the section if needed).

2. Create `tests/test_storage_manager.cpp` with GoogleTest tests:

   - **Test: BlobPathComputation** -- Create StorageManager with a temp root. Call `blobPath("abcdef1234567890", "stl")`. Assert path ends with `"ab/cd/abcdef1234567890.stl"`. Test with "1234567890abcdef" to verify different prefix.

   - **Test: BlobPathShortHash** -- Call `blobPath("abc", "stl")` with hash < 4 chars. Expect empty path returned (invalid hash).

   - **Test: StoreFileBasic** -- Create a temp directory (use `fs::temp_directory_path() / "test_cas_XXXX"`). Write a small test file. Compute its hash with `hash::computeFile()`. Call `storeFile()`. Verify: (a) returned path matches expected `blobPath()`, (b) file exists at returned path, (c) temp dir is empty (temp file was renamed).

   - **Test: StoreFileDedup** -- Store the same file twice. Second call should be a no-op (idempotent). Verify returned path is same, file still exists, no error.

   - **Test: StoreFileHashMismatch** -- Store a file but provide wrong hash string. Verify error is set, returned path is empty, no file at the wrong hash path, temp file cleaned up.

   - **Test: MoveFileBasic** -- Create test file, store via `moveFile()`. Verify blob exists at hash path. Verify source file is removed.

   - **Test: ExistsCheck** -- Before storing: `exists()` returns false. After storing: returns true.

   - **Test: RemoveBlob** -- Store a file, then `remove()`. Verify file no longer exists. `exists()` returns false.

   - **Test: CleanupOrphanedTempFiles** -- Manually create files in the temp dir (simulating crash leftovers). Call `cleanupOrphanedTempFiles()`. Verify temp dir is empty, returned count matches files created.

   Each test should create its own isolated temp directory and clean up after itself using a test fixture with SetUp/TearDown.

3. Add `tests/test_storage_manager.cpp` to the test target in CMakeLists.txt.

4. Build and run tests: `cmake --build build && ctest --test-dir build -R storage`
  </action>
  <verify>
    `cmake --build build` succeeds. `ctest --test-dir build -R storage` -- all tests pass.
  </verify>
  <done>
    All 9 StorageManager unit tests pass. Tests cover: path computation, atomic store, dedup, hash verification, move, exists, remove, and orphan cleanup.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build` compiles without warnings/errors
2. `ctest --test-dir build -R storage` -- all StorageManager tests pass
3. Verify blob path structure: test output confirms `ab/cd/abcdef1234567890.stl` pattern
4. Verify atomic write: test confirms temp file is removed after successful rename
5. Verify dedup: storing same content twice produces no error and no duplicate files
6. Verify orphan cleanup: manually-created temp files are cleaned up
</verification>

<success_criteria>
- StorageManager class exists at src/core/storage/storage_manager.h/.cpp
- getBlobStoreDir() and getTempStoreDir() added to app_paths
- Atomic write pattern: temp -> verify hash -> rename (never write directly to final path)
- Dedup: existing blob skips copy
- Orphan cleanup: removes all files from .tmp/ directory
- All unit tests pass
- Compiles cleanly with existing codebase
</success_criteria>

<output>
After completion, create `.planning/phases/02-content-addressable-storage/02-01-SUMMARY.md`
</output>
