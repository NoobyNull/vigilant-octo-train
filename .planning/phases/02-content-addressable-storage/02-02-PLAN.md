---
phase: 02-content-addressable-storage
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/core/import/import_queue.h
  - src/core/import/import_queue.cpp
  - src/app/application.h
  - src/app/application.cpp
autonomous: true
requirements: [STOR-01, STOR-02, STOR-03]

must_haves:
  truths:
    - "Importing a model places its file in blobs/ab/cd/abcdef...ext based on content hash"
    - "Killing the application mid-import leaves no corrupt or partial files in the blob store"
    - "Orphaned temp files from prior crashes are cleaned up automatically on next startup"
    - "Importing the same file twice does not create a duplicate blob (dedup by hash)"
    - "LeaveInPlace mode still works -- no blob store interaction when user chose to keep files in place"
  artifacts:
    - path: "src/core/import/import_queue.h"
      provides: "ImportQueue accepting StorageManager* in constructor"
      contains: "StorageManager"
    - path: "src/core/import/import_queue.cpp"
      provides: "Stage 5/5.5 using StorageManager for CAS writes instead of FileHandler"
      contains: "storageMgr->storeFile"
    - path: "src/app/application.h"
      provides: "Application owning StorageManager"
      contains: "StorageManager"
    - path: "src/app/application.cpp"
      provides: "Application constructing StorageManager and injecting into ImportQueue"
      contains: "m_storageManager"
  key_links:
    - from: "src/core/import/import_queue.cpp"
      to: "src/core/storage/storage_manager.h"
      via: "StorageManager* member used in processTask Stage 5.5"
      pattern: "m_storageManager->storeFile"
    - from: "src/app/application.cpp"
      to: "src/core/storage/storage_manager.h"
      via: "Application constructs and owns StorageManager, passes to ImportQueue"
      pattern: "m_storageManager.*std::make_unique"
    - from: "src/app/application.cpp"
      to: "cleanupOrphanedTempFiles"
      via: "Called during Application::init() after StorageManager construction"
      pattern: "cleanupOrphanedTempFiles"
---

<objective>
Wire StorageManager into the import pipeline and Application lifecycle so that imported models are stored in the CAS blob store, and orphan cleanup runs on startup.

Purpose: This connects the StorageManager (Plan 01) to the existing import pipeline, replacing the FileHandler copy/move logic for CAS storage. After this plan, the full STOR-01/02/03 requirements are met end-to-end.

Output: Modified ImportQueue and Application files with CAS integration
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/02-content-addressable-storage/02-01-SUMMARY.md
@src/core/import/import_queue.h
@src/core/import/import_queue.cpp
@src/core/import/file_handler.h
@src/app/application.h
@src/app/application.cpp
@src/core/config/config.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire StorageManager into ImportQueue Stage 5/5.5</name>
  <files>
    src/core/import/import_queue.h
    src/core/import/import_queue.cpp
  </files>
  <action>
1. In `import_queue.h`:
   - Add forward declaration: `class StorageManager;`
   - Modify constructor to accept optional StorageManager pointer:
     `explicit ImportQueue(ConnectionPool& pool, LibraryManager* libraryManager = nullptr, StorageManager* storageManager = nullptr);`
   - Add private member: `StorageManager* m_storageManager;`
   - Add `#include` for storage_manager.h is NOT needed in header (forward decl only)

2. In `import_queue.cpp`:
   - Add `#include "../storage/storage_manager.h"` at the top with other includes
   - Update constructor to initialize `m_storageManager(storageManager)`
   - Modify `processTask()` Stage 5 (Inserting) for mesh models:
     - BEFORE the `ModelRepository::insert()` call, compute the blob path:
       ```cpp
       auto mode = Config::instance().getFileHandlingMode();
       auto libraryDir = Config::instance().getLibraryDir();
       if (libraryDir.empty()) {
           libraryDir = FileHandler::defaultLibraryDir();
       }
       ```
     - If `m_storageManager` is not null AND mode is NOT LeaveInPlace:
       ```cpp
       Path blobDest = m_storageManager->blobPath(task.fileHash, task.extension);
       record.filePath = blobDest;
       ```
     - Otherwise (LeaveInPlace or no StorageManager): `record.filePath = task.sourcePath;` (existing behavior)
     - Insert the record with the correct filePath set upfront (no two-step insert-then-update)

   - Modify Stage 5.5 (File Handling):
     - If `m_storageManager` is not null AND mode is NOT LeaveInPlace:
       ```cpp
       std::string storageError;
       Path storedPath;
       if (mode == FileHandlingMode::CopyToLibrary) {
           storedPath = m_storageManager->storeFile(task.sourcePath, task.fileHash, task.extension, storageError);
       } else if (mode == FileHandlingMode::MoveToLibrary) {
           storedPath = m_storageManager->moveFile(task.sourcePath, task.fileHash, task.extension, storageError);
       }

       if (storedPath.empty()) {
           // Blob store failed -- roll back the DB insert
           log::errorf("Import", "Blob store failed for '%s': %s",
                       file::getStem(task.sourcePath).c_str(), storageError.c_str());
           modelRepo.remove(task.modelId);
           task.stage = ImportStage::Failed;
           task.error = "Blob store failed: " + storageError;
           // ... handle failure (update summary, progress, remaining tasks) ...
           return;
       }
       ```
     - If `m_storageManager` is null (backward compat): fall back to existing `FileHandler::handleImportedFile()` logic
     - If mode is LeaveInPlace: no-op (existing behavior)

   - Apply same pattern for GCode import path (if mode != LeaveInPlace and storageManager present, use CAS for gcode files too). The gcode record.filePath should also be set to blobPath before insert.

   CRITICAL: The key change is that `record.filePath` is set to the blob path BEFORE the DB insert, not updated afterward. This eliminates the crash window where the DB record points to a path that doesn't exist yet.

   CRITICAL: If the blob store write fails after DB insert, DELETE the DB record (rollback). This prevents records pointing to non-existent files.

   CRITICAL: Keep FileHandler import as fallback when m_storageManager is nullptr, so existing code paths continue to work during transition.
  </action>
  <verify>
    `cmake --build build` compiles without errors. Existing tests still pass.
  </verify>
  <done>
    ImportQueue accepts StorageManager* in constructor. Stage 5 sets filePath to blob path before insert. Stage 5.5 uses StorageManager for atomic CAS writes. DB record is rolled back if blob store fails. LeaveInPlace mode unchanged. Backward compatible when StorageManager is null.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire StorageManager into Application lifecycle</name>
  <files>
    src/app/application.h
    src/app/application.cpp
  </files>
  <action>
1. In `application.h`:
   - Add forward declaration: `class StorageManager;` (in the forward declarations block)
   - Add private member: `std::unique_ptr<StorageManager> m_storageManager;` (after m_importQueue)

2. In `application.cpp`:
   - Add `#include "../core/storage/storage_manager.h"` with other includes
   - In `Application::init()`, AFTER database and connection pool init, BEFORE ImportQueue creation:
     ```cpp
     // Content-addressable blob store
     m_storageManager = std::make_unique<StorageManager>(StorageManager::defaultBlobRoot());

     // Clean up orphaned temp files from prior crashes (STOR-03)
     int orphansCleaned = m_storageManager->cleanupOrphanedTempFiles();
     if (orphansCleaned > 0) {
         log::infof("App", "Cleaned up %d orphaned temp file(s) from prior session", orphansCleaned);
     }
     ```
   - Modify the `ImportQueue` construction to pass `m_storageManager.get()`:
     Find the existing line like:
     `m_importQueue = std::make_unique<ImportQueue>(*m_connectionPool, m_libraryManager.get());`
     Change to:
     `m_importQueue = std::make_unique<ImportQueue>(*m_connectionPool, m_libraryManager.get(), m_storageManager.get());`

   - In `Application::shutdown()` or destructor: StorageManager cleanup is automatic via unique_ptr destruction (no special shutdown needed).

   NOTE: Look at the actual Application::init() code to find the exact location and variable names. The construction order matters: StorageManager must be created after paths::ensureDirectoriesExist() (which now creates the blob dirs) and before ImportQueue.
  </action>
  <verify>
    `cmake --build build` compiles without errors. Run the application: `./build/digital_workshop` -- verify it starts without errors, check log output for "Cleaned up X orphaned temp file(s)" message (should show 0 on clean start). Import a model file and verify it appears in `~/.local/share/digitalworkshop/blobs/XX/YY/` directory structure (if file handling mode is Copy or Move).
  </verify>
  <done>
    Application owns StorageManager, constructs it during init, calls cleanupOrphanedTempFiles() on startup, passes it to ImportQueue. Importing a model with CopyToLibrary or MoveToLibrary mode stores the file in the CAS blob directory. LeaveInPlace continues to work. Killing the app mid-import leaves no corrupt files in the blob store.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build` succeeds with no warnings
2. All existing tests pass (no regressions)
3. Manual test: Import a .stl file with CopyToLibrary mode
   - Verify file appears at `~/.local/share/digitalworkshop/blobs/XX/YY/hash.stl`
   - Verify DB record's file_path points to the blob path
4. Manual test: Import the same file again
   - Verify dedup works (duplicate detected at Stage 3 via hash, OR if reimported, blob already exists and storeFile is a no-op)
5. Manual test: Import with LeaveInPlace mode
   - Verify file stays at original path, no blob created
6. Startup cleanup: Create a file in `~/.local/share/digitalworkshop/blobs/.tmp/`, restart app, verify it's cleaned up
</verification>

<success_criteria>
- Importing a model places its file in `blobs/ab/cd/abcdef...ext` based on content hash (STOR-01)
- Atomic write pattern prevents corrupt blobs on crash (STOR-02)
- Orphaned temp files cleaned up on startup (STOR-03)
- Importing same file twice does not create duplicate blob
- LeaveInPlace mode continues working without StorageManager interaction
- Application compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-content-addressable-storage/02-02-SUMMARY.md`
</output>
