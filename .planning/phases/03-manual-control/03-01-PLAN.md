---
phase: 03-manual-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/cnc/cnc_controller.h
  - src/core/cnc/cnc_controller.cpp
  - src/ui/panels/cnc_jog_panel.h
  - src/ui/panels/cnc_jog_panel.cpp
  - src/ui/icons.h
autonomous: true
requirements: [CUI-04, CUI-07]
must_haves:
  truths:
    - "CncController exposes a public sendCommand(string) method that queues arbitrary G-code for IO thread dispatch"
    - "CncJogPanel renders XYZ +/- jog buttons with step size selector (0.1, 1, 10, 100mm)"
    - "Clicking a jog button sends a correctly formatted $J= command through sendCommand()"
    - "Home button sends $H command and is disabled during alarm state"
    - "Jog buttons are disabled when machine is in Alarm, Run, or Home state"
  artifacts:
    - path: "src/core/cnc/cnc_controller.h"
      provides: "Public sendCommand() method declaration"
      contains: "void sendCommand"
    - path: "src/core/cnc/cnc_controller.cpp"
      provides: "sendCommand() implementation using m_pendingStringCmds"
      contains: "void CncController::sendCommand"
    - path: "src/ui/panels/cnc_jog_panel.h"
      provides: "CncJogPanel class declaration"
      contains: "class CncJogPanel"
    - path: "src/ui/panels/cnc_jog_panel.cpp"
      provides: "Jog panel rendering with buttons, step sizes, and homing"
      min_lines: 100
  key_links:
    - from: "src/ui/panels/cnc_jog_panel.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "sendCommand() calls for $J= and $H"
      pattern: "sendCommand.*\\$J=|sendCommand.*\\$H"
---

<objective>
Add a public sendCommand() method to CncController and build the CncJogPanel with jog buttons and homing.

Purpose: Provides the foundation command dispatch method needed by all Phase 3 panels, and implements the primary manual control interface — jog buttons with step size selection and homing.

Output: Modified CncController with sendCommand(), new CncJogPanel class with XYZ jog and Home.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-manual-control/03-RESEARCH.md
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_controller.cpp
@src/core/cnc/cnc_types.h
@src/ui/panels/cnc_status_panel.h
@src/ui/panels/cnc_status_panel.cpp
@src/ui/panels/panel.h
@src/ui/icons.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sendCommand() to CncController</name>
  <files>src/core/cnc/cnc_controller.h, src/core/cnc/cnc_controller.cpp</files>
  <action>
Add a public method `void sendCommand(const std::string& cmd)` to CncController.

In cnc_controller.h, add to the public section (near the `unlock()` method):
```cpp
void sendCommand(const std::string& cmd); // Queue arbitrary G-code/system command
```

In cnc_controller.cpp, implement it using the existing thread-safe string command queue:
```cpp
void CncController::sendCommand(const std::string& cmd) {
    std::lock_guard<std::mutex> lock(m_cmdStringMutex);
    m_pendingStringCmds.push_back(cmd + "\n");
}
```

This follows the exact same pattern as the existing `unlock()` method which pushes "$X\n" to m_pendingStringCmds. The IO thread dispatches these in `dispatchPendingCommands()`.

Verify the unlock() method still works as before (it's a special case of sendCommand).
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors in cnc_controller.cpp</verify>
  <done>CncController has a public sendCommand(string) method that thread-safely queues commands for IO thread dispatch</done>
</task>

<task type="auto">
  <name>Task 2: Create CncJogPanel with jog buttons and homing</name>
  <files>src/ui/panels/cnc_jog_panel.h, src/ui/panels/cnc_jog_panel.cpp, src/ui/icons.h</files>
  <action>
Create a new CncJogPanel that extends Panel (same pattern as CncStatusPanel).

**cnc_jog_panel.h:**
```cpp
class CncJogPanel : public Panel {
public:
    CncJogPanel();
    ~CncJogPanel() override = default;
    void render() override;

    void setCncController(CncController* cnc) { m_cnc = cnc; }
    void onStatusUpdate(const MachineStatus& status);
    void onConnectionChanged(bool connected, const std::string& version);

private:
    void renderStepSizeSelector();
    void renderJogButtons();
    void renderHomingSection();

    CncController* m_cnc = nullptr;
    MachineStatus m_status{};
    bool m_connected = false;

    // Step sizes in mm: 0.1, 1, 10, 100
    static constexpr float STEP_SIZES[] = {0.1f, 1.0f, 10.0f, 100.0f};
    static constexpr const char* STEP_LABELS[] = {"0.1", "1", "10", "100"};
    int m_selectedStep = 1; // Default to 1mm

    // Jog feed rates matched to step sizes (mm/min)
    static constexpr float JOG_FEEDS[] = {500.0f, 1000.0f, 2000.0f, 3000.0f};
};
```

**cnc_jog_panel.cpp:**

Constructor: `CncJogPanel() : Panel("Jog Control") {}`

`render()`: Same pattern as CncStatusPanel — if not open return, Begin/End window. If not connected, show "Disconnected" message. Otherwise render step size selector, jog buttons, and homing section.

`renderStepSizeSelector()`: Use `ImGui::SeparatorText("Step Size")`. Render 4 radio buttons in a row using `ImGui::RadioButton()` for each step size. Use `ImGui::SameLine()` between them. Show units "mm" after.

`renderJogButtons()`: Use `ImGui::SeparatorText("Jog")`. Layout as a CNCjs-style cross pattern:
- Row 1: Center an "Y+" button
- Row 2: "X-" button, spacing, "X+" button
- Row 3: Center a "Y-" button
- Below: "Z+" and "Z-" buttons side by side (or vertically)

For each button:
1. Check if jog is allowed: `m_status.state == MachineState::Idle || m_status.state == MachineState::Jog`. Disable button otherwise with `ImGui::BeginDisabled()`.
2. On click, format and send jog command:
   ```cpp
   float step = STEP_SIZES[m_selectedStep];
   float feed = JOG_FEEDS[m_selectedStep];
   char cmd[128];
   std::snprintf(cmd, sizeof(cmd), "$J=G91 G21 X%.3f F%.0f", step, feed);
   m_cnc->sendCommand(cmd);
   ```
3. Use appropriate axis and sign for each button direction.

Button sizing: Use `ImGui::PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2(12, 12))` for larger touch targets. Use Icons (arrows) where available or text labels "X+" "X-" "Y+" "Y-" "Z+" "Z-".

`renderHomingSection()`: Use `ImGui::SeparatorText("Home")`. Single "Home All" button that sends "$H". Disable when machine state is not Idle or Alarm (homing from alarm is valid to clear it). On click: `m_cnc->sendCommand("$H")`.

Add an "Unlock" button next to Home that sends "$X" (calls `m_cnc->unlock()` or `m_cnc->sendCommand("$X")`). Useful when in alarm state. Only show/enable in Alarm state.

`onStatusUpdate()`: Store `m_status = status;`
`onConnectionChanged()`: Store `m_connected = connected;` and reset status on disconnect.

**icons.h:** Add jog-related icons if not already present:
- ICON_HOME = "\xef\x80\x95" (f015 house)
- ICON_ARROW_UP = "\xef\x81\xa2" (f062 arrow-up)
- ICON_ARROW_DOWN = "\xef\x81\xa3" (f063 arrow-down)
- ICON_ARROW_LEFT = "\xef\x81\xa0" (f060 arrow-left)
- ICON_ARROW_RIGHT = "\xef\x81\xa1" (f061 arrow-right)
- ICON_LOCK_OPEN = "\xef\x82\x9c" (f09c lock-open, for unlock)

Add corresponding entries to the Icons struct.
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors. Verify files exist: `ls src/ui/panels/cnc_jog_panel.*`</verify>
  <done>CncJogPanel renders jog buttons for X/Y/Z +/- with step size selector (0.1/1/10/100mm), Home button sends $H, Unlock button sends $X, all buttons properly disabled based on machine state</done>
</task>

</tasks>

<verification>
- [ ] `sendCommand()` exists in CncController and compiles
- [ ] CncJogPanel compiles and renders jog buttons with step size selector
- [ ] Jog buttons send correctly formatted `$J=G91 G21 {axis}{distance} F{feed}` commands
- [ ] Home button sends `$H`
- [ ] Buttons are disabled in inappropriate states (Alarm, Run, Home for jog; non-Idle/non-Alarm for homing)
- [ ] New icons added to icons.h
</verification>

<success_criteria>
CncController has public sendCommand() method. CncJogPanel renders a complete jog interface with XYZ +/- buttons, 4 step sizes, Home button, and Unlock button. All commands correctly formatted for GRBL 1.1.
</success_criteria>

<output>
After completion, create `.planning/phases/03-manual-control/03-01-SUMMARY.md`
</output>
