---
phase: 03-manual-control
plan: 04
type: execute
wave: 3
depends_on: [03-01, 03-02, 03-03]
files_modified:
  - src/managers/ui_manager.h
  - src/managers/ui_manager.cpp
  - src/app/application_wiring.cpp
  - src/ui/panels/cnc_jog_panel.h
  - src/ui/panels/cnc_jog_panel.cpp
autonomous: true
requirements: [CUI-05, CUI-06]
must_haves:
  truths:
    - "Arrow keys jog X/Y and Page Up/Down jogs Z when in CNC workspace mode and no text input has focus"
    - "Holding a jog key initiates continuous jog that stops when the key is released"
    - "All three new panels (Jog, Console, WCS) appear in the CNC workspace mode layout"
    - "CncController callbacks are wired to all new panels in application_wiring.cpp"
    - "View menu has entries to toggle each new panel"
  artifacts:
    - path: "src/managers/ui_manager.h"
      provides: "Panel ownership and visibility for CncJogPanel, CncConsolePanel, CncWcsPanel"
      contains: "CncJogPanel"
    - path: "src/managers/ui_manager.cpp"
      provides: "Panel creation, rendering, workspace mode integration, keyboard jog handler"
      contains: "handleCncKeyboardJog"
    - path: "src/app/application_wiring.cpp"
      provides: "CncController callback wiring to all new panels"
      contains: "cncJogPanel|cncConsolePanel|cncWcsPanel"
  key_links:
    - from: "src/managers/ui_manager.cpp"
      to: "src/ui/panels/cnc_jog_panel.h"
      via: "Keyboard jog invokes jogAxis on CncJogPanel or directly on CncController"
      pattern: "IsKeyPressed.*Arrow|IsKeyDown.*Arrow"
    - from: "src/app/application_wiring.cpp"
      to: "src/ui/panels/cnc_jog_panel.h"
      via: "setCncController and callback wiring"
      pattern: "cncJogPanel.*setCncController|setCncController.*cncJogPanel"
---

<objective>
Integrate all Phase 3 panels into UIManager and Application, add keyboard jog shortcuts and continuous jog support.

Purpose: Wires everything together — the three new panels become visible in CNC workspace mode, keyboard shortcuts work, continuous jog is functional, and all CncController callbacks reach the new panels.

Output: Complete Phase 3 integration: panels registered, callbacks wired, keyboard jog working, continuous jog working.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-manual-control/03-RESEARCH.md
@.planning/phases/03-manual-control/03-01-SUMMARY.md
@.planning/phases/03-manual-control/03-02-SUMMARY.md
@.planning/phases/03-manual-control/03-03-SUMMARY.md
@src/managers/ui_manager.h
@src/managers/ui_manager.cpp
@src/app/application_wiring.cpp
@src/ui/panels/cnc_jog_panel.h
@src/ui/panels/cnc_console_panel.h
@src/ui/panels/cnc_wcs_panel.h
@src/core/cnc/cnc_controller.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Register new panels in UIManager and update workspace mode</name>
  <files>src/managers/ui_manager.h, src/managers/ui_manager.cpp</files>
  <action>
Add the three new panels to UIManager following the exact pattern used for CncStatusPanel.

**ui_manager.h changes:**
1. Add forward declarations:
   ```cpp
   class CncJogPanel;
   class CncConsolePanel;
   class CncWcsPanel;
   ```
2. Add panel accessors:
   ```cpp
   CncJogPanel* cncJogPanel() { return m_cncJogPanel.get(); }
   CncConsolePanel* cncConsolePanel() { return m_cncConsolePanel.get(); }
   CncWcsPanel* cncWcsPanel() { return m_cncWcsPanel.get(); }
   ```
3. Add visibility flags:
   ```cpp
   bool& showCncJog() { return m_showCncJog; }
   bool& showCncConsole() { return m_showCncConsole; }
   bool& showCncWcs() { return m_showCncWcs; }
   ```
4. Add private members:
   ```cpp
   std::unique_ptr<CncJogPanel> m_cncJogPanel;
   std::unique_ptr<CncConsolePanel> m_cncConsolePanel;
   std::unique_ptr<CncWcsPanel> m_cncWcsPanel;
   bool m_showCncJog = false;
   bool m_showCncConsole = false;
   bool m_showCncWcs = false;
   ```
5. Add private method declaration:
   ```cpp
   void handleCncKeyboardJog();
   ```

**ui_manager.cpp changes:**

1. Add includes for new panel headers.

2. In `init()`: Create the three panels:
   ```cpp
   m_cncJogPanel = std::make_unique<CncJogPanel>();
   m_cncConsolePanel = std::make_unique<CncConsolePanel>();
   m_cncWcsPanel = std::make_unique<CncWcsPanel>();
   ```

3. In `shutdown()`: Reset the panels (same order as other panels):
   ```cpp
   m_cncJogPanel.reset();
   m_cncConsolePanel.reset();
   m_cncWcsPanel.reset();
   ```

4. In `renderPanels()`: Add rendering for each new panel (same pattern as CncStatusPanel):
   ```cpp
   if (m_showCncJog && m_cncJogPanel) {
       m_cncJogPanel->render();
       if (!m_cncJogPanel->isOpen()) {
           m_showCncJog = false;
           m_cncJogPanel->setOpen(true);
       }
   }
   // Same for m_cncConsolePanel and m_cncWcsPanel
   ```

5. In `setWorkspaceMode()`: Update CNC mode to show new panels:
   ```cpp
   if (mode == WorkspaceMode::CNC) {
       m_showCncStatus = true;
       m_showGCode = true;
       m_showCncJog = true;      // NEW
       m_showCncConsole = true;   // NEW
       m_showCncWcs = true;       // NEW
       m_showLibrary = false;
       m_showProperties = false;
       m_showMaterials = false;
       m_showToolBrowser = false;
       m_showCostEstimator = false;
       m_showCutOptimizer = false;
   } else {
       m_showCncStatus = false;
       m_showGCode = false;
       m_showCncJog = false;      // NEW
       m_showCncConsole = false;   // NEW
       m_showCncWcs = false;       // NEW
       m_showLibrary = true;
       m_showProperties = true;
   }
   ```

6. In `renderViewMenu()`: Add menu items for new panels:
   ```cpp
   ImGui::MenuItem("Jog Control", nullptr, &m_showCncJog);
   ImGui::MenuItem("MDI Console", nullptr, &m_showCncConsole);
   ImGui::MenuItem("Work Zero / WCS", nullptr, &m_showCncWcs);
   ```
   Place these near the existing "CNC Status" menu item.

7. In `handleKeyboardShortcuts()`: Add call to keyboard jog handler:
   ```cpp
   // After existing shortcut handling, before the closing brace:
   handleCncKeyboardJog();
   ```

8. Implement `handleCncKeyboardJog()`:
   ```cpp
   void UIManager::handleCncKeyboardJog() {
       // Only active in CNC mode, when no text input has focus
       if (m_workspaceMode != WorkspaceMode::CNC) return;
       if (ImGui::GetIO().WantTextInput) return;
       if (!m_cncJogPanel) return;

       // Delegate to jog panel's keyboard handler
       m_cncJogPanel->handleKeyboardJog();
   }
   ```

This delegates to CncJogPanel which has access to the CncController and current step size.
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors in ui_manager</verify>
  <done>UIManager owns all three new panels, renders them, shows them in CNC workspace mode, has View menu entries, and calls keyboard jog handler</done>
</task>

<task type="auto">
  <name>Task 2: Add keyboard jog and continuous jog to CncJogPanel</name>
  <files>src/ui/panels/cnc_jog_panel.h, src/ui/panels/cnc_jog_panel.cpp</files>
  <action>
Extend CncJogPanel with keyboard jog support (CUI-05) and continuous jog (CUI-06).

**cnc_jog_panel.h additions:**
```cpp
public:
    // Called by UIManager::handleCncKeyboardJog() each frame
    void handleKeyboardJog();

private:
    void jogAxis(int axis, float direction); // Send step jog command
    void startContinuousJog(int axis, float direction, ImGuiKey key);
    void stopContinuousJog();

    // Continuous jog tracking
    int m_contJogAxis = -1;       // -1 = not jogging, 0=X, 1=Y, 2=Z
    float m_contJogDir = 0.0f;    // +1 or -1
    ImGuiKey m_contJogKey = ImGuiKey_None;
    static constexpr float CONTINUOUS_JOG_FEED = 2000.0f; // mm/min
    static constexpr float CONTINUOUS_JOG_DISTANCE = 10000.0f; // Large distance (cancelled on release)
```

**cnc_jog_panel.cpp additions:**

`handleKeyboardJog()`:
```cpp
void CncJogPanel::handleKeyboardJog() {
    if (!m_cnc || !m_connected) return;

    // Check if continuous jog should stop (key released)
    if (m_contJogAxis >= 0) {
        if (!ImGui::IsKeyDown(m_contJogKey)) {
            stopContinuousJog();
        }
        return; // Don't start new jog while continuous is active
    }

    // Check if machine state allows jogging
    if (m_status.state != MachineState::Idle && m_status.state != MachineState::Jog)
        return;

    // Key mapping: arrows for X/Y, page up/down for Z
    struct JogKey {
        ImGuiKey key;
        int axis;      // 0=X, 1=Y, 2=Z
        float dir;     // +1 or -1
    };
    static constexpr JogKey keys[] = {
        {ImGuiKey_RightArrow, 0, +1.0f},  // X+
        {ImGuiKey_LeftArrow,  0, -1.0f},  // X-
        {ImGuiKey_UpArrow,    1, +1.0f},  // Y+
        {ImGuiKey_DownArrow,  1, -1.0f},  // Y-
        {ImGuiKey_PageUp,     2, +1.0f},  // Z+
        {ImGuiKey_PageDown,   2, -1.0f},  // Z-
    };

    for (const auto& k : keys) {
        if (ImGui::IsKeyPressed(k.key, false)) { // false = no repeat
            // Check if key is held (for continuous jog detection)
            // On first press, send a step jog
            jogAxis(k.axis, k.dir);

            // If Shift is held, start continuous jog instead
            if (ImGui::GetIO().KeyShift) {
                startContinuousJog(k.axis, k.dir, k.key);
            }
        }
    }
}
```

`jogAxis()`:
```cpp
void CncJogPanel::jogAxis(int axis, float direction) {
    if (!m_cnc) return;
    static const char* axisLetters = "XYZ";
    float step = STEP_SIZES[m_selectedStep] * direction;
    float feed = JOG_FEEDS[m_selectedStep];
    char cmd[128];
    std::snprintf(cmd, sizeof(cmd), "$J=G91 G21 %c%.3f F%.0f",
                  axisLetters[axis], step, feed);
    m_cnc->sendCommand(cmd);
}
```

`startContinuousJog()`:
```cpp
void CncJogPanel::startContinuousJog(int axis, float direction, ImGuiKey key) {
    if (!m_cnc) return;
    static const char* axisLetters = "XYZ";
    float dist = CONTINUOUS_JOG_DISTANCE * direction;
    char cmd[128];
    std::snprintf(cmd, sizeof(cmd), "$J=G91 G21 %c%.0f F%.0f",
                  axisLetters[axis], dist, CONTINUOUS_JOG_FEED);
    m_cnc->sendCommand(cmd);
    m_contJogAxis = axis;
    m_contJogDir = direction;
    m_contJogKey = key;
}
```

`stopContinuousJog()`:
```cpp
void CncJogPanel::stopContinuousJog() {
    if (m_cnc) {
        m_cnc->jogCancel(); // Sends 0x85 real-time command
    }
    m_contJogAxis = -1;
    m_contJogKey = ImGuiKey_None;
}
```

Also update the existing `render()` method to:
1. Call `stopContinuousJog()` if the panel loses focus or connection drops
2. In `onConnectionChanged()`, stop any active continuous jog on disconnect

**Keyboard jog UX:**
- Bare arrow key press = step jog (uses current step size)
- Shift + arrow key = start continuous jog (large distance, cancel on release)
- This maps cleanly to CNCjs behavior

**Safety: Cancel continuous jog on focus loss.** In `handleKeyboardJog()`, if the ImGui window is not focused (check with `ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)` being false), call `stopContinuousJog()`.
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors</verify>
  <done>Keyboard arrow keys jog X/Y, Page Up/Down jogs Z, Shift+key starts continuous jog that stops on release, focus loss cancels continuous jog</done>
</task>

<task type="auto">
  <name>Task 3: Wire CncController callbacks to all new panels in application_wiring.cpp</name>
  <files>src/app/application_wiring.cpp</files>
  <action>
Extend the CncController callback wiring in application_wiring.cpp to include the three new panels.

Find the section where CncCallbacks are set up (around line 540-566 in current code). This section already captures `gcp` (GCodePanel) and `csp` (CncStatusPanel).

Add captures for new panels:
```cpp
auto* jp = m_uiManager->cncJogPanel();
auto* cp = m_uiManager->cncConsolePanel();
auto* wp = m_uiManager->cncWcsPanel();
```

Update existing callbacks to also notify new panels:

```cpp
cncCb.onConnectionChanged = [gcp, csp, jp, cp, wp](bool connected, const std::string& version) {
    gcp->onGrblConnected(connected, version);
    if (csp) csp->onConnectionChanged(connected, version);
    if (jp) jp->onConnectionChanged(connected, version);
    if (cp) cp->onConnectionChanged(connected, version);
    if (wp) wp->onConnectionChanged(connected, version);
};

cncCb.onStatusUpdate = [gcp, csp, jp, wp](const MachineStatus& status) {
    gcp->onGrblStatus(status);
    if (csp) csp->onStatusUpdate(status);
    if (jp) jp->onStatusUpdate(status);
    if (wp) wp->onStatusUpdate(status);
};

cncCb.onAlarm = [gcp, cp](int code, const std::string& desc) {
    gcp->onGrblAlarm(code, desc);
    if (cp) cp->onAlarm(code, desc);
};

cncCb.onError = [gcp, cp](const std::string& message) {
    gcp->onGrblError(message);
    if (cp) cp->onError(message);
};

cncCb.onRawLine = [gcp, cp, wp](const std::string& line, bool isSent) {
    gcp->onGrblRawLine(line, isSent);
    if (cp) cp->onRawLine(line, isSent);
    if (wp) wp->onRawLine(line, isSent);
};
```

Wire CncController to new panels:
```cpp
if (jp) jp->setCncController(m_cncController.get());
if (cp) cp->setCncController(m_cncController.get());
if (wp) wp->setCncController(m_cncController.get());
```

Add includes at the top for the new panel headers:
```cpp
#include "ui/panels/cnc_jog_panel.h"
#include "ui/panels/cnc_console_panel.h"
#include "ui/panels/cnc_wcs_panel.h"
```

**Important:** Keep the existing callback behavior for GCodePanel and CncStatusPanel intact. Only ADD new panel notifications to the callback chains.
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors in application_wiring.cpp</verify>
  <done>All three new panels receive CncController instance and status/connection/error/rawLine callbacks. Existing GCodePanel and CncStatusPanel wiring preserved.</done>
</task>

</tasks>

<verification>
- [ ] All new panels appear when switching to CNC workspace mode (Ctrl+2)
- [ ] Arrow keys jog X/Y when in CNC mode and no text input focused
- [ ] Page Up/Down jogs Z
- [ ] Shift + arrow starts continuous jog, releasing stops it
- [ ] Keyboard jog does NOT activate when typing in MDI console
- [ ] View menu has entries for all three new panels
- [ ] CncController callbacks reach all new panels
- [ ] Build succeeds with zero errors
</verification>

<success_criteria>
Complete integration: all Phase 3 panels visible in CNC workspace, keyboard jog functional with focus-awareness, continuous jog with Shift modifier, all callbacks wired. The full manual control suite is operational.
</success_criteria>

<output>
After completion, create `.planning/phases/03-manual-control/03-04-SUMMARY.md`
</output>
