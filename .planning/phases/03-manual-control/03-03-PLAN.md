---
phase: 03-manual-control
plan: 03
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - src/ui/panels/cnc_wcs_panel.h
  - src/ui/panels/cnc_wcs_panel.cpp
  - src/core/cnc/cnc_types.h
autonomous: true
requirements: [CUI-08, CUI-09]
must_haves:
  truths:
    - "User can click per-axis zero buttons (X, Y, Z) and a Zero All button to set work zero using G10 L20"
    - "Zero buttons show a confirmation before executing (safety-first design)"
    - "User can switch between G54-G59 coordinate systems by clicking WCS selector buttons"
    - "Current active WCS is visually highlighted"
    - "Stored offsets for each WCS are displayed after querying $#"
  artifacts:
    - path: "src/ui/panels/cnc_wcs_panel.h"
      provides: "CncWcsPanel class declaration"
      contains: "class CncWcsPanel"
    - path: "src/ui/panels/cnc_wcs_panel.cpp"
      provides: "WCS panel with zero-set buttons, WCS selector, and offset display"
      min_lines: 150
    - path: "src/core/cnc/cnc_types.h"
      provides: "WcsOffsets structure for storing parsed $# response data"
      contains: "WcsOffsets"
  key_links:
    - from: "src/ui/panels/cnc_wcs_panel.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "sendCommand() for G10 L20, G54-G59, $#"
      pattern: "sendCommand.*G10|sendCommand.*G5[4-9]|sendCommand.*\\$#"
---

<objective>
Build the CncWcsPanel — work zero setting buttons and work coordinate system (G54-G59) selector with offset display.

Purpose: Enables the operator to set work zero (critical for job alignment) and manage multiple coordinate systems for multi-fixture setups.

Output: New CncWcsPanel class, WcsOffsets type in cnc_types.h.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-manual-control/03-RESEARCH.md
@.planning/phases/03-manual-control/03-01-SUMMARY.md
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_types.h
@src/ui/panels/panel.h
@src/ui/panels/cnc_status_panel.h
@src/ui/panels/cnc_status_panel.cpp
@src/ui/icons.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WcsOffsets type and $# response parsing support</name>
  <files>src/core/cnc/cnc_types.h</files>
  <action>
Add a WcsOffsets structure to cnc_types.h to hold parsed $# response data:

```cpp
// Work coordinate system offsets parsed from $# response
struct WcsOffsets {
    Vec3 g54{0.0f};
    Vec3 g55{0.0f};
    Vec3 g56{0.0f};
    Vec3 g57{0.0f};
    Vec3 g58{0.0f};
    Vec3 g59{0.0f};
    Vec3 g28{0.0f};  // G28 home position
    Vec3 g30{0.0f};  // G30 home position
    Vec3 g92{0.0f};  // G92 offset
    float tlo = 0.0f; // Tool length offset

    // Get offset by WCS index (0=G54, 1=G55, ..., 5=G59)
    Vec3 getByIndex(int idx) const {
        switch (idx) {
        case 0: return g54;
        case 1: return g55;
        case 2: return g56;
        case 3: return g57;
        case 4: return g58;
        case 5: return g59;
        default: return Vec3{0.0f};
        }
    }
};
```

Also add a WCS-related callback to CncCallbacks struct:
```cpp
std::function<void(const WcsOffsets& offsets)> onWcsOffsets;
```

This callback fires when the $# response is fully parsed.

Add a WCS index to MachineStatus (or keep it separate — the active WCS is determined by the last G54-G59 command sent, not from status reports). For simplicity, the WCS panel will track which WCS it last selected.
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors in cnc_types.h consumers</verify>
  <done>WcsOffsets struct exists in cnc_types.h with G54-G59 offsets and getByIndex() accessor. CncCallbacks has onWcsOffsets callback.</done>
</task>

<task type="auto">
  <name>Task 2: Create CncWcsPanel with zero-set and WCS selector</name>
  <files>src/ui/panels/cnc_wcs_panel.h, src/ui/panels/cnc_wcs_panel.cpp</files>
  <action>
Create CncWcsPanel extending Panel.

**cnc_wcs_panel.h:**
```cpp
class CncWcsPanel : public Panel {
public:
    CncWcsPanel();
    ~CncWcsPanel() override = default;
    void render() override;

    void setCncController(CncController* cnc) { m_cnc = cnc; }
    void onStatusUpdate(const MachineStatus& status);
    void onConnectionChanged(bool connected, const std::string& version);
    void onWcsOffsets(const WcsOffsets& offsets);
    // Parse a raw GRBL line for $# offset data
    void onRawLine(const std::string& line, bool isSent);

private:
    void renderZeroButtons();
    void renderWcsSelector();
    void renderOffsetDisplay();
    void requestOffsets(); // Send $# command

    CncController* m_cnc = nullptr;
    MachineStatus m_status{};
    bool m_connected = false;

    // Active WCS: 0=G54, 1=G55, ..., 5=G59
    int m_activeWcs = 0;
    static constexpr const char* WCS_NAMES[] = {"G54", "G55", "G56", "G57", "G58", "G59"};

    // Stored offsets from $# query
    WcsOffsets m_offsets{};
    bool m_offsetsLoaded = false;

    // Confirmation popup state
    bool m_confirmZeroOpen = false;
    std::string m_confirmZeroLabel;
    std::string m_confirmZeroCmd;

    // $# response parsing state
    bool m_parsingOffsets = false;
    WcsOffsets m_pendingOffsets{};
};
```

**cnc_wcs_panel.cpp:**

Constructor: `CncWcsPanel() : Panel("Work Zero / WCS") {}`

`render()`:
1. Standard Panel begin/end pattern.
2. If not connected, show disconnected message.
3. Call renderZeroButtons(), renderWcsSelector(), renderOffsetDisplay().
4. Handle confirmation popup (see below).

`renderZeroButtons()`:
- `ImGui::SeparatorText("Set Work Zero")`
- Show current work position for reference (from m_status.workPos)
- 4 buttons in a row: "Zero X", "Zero Y", "Zero Z", "Zero All"
- Disable when not Idle state
- On click, open a confirmation popup (safety-first per user context):
  - Store the command: e.g., `G10 L20 P{m_activeWcs+1} X0` for Zero X
  - Set m_confirmZeroOpen = true
  - Set m_confirmZeroLabel = "Set X work zero to current position in {WCS_NAMES[m_activeWcs]}?"
- Confirmation popup: `ImGui::OpenPopup("Confirm Zero")` / `BeginPopupModal`:
  - Show the label text
  - Show current position for the axis/axes being zeroed
  - "Confirm" button: send the command, close popup, request new offsets
  - "Cancel" button: close popup
- Use red/warning color for the confirm button to emphasize the action

The G10 L20 P number: P1=G54, P2=G55, ..., P6=G59. So P = m_activeWcs + 1.

Commands:
- Zero X: `G10 L20 P{n} X0`
- Zero Y: `G10 L20 P{n} Y0`
- Zero Z: `G10 L20 P{n} Z0`
- Zero All: `G10 L20 P{n} X0 Y0 Z0`

After sending zero command, call `requestOffsets()` to refresh displayed offsets.

`renderWcsSelector()`:
- `ImGui::SeparatorText("Coordinate System")`
- 6 buttons in a row (or 2 rows of 3): G54, G55, G56, G57, G58, G59
- Highlight the active WCS button with a different color (use `ImGui::PushStyleColor` for the active one)
- On click: send the WCS command (e.g., "G54"), update m_activeWcs, request new offsets
- Disable when streaming

`renderOffsetDisplay()`:
- `ImGui::SeparatorText("Stored Offsets")`
- If !m_offsetsLoaded, show "Send $# to load offsets" with a "Refresh" button
- If loaded, show a small table:
  | WCS | X | Y | Z |
  |-----|---|---|---|
  | G54 | x | y | z |
  | G55 | x | y | z |
  | ... |
- Highlight the active WCS row
- "Refresh" button to re-query $#

`requestOffsets()`: `m_cnc->sendCommand("$#"); m_parsingOffsets = true;`

`onRawLine()`: Parse $# response lines. When a line matches `[G54:x,y,z]` through `[G59:x,y,z]` format:
- Extract WCS name and coordinates using sscanf or string parsing
- Store in m_pendingOffsets
- When all 6 WCS lines parsed (or a non-WCS line arrives after WCS lines), commit: `m_offsets = m_pendingOffsets; m_offsetsLoaded = true; m_parsingOffsets = false;`

Also parse `[TLO:x]` for tool length offset.

Pattern for parsing: check if line starts with "[G5" and contains ":" and "]":
```cpp
if (line.size() > 5 && line[0] == '[' && line[1] == 'G' && line[2] == '5') {
    // Parse [G54:x.xxx,y.yyy,z.zzz]
    char name[4];
    float x, y, z;
    if (sscanf(line.c_str(), "[%3s:%f,%f,%f]", name, &x, &y, &z) == 4) {
        // Store based on name
    }
}
```

`onStatusUpdate()`: Store status.
`onConnectionChanged()`: Store connected state. On connect, request offsets automatically.
`onWcsOffsets()`: Store offsets (alternative callback path if CncController parses them).
  </action>
  <verify>Build compiles: `cd build && cmake --build . 2>&1 | tail -20` — no errors. Verify files exist: `ls src/ui/panels/cnc_wcs_panel.*`</verify>
  <done>CncWcsPanel renders zero-set buttons (X/Y/Z/All) with confirmation dialogs using G10 L20, WCS selector (G54-G59) with active highlight, and offset display from $# query</done>
</task>

</tasks>

<verification>
- [ ] WcsOffsets struct exists in cnc_types.h
- [ ] CncWcsPanel compiles and renders zero buttons, WCS selector, offset display
- [ ] Zero buttons show confirmation before sending G10 L20 command
- [ ] WCS selector sends G54-G59 and highlights active system
- [ ] $# response parsed correctly to populate offset display
- [ ] Offsets refresh after zero-set and WCS switch
- [ ] Buttons disabled in inappropriate states
</verification>

<success_criteria>
CncWcsPanel provides complete work zero and coordinate system management: per-axis and all-axis zero-set with safety confirmation, G54-G59 switching with visual feedback, stored offset display from $# queries.
</success_criteria>

<output>
After completion, create `.planning/phases/03-manual-control/03-03-SUMMARY.md`
</output>
