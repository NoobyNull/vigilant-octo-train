---
phase: 01-add-materials-mapping-to-object-view-with-coordinated-materials-database
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmake/Dependencies.cmake
  - src/CMakeLists.txt
  - src/core/materials/material.h
  - src/core/database/schema.h
  - src/core/database/schema.cpp
  - src/core/database/material_repository.h
  - src/core/database/material_repository.cpp
autonomous: true

must_haves:
  truths:
    - "Materials table exists in SQLite database with all required fields"
    - "MaterialRecord struct represents a wood species with Janka hardness, feed/speed, cost, grain direction"
    - "MaterialRepository can insert, find, update, and delete material records"
    - "MaterialCategory enum covers hardwood, softwood, domestic, composite groupings"
    - "New dependencies (miniz, stb_image, nlohmann/json) compile and link successfully"
  artifacts:
    - path: "src/core/materials/material.h"
      provides: "MaterialRecord struct, MaterialCategory enum, category string conversion"
    - path: "src/core/database/material_repository.h"
      provides: "MaterialRepository CRUD class"
    - path: "src/core/database/material_repository.cpp"
      provides: "MaterialRepository implementation with prepared statements"
    - path: "cmake/Dependencies.cmake"
      provides: "miniz, stb_image, nlohmann/json FetchContent declarations"
  key_links:
    - from: "src/core/database/material_repository.cpp"
      to: "src/core/database/schema.cpp"
      via: "materials table created in schema, queried in repository"
      pattern: "materials"
    - from: "src/core/database/material_repository.h"
      to: "src/core/materials/material.h"
      via: "MaterialRecord used as parameter and return type"
      pattern: "MaterialRecord"
---

<objective>
Add third-party dependencies (miniz, stb_image, nlohmann/json), define the MaterialRecord domain type with MaterialCategory enum, create the materials SQLite table, and implement MaterialRepository for CRUD operations.

Purpose: Establish the data foundation that all subsequent plans build upon — types, schema, and data access.
Output: Compilable project with new dependencies, material types, and working MaterialRepository.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-RESEARCH.md

# Key existing files to reference
@cmake/Dependencies.cmake
@src/CMakeLists.txt
@src/core/database/schema.h
@src/core/database/schema.cpp
@src/core/database/model_repository.h
@src/core/database/model_repository.cpp
@src/core/types.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add third-party dependencies and MaterialRecord types</name>
  <files>
    cmake/Dependencies.cmake
    src/core/materials/material.h
    src/CMakeLists.txt
  </files>
  <action>
    1. Add miniz, stb_image (stb), and nlohmann/json to cmake/Dependencies.cmake using FetchContent (same pattern as existing deps):
       - miniz: GIT_REPOSITORY https://github.com/richgel999/miniz.git, GIT_TAG 3.0.2, create STATIC library from miniz.c
       - stb: GIT_REPOSITORY https://github.com/nothings/stb.git, GIT_TAG master, header-only (just need include dir)
       - nlohmann/json: GIT_REPOSITORY https://github.com/nlohmann/json.git, GIT_TAG v3.11.3, header-only via FetchContent
    2. Link new dependencies to digital_workshop target in src/CMakeLists.txt (add miniz and nlohmann_json::nlohmann_json to target_link_libraries, add stb include dir via target_include_directories)
    3. Create src/core/materials/material.h with:
       - MaterialCategory enum: Hardwood, Softwood, Domestic, Composite (per user decision: hardwood, softwood, domestic, composite)
       - Hardwood: traditional hardwood species (oak, maple, walnut, cherry, etc.)
       - Softwood: coniferous species (pine, cedar, fir, spruce, etc.)
       - Domestic: common North American woods not covered by hardwood/softwood categories
       - Composite: MDF, HDF, plywood, non-ferrous metals, plastics, foams
       - materialCategoryToString() and stringToMaterialCategory() conversion functions
       - MaterialRecord struct with fields: id (i64), name (string), category (MaterialCategory), archivePath (Path), jankaHardness (f32, lbf), feedRate (f32, inches/min), spindleSpeed (f32, RPM), depthOfCut (f32, inches), costPerBoardFoot (f32, USD), grainDirectionDeg (f32, 0-360), thumbnailPath (Path), importedAt (string)
       - All in namespace dw, using #pragma once, following CONVENTIONS.md
    4. Verify the project compiles with the new dependencies by running cmake configure + build.
  </action>
  <verify>
    cd build && cmake .. -DDW_BUILD_TESTS=ON && cmake --build . --target digital_workshop 2>&1 | tail -5
    Should compile without errors. New dependencies should show in cmake status output.
  </verify>
  <done>
    Project compiles with miniz, stb_image, and nlohmann/json available. MaterialRecord struct and MaterialCategory enum defined in material.h.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create materials database schema and MaterialRepository</name>
  <files>
    src/core/database/schema.h
    src/core/database/schema.cpp
    src/core/database/material_repository.h
    src/core/database/material_repository.cpp
    src/CMakeLists.txt
  </files>
  <action>
    1. Update schema.cpp to add materials table (bump CURRENT_VERSION to 4 in schema.h):
       ```sql
       CREATE TABLE IF NOT EXISTS materials (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           name TEXT NOT NULL,
           category TEXT NOT NULL DEFAULT 'hardwood',
           archive_path TEXT,
           janka_hardness REAL DEFAULT 0,
           feed_rate REAL DEFAULT 0,
           spindle_speed REAL DEFAULT 0,
           depth_of_cut REAL DEFAULT 0,
           cost_per_board_foot REAL DEFAULT 0,
           grain_direction_deg REAL DEFAULT 0,
           thumbnail_path TEXT,
           imported_at TEXT DEFAULT CURRENT_TIMESTAMP
       )
       ```
       Add indexes: idx_materials_name ON materials(name), idx_materials_category ON materials(category).
       Also add material_id column to models table: ALTER TABLE or add to CREATE TABLE:
       `material_id INTEGER DEFAULT NULL` with a comment noting FK to materials(id).
       Since we use CREATE IF NOT EXISTS pattern (not migrations), add the column in the CREATE TABLE statement for models.

    2. Create material_repository.h following model_repository.h pattern exactly:
       - Constructor takes Database& reference
       - insert(const MaterialRecord&) -> std::optional<i64>
       - findById(i64) -> std::optional<MaterialRecord>
       - findAll() -> std::vector<MaterialRecord>
       - findByCategory(MaterialCategory) -> std::vector<MaterialRecord>
       - findByName(std::string_view searchTerm) -> std::vector<MaterialRecord>
       - update(const MaterialRecord&) -> bool
       - remove(i64) -> bool
       - count() -> i64
       - Private: rowToMaterial(Statement&) helper

    3. Implement material_repository.cpp following model_repository.cpp patterns:
       - Use prepared statements with bind/step/get
       - findByName uses LIKE '%search%' with proper escaping (per BUG-05 pattern from v1.0)
       - Category stored as string in DB, converted via materialCategoryToString/stringToMaterialCategory

    4. Add material_repository.cpp to src/CMakeLists.txt DW_SOURCES list (in Database section).

    5. Write tests: Create src/tests/test_material_repository.cpp mirroring existing test patterns. Test insert, findById, findAll, findByCategory, findByName, update, remove.
  </action>
  <verify>
    cd build && cmake --build . --target digital_workshop 2>&1 | tail -5
    cd build && cmake --build . --target dw_tests && ./dw_tests --gtest_filter="MaterialRepository*" 2>&1
    All MaterialRepository tests pass.
  </verify>
  <done>
    Materials table created in schema. MaterialRepository implements full CRUD. Models table has material_id column. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --target digital_workshop` compiles without errors
2. `cmake --build build --target dw_tests && build/dw_tests --gtest_filter="MaterialRepository*"` — all tests pass
3. MaterialRecord struct has all required fields (Janka, feed/speed, cost, grain direction)
4. MaterialCategory covers hardwood, softwood, domestic, composite
5. New dependencies (miniz, stb_image, nlohmann/json) are available in the build
</verification>

<success_criteria>
- Project compiles with three new dependencies
- MaterialRecord and MaterialCategory defined
- materials table exists in SQLite schema
- models table has material_id column
- MaterialRepository CRUD operations work (verified by tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-01-SUMMARY.md`
</output>
