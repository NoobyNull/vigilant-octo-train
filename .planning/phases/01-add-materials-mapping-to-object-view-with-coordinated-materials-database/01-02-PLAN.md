---
phase: 01-add-materials-mapping-to-object-view-with-coordinated-materials-database
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/materials/material_archive.h
  - src/core/materials/material_archive.cpp
  - src/core/loaders/texture_loader.h
  - src/core/loaders/texture_loader.cpp
  - src/render/texture.h
  - src/render/texture.cpp
  - src/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "MaterialArchive can create a .dwmat ZIP file from texture PNG + MaterialRecord metadata"
    - "MaterialArchive can load a .dwmat ZIP file and return texture data + metadata"
    - "TextureLoader can load PNG images from file path or memory buffer"
    - "Texture class wraps OpenGL texture ID with RAII lifecycle"
    - "Texture supports GL_REPEAT wrap mode for tileable wood grain textures"
  artifacts:
    - path: "src/core/materials/material_archive.h"
      provides: "MaterialArchive class with create/load/list static methods"
    - path: "src/core/loaders/texture_loader.h"
      provides: "TextureLoader with loadPNG and loadPNGFromMemory"
    - path: "src/render/texture.h"
      provides: "RAII Texture wrapper with upload/bind/unbind"
    - path: "src/render/texture.cpp"
      provides: "OpenGL texture management implementation"
  key_links:
    - from: "src/core/materials/material_archive.cpp"
      to: "miniz library"
      via: "mz_zip_reader/writer API for ZIP operations"
      pattern: "mz_zip"
    - from: "src/core/materials/material_archive.cpp"
      to: "nlohmann/json library"
      via: "JSON serialization of MaterialRecord metadata"
      pattern: "nlohmann::json"
    - from: "src/core/loaders/texture_loader.cpp"
      to: "stb_image library"
      via: "stbi_load for PNG decoding"
      pattern: "stbi_load"
    - from: "src/render/texture.cpp"
      to: "OpenGL API"
      via: "glGenTextures/glBindTexture/glTexImage2D for GPU upload"
      pattern: "glGenTextures"
---

<objective>
Implement the .dwmat archive format (ZIP-based), PNG texture loading via stb_image, and OpenGL texture RAII wrapper.

Purpose: Enable reading/writing portable material archives and loading textures for 3D rendering.
Output: MaterialArchive, TextureLoader, and Texture classes — the I/O and GPU pipeline for materials.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-RESEARCH.md
@.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-01-SUMMARY.md

# Existing patterns to follow
@src/core/archive/archive.h
@src/core/archive/archive.cpp
@src/render/shader.h
@src/render/framebuffer.h
@src/core/materials/material.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MaterialArchive for .dwmat ZIP read/write</name>
  <files>
    src/core/materials/material_archive.h
    src/core/materials/material_archive.cpp
    src/CMakeLists.txt
  </files>
  <action>
    1. Create material_archive.h with MaterialArchive class (static methods, mirroring ProjectArchive pattern):
       - MaterialData struct: textureData (vector of uint8_t), textureWidth (int), textureHeight (int), metadata (MaterialRecord)
       - static create(archivePath, texturePath, MaterialRecord) -> ArchiveResult
       - static load(archivePath) -> std::optional of MaterialData
       - static list(archivePath) -> vector of ArchiveEntry (reuse existing ArchiveEntry from archive.h)
       - static isValidArchive(archivePath) -> bool
       - static constexpr Extension = ".dwmat"
       - Private helpers: metadataToJson(MaterialRecord) -> nlohmann::json, jsonToMaterial(json) -> MaterialRecord

    2. Implement material_archive.cpp using miniz (NOT the custom binary format in archive.cpp):
       - create(): Use mz_zip_writer_init_file, add "texture.png" from file, serialize metadata to JSON and add "metadata.json", finalize
       - load(): Use mz_zip_reader_init_file, extract "texture.png" to memory, extract "metadata.json" to memory, parse JSON to MaterialRecord, close. Do NOT decode the PNG here (that's TextureLoader's job) — return raw PNG bytes.
       - list(): Use mz_zip_reader to enumerate archive entries
       - isValidArchive(): Check file can be opened as ZIP and contains "metadata.json"
       - Archive internal structure (Claude's discretion per CONTEXT.md):
         ```
         material.dwmat (ZIP)
         +-- texture.png        (tileable wood grain)
         +-- metadata.json      (material properties)
         +-- thumbnail.png      (optional, 128x128 preview)
         ```
       - metadata.json format:
         ```json
         {
           "name": "Red Oak",
           "category": "hardwood",
           "janka_hardness": 1290.0,
           "feed_rate": 100.0,
           "spindle_speed": 18000.0,
           "depth_of_cut": 0.125,
           "cost_per_board_foot": 4.50,
           "grain_direction_deg": 0.0,
           "texture_file": "texture.png",
           "version": 1
         }
         ```

    3. Add material_archive.cpp to src/CMakeLists.txt DW_SOURCES (in Archive or Materials section).

    4. Write tests: test_material_archive.cpp — test create archive from a test PNG + metadata, load it back, verify metadata round-trips, verify texture data is non-empty, verify list returns expected entries.
  </action>
  <verify>
    cd build && cmake --build . --target digital_workshop 2>&1 | tail -5
    cd build && cmake --build . --target dw_tests && ./dw_tests --gtest_filter="MaterialArchive*" 2>&1
    All tests pass.
  </verify>
  <done>
    MaterialArchive can create and load .dwmat ZIP files. Metadata round-trips through JSON correctly. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TextureLoader and Texture RAII wrapper</name>
  <files>
    src/core/loaders/texture_loader.h
    src/core/loaders/texture_loader.cpp
    src/render/texture.h
    src/render/texture.cpp
    src/CMakeLists.txt
  </files>
  <action>
    1. Create texture_loader.h in src/core/loaders/:
       - TextureData struct: pixels (vector of uint8_t), width (int), height (int), channels (int)
       - Static methods:
         - loadPNG(const Path& path) -> std::optional of TextureData
         - loadPNGFromMemory(const uint8_t* data, size_t size) -> std::optional of TextureData
       - Both force 4 channels (RGBA) via STBI_rgb_alpha for consistent GPU upload

    2. Create texture_loader.cpp:
       - #define STB_IMAGE_IMPLEMENTATION in this .cpp file ONLY (single compilation unit rule for stb)
       - #include <stb_image.h>
       - loadPNG: Call stbi_load with STBI_rgb_alpha, copy to vector, stbi_image_free
       - loadPNGFromMemory: Call stbi_load_from_memory with STBI_rgb_alpha, copy to vector, stbi_image_free
       - Log errors using dw::log::error with stbi_failure_reason()

    3. Create texture.h in src/render/:
       - Texture class following Shader/Framebuffer RAII pattern:
         - Delete copy, allow move (move constructor + move assignment)
         - upload(const uint8_t* data, int width, int height, GLenum format = GL_RGBA) -> bool
         - bind(unsigned int slot = 0) const
         - unbind() const
         - id() const -> GLuint
         - isValid() const -> bool
         - width() const -> int, height() const -> int
         - setWrap(GLenum wrap) — for GL_REPEAT on tileable textures
         - setFilter(GLenum minFilter, GLenum magFilter) — for GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR
       - Destructor calls glDeleteTextures if m_id != 0

    4. Implement texture.cpp:
       - Constructor: does nothing (lazy init on upload)
       - upload(): glGenTextures, glBindTexture(GL_TEXTURE_2D), glTexImage2D, glGenerateMipmap, set default wrap GL_REPEAT and filter GL_LINEAR_MIPMAP_LINEAR/GL_LINEAR, unbind. Store width/height.
       - bind(): glActiveTexture(GL_TEXTURE0 + slot), glBindTexture(GL_TEXTURE_2D, m_id)
       - unbind(): glBindTexture(GL_TEXTURE_2D, 0)
       - Move semantics: transfer m_id, zero out source
       - setWrap/setFilter: bind, set parameters, unbind

    5. Add texture_loader.cpp and texture.cpp to src/CMakeLists.txt DW_SOURCES.
  </action>
  <verify>
    cd build && cmake --build . --target digital_workshop 2>&1 | tail -5
    Compiles without errors. stb_image.h included and STB_IMAGE_IMPLEMENTATION compiled in exactly one translation unit.
  </verify>
  <done>
    TextureLoader can load PNG files from disk and memory. Texture class wraps OpenGL texture with RAII lifecycle, GL_REPEAT wrap, and mipmap support.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --target digital_workshop` compiles without errors
2. MaterialArchive tests pass (create, load, list, isValidArchive)
3. Texture class compiles with proper RAII (move semantics, no copy)
4. TextureLoader compiles with stb_image (STB_IMAGE_IMPLEMENTATION in exactly one .cpp)
5. No linker errors from duplicate stb_image symbols
</verification>

<success_criteria>
- MaterialArchive creates valid .dwmat ZIP files with texture.png + metadata.json
- MaterialArchive loads .dwmat and returns raw texture bytes + parsed MaterialRecord
- TextureLoader decodes PNG to RGBA pixel data
- Texture class uploads to GPU with GL_REPEAT and mipmaps
- All tests pass, project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-02-SUMMARY.md`
</output>
