---
phase: 01-add-materials-mapping-to-object-view-with-coordinated-materials-database
plan: 04
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/render/shader_sources.h
  - src/render/renderer.h
  - src/render/renderer.cpp
  - src/core/mesh/mesh.h
  - src/core/mesh/mesh.cpp
autonomous: true

must_haves:
  truths:
    - "Renderer can render a mesh with a wood texture mapped to its surface"
    - "Renderer falls back to solid color when no texture is assigned"
    - "Meshes without UV coordinates get auto-generated planar UVs"
    - "Grain direction rotation affects texture mapping on the object"
    - "Existing solid-color and toolpath rendering still works unchanged"
  artifacts:
    - path: "src/render/shader_sources.h"
      provides: "Fragment shader with uUseTexture/uMaterialTexture uniforms"
    - path: "src/render/renderer.h"
      provides: "renderMesh overload accepting Texture pointer"
    - path: "src/core/mesh/mesh.h"
      provides: "generatePlanarUVs() and needsUVGeneration() methods"
  key_links:
    - from: "src/render/renderer.cpp"
      to: "src/render/texture.h"
      via: "Texture::bind() called before draw when material assigned"
      pattern: "texture.*bind"
    - from: "src/render/renderer.cpp"
      to: "src/render/shader_sources.h"
      via: "uUseTexture uniform toggles texture vs solid color"
      pattern: "uUseTexture"
    - from: "src/core/mesh/mesh.cpp"
      to: "src/core/mesh/vertex.h"
      via: "UV coordinates written to Vertex::texCoord"
      pattern: "texCoord"
---

<objective>
Add texture mapping support to the rendering pipeline: update fragment shader with texture sampling, add UV generation for meshes lacking texture coordinates, and extend Renderer to accept material textures.

Purpose: Enable wood grain textures to be displayed on 3D objects in the viewport — the visual core of the materials system.
Output: Shader texture support, automatic UV generation, and Renderer texture binding.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-RESEARCH.md
@.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-02-SUMMARY.md

# Key existing files
@src/render/shader_sources.h
@src/render/renderer.h
@src/render/renderer.cpp
@src/render/texture.h
@src/core/mesh/mesh.h
@src/core/mesh/mesh.cpp
@src/core/mesh/vertex.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UV generation to Mesh class</name>
  <files>
    src/core/mesh/mesh.h
    src/core/mesh/mesh.cpp
  </files>
  <action>
    1. Add to Mesh class in mesh.h:
       - generatePlanarUVs(float grainRotationDeg = 0.0f) — generate UV coordinates via planar projection
       - needsUVGeneration() const -> bool — returns true if all vertex texCoords are zero (STL default)

    2. Implement in mesh.cpp:

       needsUVGeneration():
       - Return true if m_vertices is empty OR if ALL vertices have texCoord == Vec2(0,0)
       - Use std::all_of with epsilon check (fabs(texCoord.x) < 0.0001f && fabs(texCoord.y) < 0.0001f)

       generatePlanarUVs(float grainRotationDeg):
       - If m_vertices empty, return early
       - Compute bounding box (use existing m_bounds)
       - Determine dominant projection plane:
         - size = bounds.max() - bounds.min()
         - For wood grain along longest axis: use the two largest dimensions for UV mapping
         - If size.x >= size.y && size.x >= size.z: use XY if size.y > size.z, else XZ
         - General: pick the plane with largest area
       - For each vertex, compute UV by normalizing position within bounds:
         - u = (position.axis1 - bounds.min.axis1) / size.axis1
         - v = (position.axis2 - bounds.min.axis2) / size.axis2
       - Apply grain direction rotation if grainRotationDeg != 0:
         - rad = glm::radians(grainRotationDeg)
         - Rotate UV around (0.5, 0.5) center:
           u_rot = (u-0.5)*cos(rad) - (v-0.5)*sin(rad) + 0.5
           v_rot = (u-0.5)*sin(rad) + (v-0.5)*cos(rad) + 0.5
       - Guard against zero-size dimensions (divide by zero) — use 1.0f fallback

    3. Write tests in existing test file or new test_mesh_uv.cpp:
       - Test needsUVGeneration returns true for default vertices
       - Test generatePlanarUVs produces non-zero UVs
       - Test grain rotation rotates UVs
  </action>
  <verify>
    cd build && cmake --build . --target dw_tests && ./dw_tests --gtest_filter="*UV*:*Uv*:*uv*" 2>&1
    Tests pass.
  </verify>
  <done>
    Mesh::generatePlanarUVs() creates proper UV coordinates for textureless meshes. Grain rotation applied as UV rotation. needsUVGeneration() correctly detects zero-UV meshes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update shader and Renderer for texture mapping</name>
  <files>
    src/render/shader_sources.h
    src/render/renderer.h
    src/render/renderer.cpp
  </files>
  <action>
    1. Update MESH_FRAGMENT shader in shader_sources.h:
       - Add two new uniforms: `uniform sampler2D uMaterialTexture;` and `uniform bool uUseTexture;`
       - Modify base color computation:
         ```glsl
         vec3 objectColor;
         if (uUseTexture) {
             objectColor = texture(uMaterialTexture, vTexCoord).rgb;
         } else {
             objectColor = uObjectColor;
         }
         ```
       - Keep existing toolpath logic (uIsToolpath overrides both texture and solid color)
       - The ordering should be: if uIsToolpath, use toolpath colors; else if uUseTexture, use texture; else use uObjectColor

    2. Update Renderer class in renderer.h:
       - Add new renderMesh overload: void renderMesh(const Mesh& mesh, const Texture* materialTexture, const Mat4& modelMatrix = Mat4(1.0f))
       - Add same for GPUMesh: void renderMesh(const GPUMesh& gpuMesh, const Texture* materialTexture, const Mat4& modelMatrix = Mat4(1.0f))
       - Keep existing renderMesh(const Mesh&, const Mat4&) and renderMesh(const GPUMesh&, const Mat4&) — they pass nullptr for texture (backward compatible)

    3. Implement in renderer.cpp:
       - In existing renderMesh methods, call the new overload with nullptr for texture
       - In new textured renderMesh:
         - After binding shader and setting existing uniforms:
         - If materialTexture is not nullptr and materialTexture->isValid():
           - m_meshShader.setBool("uUseTexture", true)
           - materialTexture->bind(0) — texture unit 0
           - m_meshShader.setInt("uMaterialTexture", 0)
         - Else:
           - m_meshShader.setBool("uUseTexture", false)
         - After draw call, if texture was bound, unbind it
       - Ensure uUseTexture defaults to false in all existing render paths (renderMesh without texture, renderToolpath)

    4. Verify backward compatibility: existing renderMesh and renderToolpath behavior must remain identical.
  </action>
  <verify>
    cd build && cmake --build . --target digital_workshop 2>&1 | tail -5
    Compiles. Run the application briefly and confirm existing models render with solid color (no visual regression).
  </verify>
  <done>
    Shader supports texture sampling with uUseTexture toggle. Renderer has textured renderMesh overloads. Existing rendering unchanged (backward compatible). Toolpath rendering unaffected.
  </done>
</task>

</tasks>

<verification>
1. `cmake --build build --target digital_workshop` compiles without errors
2. UV generation tests pass
3. Application launches and existing models render with solid color (no regression)
4. Shader compiles at runtime (check for GL errors in log output)
5. Toolpath rendering still shows blue/orange color coding
</verification>

<success_criteria>
- Mesh::generatePlanarUVs() creates proper UV coordinates from mesh bounds
- Mesh::needsUVGeneration() detects zero-UV meshes (typical STL imports)
- Fragment shader toggles between texture and solid color via uUseTexture
- Renderer::renderMesh with Texture* binds texture to GPU before draw
- All existing rendering unchanged (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/01-add-materials-mapping-to-object-view-with-coordinated-materials-database/01-04-SUMMARY.md`
</output>
