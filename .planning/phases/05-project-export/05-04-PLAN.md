---
phase: 05-project-export
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/export/project_export_manager.h
  - src/core/export/project_export_manager.cpp
  - src/managers/file_io_manager.cpp
autonomous: true
requirements: [EXPORT-02]
gap_closure: true

must_haves:
  truths:
    - "After importing a .dwproj, the imported project is automatically opened and set as the current project"
    - "After import, the library panel shows the newly imported models"
  artifacts:
    - path: "src/core/export/project_export_manager.h"
      provides: "DwprojExportResult with importedProjectId field"
      contains: "importedProjectId"
    - path: "src/managers/file_io_manager.cpp"
      provides: "importProjectArchive() success path calls projMgr->open() and setCurrentProject()"
      contains: "projMgr->open"
  key_links:
    - from: "src/core/export/project_export_manager.cpp"
      to: "DwprojExportResult"
      via: "importProject() sets importedProjectId on success"
      pattern: "importedProjectId"
    - from: "src/managers/file_io_manager.cpp"
      to: "src/core/project/project.h"
      via: "projMgr->open(result.importedProjectId) in import success lambda"
      pattern: "projMgr->open"
---

<objective>
Close Gap 2: Auto-open imported project after .dwproj import completes.

Purpose: After importing a .dwproj archive, the user currently sees a toast but the project is not opened — they must manually find and open it. EXPORT-02 requires the imported project to be immediately active with its models visible in the library.

Output: Modified `DwprojExportResult` with importedProjectId, and updated `file_io_manager.cpp` import success paths to call `projMgr->open()` + `setCurrentProject()`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/05-project-export/05-VERIFICATION.md
@.planning/phases/05-project-export/05-02-SUMMARY.md
@src/core/export/project_export_manager.h
@src/core/export/project_export_manager.cpp
@src/managers/file_io_manager.h
@src/managers/file_io_manager.cpp
@src/core/project/project.h (ProjectManager::open, setCurrentProject)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add importedProjectId to DwprojExportResult and return it from importProject()</name>
  <files>
    src/core/export/project_export_manager.h
    src/core/export/project_export_manager.cpp
  </files>
  <action>
**project_export_manager.h — DwprojExportResult struct:**

Add a new field:
```cpp
std::optional<i64> importedProjectId;  // Set on successful import, nullopt on export or failure
```

Update the `ok()` factory to NOT set this field (it's set manually in importProject). No change to `fail()`.

**project_export_manager.cpp — importProject():**

At the end of importProject(), just before the return statement (line ~292), the `projectId` variable already holds the newly inserted project's ID (from `projectRepo.insert(projRec)` at line ~196). Set it on the result:

```cpp
auto result = DwprojExportResult::ok(importedCount, totalBytes);
result.importedProjectId = *projectId;
return result;
```

Replace the current `return DwprojExportResult::ok(importedCount, totalBytes);` with the above.

This is a minimal, surgical change — only 3 lines added/modified across both files.
  </action>
  <verify>
Run `cmake --build build --target digital_workshop 2>&1 | tail -10` — builds cleanly. Grep for `importedProjectId` in the header to confirm it exists.
  </verify>
  <done>
DwprojExportResult carries the imported project's DB ID after a successful import. Existing callers are unaffected (field is optional, defaults to nullopt).
  </done>
</task>

<task type="auto">
  <name>Task 2: Auto-open imported project in FileIOManager import paths</name>
  <files>
    src/managers/file_io_manager.cpp
  </files>
  <action>
There are TWO code paths that import .dwproj files — both need the same fix:

**Path 1: importProjectArchive() (line ~486, file dialog flow)**

In the background thread lambda, after `exportMgr->importProject()` returns, the result is posted to the main thread via `mtq->enqueue()`. Inside that main-thread lambda (line ~494), the success branch currently calls `setShowStartPage(false)` and shows a toast but does NOT use `projMgr`.

Change the main-thread lambda to capture `projMgr` (it's already captured in the outer thread lambda but not passed to the inner mtq lambda). Update the `mtq->enqueue()` capture list to include `projMgr`. Then in the success branch, add:

```cpp
if (result.success) {
    setShowStartPage(false);

    // Auto-open the imported project
    if (result.importedProjectId) {
        auto project = projMgr->open(*result.importedProjectId);
        if (project) {
            projMgr->setCurrentProject(project);
        }
    }

    ToastManager::instance().show(
        ToastType::Success, "Project Imported",
        archivePath.stem().string() + " (" +
            std::to_string(result.modelCount) + " models)");
}
```

**Path 2: onFilesDropped() drag-and-drop path (line ~144)**

The same pattern exists in `onFilesDropped()` for .dwproj files. The mtq->enqueue lambda (line ~155) captures `projMgr` but never uses it. Add the same auto-open logic inside the success branch:

```cpp
if (result.success) {
    if (result.importedProjectId) {
        auto project = projMgr->open(*result.importedProjectId);
        if (project) {
            projMgr->setCurrentProject(project);
        }
    }

    ToastManager::instance().show(
        ToastType::Success, "Project Imported",
        archivePath.stem().string() + " (" +
            std::to_string(result.modelCount) + " models)");
}
```

**Important:** `projMgr->open()` and `setCurrentProject()` MUST run on the main thread (they touch UI state). Both call sites are already inside `mtq->enqueue()` lambdas, so this is safe.

**Note:** The library panel refresh happens automatically when the current project changes (via EventBus notifications from ProjectManager), so no explicit library refresh call is needed. If the EventBus does NOT auto-refresh, add a comment noting this may need a manual `library->refresh()` call wired through a callback — but based on how `openRecentProject()` works (line ~362, no explicit refresh), the EventBus pattern should handle it.
  </action>
  <verify>
Run `cmake --build build --target digital_workshop 2>&1 | tail -10` — builds cleanly. Grep `file_io_manager.cpp` for `projMgr->open` to confirm both import paths auto-open the project. Verify `projMgr` appears in the mtq->enqueue capture lists for both lambdas.
  </verify>
  <done>
Both import paths (file dialog and drag-and-drop) auto-open the imported project via projMgr->open() + setCurrentProject(). The imported project becomes active immediately after import, and its models are visible in the library.
  </done>
</task>

</tasks>

<verification>
1. DwprojExportResult has `std::optional<i64> importedProjectId` field
2. importProject() sets importedProjectId on success
3. importProjectArchive() file dialog path calls projMgr->open() on success
4. onFilesDropped() drag-and-drop path calls projMgr->open() on success
5. Both auto-open calls run on the main thread (inside mtq->enqueue)
6. Application builds cleanly
</verification>

<success_criteria>
- After File > Import .dwproj completes, the imported project is the active project
- After drag-and-drop of .dwproj completes, the imported project is the active project
- Library panel shows the imported project's models without manual navigation
- Existing export functionality is unaffected (importedProjectId is nullopt for exports)
</success_criteria>

<output>
After completion, create `.planning/phases/05-project-export/05-04-SUMMARY.md`
</output>
