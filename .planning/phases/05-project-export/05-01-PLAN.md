---
phase: 05-project-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/export/project_export_manager.h
  - src/core/export/project_export_manager.cpp
  - tests/test_project_export_manager.cpp
  - src/CMakeLists.txt
autonomous: true
requirements: [EXPORT-01, EXPORT-02]

must_haves:
  truths:
    - "A project with models can be exported to a .dwproj ZIP file containing manifest.json and model blobs"
    - "A .dwproj ZIP can be imported, creating DB records and extracting model blobs"
    - "Unknown manifest fields are silently ignored on import (forward compatibility)"
    - "Export produces a manifest with format_version, app_version, created_at, project_id, and models[]"
    - "Import on a different machine recreates all models with correct metadata"
  artifacts:
    - path: "src/core/export/project_export_manager.h"
      provides: "ProjectExportManager class with exportProject() and importProject() methods"
      exports: ["ProjectExportManager", "DwprojExportResult"]
    - path: "src/core/export/project_export_manager.cpp"
      provides: "ZIP creation via miniz, manifest via nlohmann/json, blob extraction"
      min_lines: 150
    - path: "tests/test_project_export_manager.cpp"
      provides: "Unit tests for export/import round-trip"
      min_lines: 50
  key_links:
    - from: "src/core/export/project_export_manager.cpp"
      to: "miniz"
      via: "mz_zip_writer_* and mz_zip_reader_* APIs"
      pattern: "mz_zip_writer_add_mem|mz_zip_reader_extract"
    - from: "src/core/export/project_export_manager.cpp"
      to: "nlohmann/json"
      via: "manifest serialization/deserialization"
      pattern: "nlohmann::json|json::parse"
    - from: "src/core/export/project_export_manager.cpp"
      to: "src/core/database/model_repository.h"
      via: "reading model records for export, creating records on import"
      pattern: "ModelRepository|ModelRecord"
---

<objective>
Create the ProjectExportManager component that handles exporting a project to a .dwproj ZIP archive and importing a .dwproj archive back into the application.

Purpose: This is the core business logic for project portability. The .dwproj format bundles a JSON manifest with model blob files into a standard ZIP archive, enabling users to share projects between machines.

Output: `src/core/export/project_export_manager.h`, `src/core/export/project_export_manager.cpp`, and tests.
</objective>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/research/FEATURES.md (Project Export section)
@.planning/research/ARCHITECTURE.md (Section 5: Project Export)
@src/core/archive/archive.h (existing archive patterns — NOT reused, but shows conventions)
@src/core/archive/archive.cpp
@src/core/database/model_repository.h (ModelRecord struct, repository API)
@src/core/database/project_repository.h (ProjectRecord, project-model links)
@src/core/project/project.h (Project class, ProjectManager)
@src/core/export/model_exporter.h (existing export component — separate concern, mesh export)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProjectExportManager with export and import logic</name>
  <files>
    src/core/export/project_export_manager.h
    src/core/export/project_export_manager.cpp
    src/CMakeLists.txt
  </files>
  <action>
Create `src/core/export/project_export_manager.h` (max 400 lines) with:

```cpp
namespace dw {

struct DwprojExportResult {
    bool success = false;
    std::string error;
    int modelCount = 0;
    uint64_t totalBytes = 0;
};

// Progress callback: (current, total, currentItemName)
using ExportProgressCallback = std::function<void(int, int, const std::string&)>;

class ProjectExportManager {
public:
    ProjectExportManager(Database& db);

    // Export current project to .dwproj ZIP at outputPath
    DwprojExportResult exportProject(const Project& project,
                                     const Path& outputPath,
                                     ExportProgressCallback progress = nullptr);

    // Import .dwproj ZIP, creating project + models in DB
    DwprojExportResult importProject(const Path& archivePath,
                                     ExportProgressCallback progress = nullptr);

    static constexpr const char* Extension = ".dwproj";
    static constexpr int FormatVersion = 1;

private:
    std::string buildManifestJson(const Project& project,
                                  const std::vector<ModelRecord>& models);
    bool parseManifest(const std::string& json, /* out params */);

    Database& m_db;
};
}
```

Create `src/core/export/project_export_manager.cpp` (max 800 lines) implementing:

**exportProject():**
1. Open a `mz_zip_archive` writer via `mz_zip_writer_init_file()` targeting `outputPath`.
2. Query `ProjectRepository` for model IDs via `getModelIds(project.id())`.
3. For each model ID, query `ModelRepository::findById()` to get the `ModelRecord`.
4. Build manifest JSON using nlohmann/json with these 5 required fields:
   - `format_version`: integer `1`
   - `app_version`: string (use a compile-time constant like `"1.1.0"` or git hash if available)
   - `created_at`: ISO-8601 UTC timestamp (use `std::chrono::system_clock::now()`)
   - `project_id`: the project's database ID
   - `project_name`: project name
   - `models[]`: array of objects, each with: `name`, `hash`, `original_filename` (basename of filePath), `file_in_archive` (path inside ZIP like `models/<hash>.<ext>`), `tags` (array), `vertex_count`, `triangle_count`, `bounds_min` [x,y,z], `bounds_max` [x,y,z]
5. Add `manifest.json` to the ZIP via `mz_zip_writer_add_mem()`.
6. For each model, read the blob file from `model.filePath` using `file::readBinary()`, then add it to ZIP as `models/<hash>.<ext>` via `mz_zip_writer_add_mem()`. Call progress callback after each model.
7. Finalize with `mz_zip_writer_finalize_archive()` and `mz_zip_writer_end()`.
8. On any failure, clean up partial ZIP file (delete it).

**importProject():**
1. Open archive with `mz_zip_reader_init_file()`.
2. Find and extract `manifest.json` from ZIP via `mz_zip_reader_extract_file_to_heap()`.
3. Parse JSON with `nlohmann::json::parse()`. If `format_version` > FormatVersion, log warning but continue (forward compat). Silently ignore unknown top-level keys.
4. For each model in `models[]`:
   a. Check if model hash already exists in DB via `ModelRepository::exists(hash)`. If yes, skip blob extraction (dedup), but still link to project.
   b. If not exists: extract blob from ZIP (`models/<hash>.<ext>`) to a temp file, then copy/rename to the model's expected file path. Create a new `ModelRecord` and insert via `ModelRepository::insert()`.
   c. Call progress callback after each model.
5. Create a new `ProjectRecord` with the imported name, insert via `ProjectRepository::insert()`.
6. Link all models to the new project via `ProjectRepository::addModel()`.
7. Close reader with `mz_zip_reader_end()`.

**Important implementation notes:**
- Use `#include <miniz.h>` for ZIP operations (already linked in the project).
- Use `#include <nlohmann/json.hpp>` for JSON (already linked).
- Path traversal security: validate that extracted paths don't contain `..`.
- The `models/` directory in the ZIP uses flat hash-based naming: `models/<full_hash>.<ext>` (no CAS sharding inside the ZIP — that is for disk layout only).
- For import, the model's `filePath` in the new DB record should point to wherever the blob is extracted to. Since CAS (Phase 2) may or may not exist yet, use a simple `models/` subdirectory under the app data dir. Store as: `<data_dir>/models/<hash>.<ext>`.
- Include `#include "../database/model_repository.h"` and `#include "../database/project_repository.h"`.
- Include `#include "../utils/file_utils.h"` for `file::readBinary`, `file::writeBinary`, `file::createDirectories`.
- Include `#include "../paths/app_paths.h"` for `paths::getDataDir()`.

Add `src/core/export/project_export_manager.cpp` to `src/CMakeLists.txt` in the source list (find where `model_exporter.cpp` is listed and add adjacent).
  </action>
  <verify>
Run `cmake --build build --target digital_workshop 2>&1 | tail -20` and confirm project_export_manager.cpp compiles without errors. Check for zero warnings related to the new file.
  </verify>
  <done>
ProjectExportManager compiles, has exportProject() and importProject() methods that use miniz for ZIP and nlohmann/json for manifest. The manifest contains all 5 required fields. Unknown manifest fields are ignored on import.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for export/import round-trip</name>
  <files>
    tests/test_project_export_manager.cpp
    tests/CMakeLists.txt
  </files>
  <action>
Create `tests/test_project_export_manager.cpp` with Catch2 tests (match existing test patterns in the project):

1. **TEST: Export creates valid ZIP with manifest.json**
   - Create a temp Database (in-memory or temp file).
   - Insert a ProjectRecord and 2 ModelRecords with dummy model files on disk (write small binary content to temp files).
   - Link models to project via ProjectRepository::addModel().
   - Call `exportProject()` to a temp .dwproj path.
   - Verify the .dwproj file exists and is > 0 bytes.
   - Open the ZIP with miniz reader and verify `manifest.json` exists.
   - Parse manifest.json and verify: format_version == 1, project_name matches, models array has 2 entries, each entry has hash, name, file_in_archive fields.

2. **TEST: Import round-trip preserves model metadata**
   - Export a project (reuse setup from test 1).
   - Create a second temp Database (simulating a different machine).
   - Call `importProject()` on the exported .dwproj.
   - Verify: new project exists in DB with correct name, project has 2 models linked, each model has correct hash/name/vertex_count/triangle_count, model blob files exist on disk.

3. **TEST: Import ignores unknown manifest fields (forward compat)**
   - Manually create a .dwproj ZIP with a manifest.json that includes an extra unknown field (e.g., `"future_feature": true`).
   - Import it and verify success (no error).

4. **TEST: Import deduplicates existing models**
   - Insert a model with hash "abc123" into the DB.
   - Import a .dwproj containing a model with the same hash.
   - Verify only 1 model with that hash exists in DB (not duplicated), but the project still links to it.

Add the test file to `tests/CMakeLists.txt` following existing patterns.
  </action>
  <verify>
Run `cmake --build build --target tests 2>&1 | tail -10` to confirm test compiles. Run `./build/tests --test-case="*ProjectExport*" -v` and verify all tests pass.
  </verify>
  <done>
All 4 test cases pass: export creates valid ZIP, round-trip preserves metadata, unknown fields ignored, dedup works on import.
  </done>
</task>

</tasks>

<verification>
1. `project_export_manager.h` exists under 400 lines with ProjectExportManager class
2. `project_export_manager.cpp` exists under 800 lines with full export/import implementation
3. Application target builds cleanly with the new source file
4. Test target builds and all ProjectExport tests pass
5. Exported .dwproj is a valid ZIP containing manifest.json + model blobs
</verification>

<success_criteria>
- ProjectExportManager can export a project with N models to a .dwproj ZIP
- ProjectExportManager can import a .dwproj ZIP, creating project + model records
- Manifest contains format_version, app_version, created_at, project_id, models[]
- Unknown manifest fields are silently ignored (forward compatibility)
- Duplicate models (by hash) are not re-imported but are linked to the new project
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-project-export/05-01-SUMMARY.md`
</output>
