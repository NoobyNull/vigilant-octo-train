---
phase: 05-project-export
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/export/project_export_manager.h
  - src/core/export/project_export_manager.cpp
  - tests/test_project_export_manager.cpp
autonomous: true
requirements: [EXPORT-01]
gap_closure: true

must_haves:
  truths:
    - "Exported .dwproj archive contains materials/ directory with .dwmat files for each model that has a material assigned"
    - "Exported .dwproj archive contains thumbnails/ directory with .png files for each model that has a thumbnail"
    - "Manifest models[] entries include material_id and thumbnail_in_archive fields"
    - "Imported project restores material assignments (material_id on model records)"
    - "Imported project restores thumbnail files and updates model thumbnailPath"
  artifacts:
    - path: "src/core/export/project_export_manager.cpp"
      provides: "Material and thumbnail export/import logic added to existing exportProject() and importProject()"
    - path: "src/core/export/project_export_manager.h"
      provides: "ManifestModel struct extended with materialId and thumbnailInArchive fields"
  key_links:
    - from: "src/core/export/project_export_manager.cpp"
      to: "src/core/database/material_repository.h"
      via: "MaterialRepository::findById() to fetch material records for export"
      pattern: "MaterialRepository|MaterialRecord"
    - from: "src/core/export/project_export_manager.cpp"
      to: "src/core/materials/material_archive.h"
      via: "Reading .dwmat files from archivePath for bundling into ZIP"
      pattern: "archivePath|dwmat"
---

<objective>
Close Gap 1: Add materials and thumbnails to .dwproj archive export and import.

Purpose: EXPORT-01 requires the .dwproj archive to contain materials and thumbnails alongside manifest and model blobs. Currently only manifest.json and models/ are included. This plan adds materials/ and thumbnails/ directories to the archive, updates the manifest schema, and restores them on import.

Output: Modified `project_export_manager.h` and `.cpp` with material/thumbnail bundling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-project-export/05-VERIFICATION.md
@.planning/phases/05-project-export/05-01-SUMMARY.md
@src/core/export/project_export_manager.h
@src/core/export/project_export_manager.cpp
@src/core/database/material_repository.h
@src/core/materials/material.h
@src/core/materials/material_archive.h
@src/core/database/model_repository.h
@src/core/paths/app_paths.h
@src/core/utils/file_utils.h
@tests/test_project_export_manager.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add material and thumbnail export to ProjectExportManager</name>
  <files>
    src/core/export/project_export_manager.h
    src/core/export/project_export_manager.cpp
  </files>
  <action>
**project_export_manager.h changes:**

1. Add `#include "../database/material_repository.h"` (MaterialRepository is already transitively included via model_repository.h but material_repository.h is needed for MaterialRecord lookups).

2. Extend the `ManifestModel` struct with two new fields:
   ```cpp
   std::optional<i64> materialId;           // material_id from models table (NULL if none)
   std::string materialInArchive;           // e.g. "materials/3.dwmat" (empty if no material)
   std::string thumbnailInArchive;          // e.g. "thumbnails/<hash>.png" (empty if no thumbnail)
   ```

3. Add a private helper:
   ```cpp
   std::optional<i64> getModelMaterialId(i64 modelId);
   ```

**project_export_manager.cpp changes — exportProject():**

After writing model blobs to the ZIP (the existing for-loop over models), add two new phases:

**Phase A — Export thumbnails:**
For each model in `models`, check if `model.thumbnailPath` is non-empty and the file exists on disk. If so:
- Read the thumbnail PNG via `file::readBinary(model.thumbnailPath)`.
- Add to ZIP as `thumbnails/<hash>.png` using `mz_zip_writer_add_mem()`.
- Record the archive path in a `std::unordered_map<std::string, std::string> hashToThumbnailArchPath` for manifest use.

**Phase B — Export materials:**
For each model in `models`:
- Query the material_id for this model. Use a raw SQL query: `SELECT material_id FROM models WHERE id = ?` (implement in `getModelMaterialId()`).
- If material_id is non-NULL, use `MaterialRepository::findById(materialId)` to get the `MaterialRecord`.
- If the material's `archivePath` is non-empty and the .dwmat file exists, read it via `file::readBinary(archivePath)`.
- Add to ZIP as `materials/<materialId>.dwmat` using `mz_zip_writer_add_mem()`.
- Track which material IDs have already been written (use `std::unordered_set<i64> writtenMaterialIds`) to avoid duplicating materials shared by multiple models.
- Store the mapping from modelId to materialId and archive path for manifest use.

**Manifest changes — buildManifestJson():**

The function signature should be extended to accept additional context. The cleanest approach: change buildManifestJson to accept the models vector plus two maps:
- `std::unordered_map<i64, i64> modelIdToMaterialId` (model DB id -> material DB id)
- `std::unordered_map<std::string, std::string> hashToThumbnailPath` (model hash -> archive path like "thumbnails/abc.png")

In the JSON model entry, add:
- `"material_id"`: the material's DB id (or omit/null if none). This is used on import to re-link.
- `"material_in_archive"`: string like `"materials/3.dwmat"` (or empty string if none).
- `"thumbnail_in_archive"`: string like `"thumbnails/<hash>.png"` (or empty string if none).

**parseManifest() changes:**

In the model parsing loop, read the new optional fields:
```cpp
if (mj.contains("material_id") && !mj["material_id"].is_null()) {
    mm.materialId = mj["material_id"].get<i64>();
}
mm.materialInArchive = mj.value("material_in_archive", "");
mm.thumbnailInArchive = mj.value("thumbnail_in_archive", "");
```

**importProject() changes:**

After the existing model import loop, add two restoration phases:

**Phase A — Restore thumbnails:**
For each imported model that has a non-empty `thumbnailInArchive`:
- Extract the PNG from ZIP to `paths::getThumbnailDir() / <hash>.png`.
- Update the model record's thumbnailPath via `modelRepo.updateThumbnail(modelId, thumbnailPath)`.

**Phase B — Restore materials:**
Track which materials have already been imported (by original material_id) using `std::unordered_map<i64, i64> oldToNewMaterialId`.
For each model that has a non-empty `materialInArchive`:
- If this material_id has already been imported (in the map), just do the assignment.
- Otherwise: extract the .dwmat file from ZIP to `paths::getMaterialsDir() / <filename>`. Insert a new `MaterialRecord` via `MaterialRepository::insert()` with the archive path pointing to the extracted file. Use `MaterialArchive::load()` to extract metadata from the .dwmat if available, or create a minimal record with name derived from the filename.
- Assign the material to the model using a raw SQL: `UPDATE models SET material_id = ? WHERE id = ?` (or add a method call if MaterialManager is accessible — but since we only have Database&, use raw SQL via `m_db.prepare()`).
- Map old material_id -> new material_id for subsequent models sharing the same material.

**Important notes:**
- Add `#include "../materials/material_archive.h"` to the .cpp file.
- The thumbnail and material phases should report progress via the callback (update total count to include thumbnails + materials).
- Path traversal check applies to material and thumbnail archive paths too.
- Materials are keyed by their original DB id in the archive (not hash) since materials don't have content hashes.
  </action>
  <verify>
Run `cmake --build build --target digital_workshop 2>&1 | tail -30` and confirm no compile errors. Grep the .cpp for "materials/" and "thumbnails/" to confirm both paths are written to the ZIP.
  </verify>
  <done>
exportProject() writes materials/*.dwmat and thumbnails/*.png into the ZIP alongside models/. importProject() extracts both, creates MaterialRecords, assigns material_id on imported models, and restores thumbnail paths. Manifest includes material_id, material_in_archive, and thumbnail_in_archive per model.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tests for material and thumbnail round-trip</name>
  <files>
    tests/test_project_export_manager.cpp
  </files>
  <action>
Add a new test case to the existing test file:

**TEST: Export/import round-trip preserves materials and thumbnails**

1. Set up an in-memory Database with schema.
2. Insert a MaterialRecord (name="Red Oak", category=Hardwood) via MaterialRepository. Note the material_id.
3. Create a small fake .dwmat file on disk at a temp path (can be a minimal valid ZIP or just bytes — the export reads it as raw binary). Set the MaterialRecord's archivePath to this temp file.
4. Insert a ModelRecord with a known hash. Write a small binary blob for the model file.
5. Write a small PNG file (can be a minimal 1x1 PNG or just dummy bytes) to a temp path and set as the model's thumbnailPath. Update via `modelRepo.updateThumbnail()`.
6. Assign the material to the model: `UPDATE models SET material_id = ? WHERE id = ?`.
7. Create a ProjectRecord, link the model to it.
8. Export the project to a temp .dwproj path.
9. Open the ZIP with miniz and verify:
   - `materials/<materialId>.dwmat` exists in the archive.
   - `thumbnails/<hash>.png` exists in the archive.
   - `manifest.json` model entry has `material_id`, `material_in_archive`, `thumbnail_in_archive` fields.
10. Create a second in-memory Database.
11. Import the .dwproj into the second DB.
12. Verify the imported model has a non-empty thumbnailPath and the file exists on disk.
13. Verify the imported model has material_id set (query `SELECT material_id FROM models WHERE id = ?`).
14. Verify a MaterialRecord exists in the second DB.

Keep the test focused — this is the critical gap verification. The existing 4 tests should continue to pass unchanged (materials/thumbnails are optional in the archive, so old tests with no materials should still work).
  </action>
  <verify>
Run `cmake --build build --target tests 2>&1 | tail -10` to confirm test compiles. Run `./build/tests --test-case="*ProjectExport*" -v` and verify all tests pass (existing 4 + new 1).
  </verify>
  <done>
New test confirms materials and thumbnails survive export/import round-trip. All 5 ProjectExport tests pass. Existing tests are not broken by the new optional fields.
  </done>
</task>

</tasks>

<verification>
1. `project_export_manager.h` ManifestModel has materialId, materialInArchive, thumbnailInArchive fields
2. `project_export_manager.cpp` exportProject() writes materials/ and thumbnails/ to ZIP
3. `project_export_manager.cpp` importProject() restores materials and thumbnails from ZIP
4. `project_export_manager.cpp` buildManifestJson() includes material/thumbnail archive paths
5. All 5 ProjectExport unit tests pass
6. Application target builds cleanly
</verification>

<success_criteria>
- Exported .dwproj ZIP contains materials/<id>.dwmat for each assigned material
- Exported .dwproj ZIP contains thumbnails/<hash>.png for each model with a thumbnail
- Manifest model entries include material_id, material_in_archive, thumbnail_in_archive
- Import restores material files, creates MaterialRecords, assigns material_id on models
- Import restores thumbnail files and updates model thumbnailPath
- Shared materials (same material on multiple models) are deduplicated in the archive
- All existing tests continue to pass (backward compatible — old archives without materials/thumbnails still import fine)
</success_criteria>

<output>
After completion, create `.planning/phases/05-project-export/05-03-SUMMARY.md`
</output>
