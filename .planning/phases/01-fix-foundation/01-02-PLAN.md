---
phase: 01-fix-foundation
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/core/cnc/cnc_controller.h
  - src/core/cnc/cnc_controller.cpp
autonomous: true
requirements:
  - FND-01
  - FND-03

must_haves:
  truths:
    - "feedHold(), cycleStart(), softReset(), and all override methods never call m_port.writeByte() directly -- all serial writes go through the IO thread"
    - "Real-time commands posted from the UI thread are dispatched by the IO thread within one loop iteration (~20ms max latency)"
    - "The IO thread detects USB disconnect via SerialPort::connectionState() and notifies the UI within 2 seconds"
    - "Connection loss during streaming triggers disconnect handling and stops the stream"
  artifacts:
    - path: "src/core/cnc/cnc_controller.h"
      provides: "Atomic command bitmask, override command queue, disconnect detection state"
      contains: "m_pendingRtCommands"
    - path: "src/core/cnc/cnc_controller.cpp"
      provides: "dispatchPendingCommands() called each IO loop, disconnect check after readLine()"
      contains: "dispatchPendingCommands"
  key_links:
    - from: "cnc_controller.cpp::feedHold()"
      to: "m_pendingRtCommands atomic bitmask"
      via: "fetch_or to set RT_FEED_HOLD bit"
      pattern: "fetch_or.*RT_FEED_HOLD"
    - from: "cnc_controller.cpp::ioThreadFunc()"
      to: "dispatchPendingCommands()"
      via: "called at top of each loop iteration"
      pattern: "dispatchPendingCommands"
    - from: "cnc_controller.cpp::ioThreadFunc()"
      to: "m_port.connectionState()"
      via: "checked after readLine returns, triggers disconnect on Disconnected state"
      pattern: "connectionState.*Disconnected"
---

<objective>
Eliminate thread safety violations in CncController command dispatch (FND-01) and add controller-level USB disconnect detection (FND-03).

Purpose: All real-time command methods (feedHold, cycleStart, softReset, overrides, jogCancel, unlock) currently call m_port.writeByte() directly from the UI thread while the IO thread simultaneously uses m_port. This is a data race. The fix routes all serial writes through the IO thread using an atomic command bitmask for single-byte commands and a mutex-protected queue for multi-byte override sequences. Additionally, the IO thread now monitors SerialPort::connectionState() to detect USB disconnects and report them to the UI.

Output: Updated cnc_controller.h and cnc_controller.cpp with thread-safe command dispatch and disconnect detection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fix-foundation/01-CONTEXT.md
@.planning/phases/01-fix-foundation/01-RESEARCH.md
@.planning/phases/01-fix-foundation/01-01-SUMMARY.md
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_controller.cpp
@src/core/cnc/serial_port.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add atomic command bitmask and override queue to CncController</name>
  <files>src/core/cnc/cnc_controller.h, src/core/cnc/cnc_controller.cpp</files>
  <action>
  1. In cnc_controller.h, add an enum for real-time command bits (inside the class or in a nested namespace):
     ```cpp
     enum RtCommand : uint32_t {
         RT_FEED_HOLD    = 1 << 0,
         RT_CYCLE_START  = 1 << 1,
         RT_SOFT_RESET   = 1 << 2,
         RT_JOG_CANCEL   = 1 << 3,
     };
     ```

  2. Add private members to CncController:
     ```cpp
     // Thread-safe command dispatch (UI thread -> IO thread)
     std::atomic<uint32_t> m_pendingRtCommands{0};

     // Override commands need multiple bytes, use mutex-protected queue
     struct OverrideCmd {
         std::vector<u8> bytes;
     };
     std::mutex m_overrideMutex;
     std::vector<OverrideCmd> m_pendingOverrides;
     ```

  3. Add private method declaration: `void dispatchPendingCommands();`

  4. Rewrite feedHold() to post to the atomic bitmask instead of direct port write:
     ```cpp
     void CncController::feedHold() {
         m_pendingRtCommands.fetch_or(RT_FEED_HOLD, std::memory_order_release);
         m_held = true;
     }
     ```

  5. Rewrite cycleStart() similarly:
     ```cpp
     void CncController::cycleStart() {
         m_pendingRtCommands.fetch_or(RT_CYCLE_START, std::memory_order_release);
         m_held = false;
     }
     ```

  6. Rewrite softReset():
     ```cpp
     void CncController::softReset() {
         m_pendingRtCommands.fetch_or(RT_SOFT_RESET, std::memory_order_release);
         m_streaming = false;
         m_held = false;
         {
             std::lock_guard<std::mutex> lock(m_streamMutex);
             m_sentLengths.clear();
             m_bufferUsed = 0;
         }
         // Note: drain() will be called by the IO thread after dispatching the reset
     }
     ```

  7. Rewrite jogCancel():
     ```cpp
     void CncController::jogCancel() {
         m_pendingRtCommands.fetch_or(RT_JOG_CANCEL, std::memory_order_release);
     }
     ```

  8. Rewrite setFeedOverride() to build a byte sequence and enqueue it:
     ```cpp
     void CncController::setFeedOverride(int percent) {
         OverrideCmd cmd;
         cmd.bytes.push_back(cnc::CMD_FEED_100_PERCENT);
         int diff = percent - 100;
         while (diff >= 10)  { cmd.bytes.push_back(cnc::CMD_FEED_PLUS_10);  diff -= 10; }
         while (diff <= -10) { cmd.bytes.push_back(cnc::CMD_FEED_MINUS_10); diff += 10; }
         while (diff > 0)    { cmd.bytes.push_back(cnc::CMD_FEED_PLUS_1);   diff--; }
         while (diff < 0)    { cmd.bytes.push_back(cnc::CMD_FEED_MINUS_1);  diff++; }
         {
             std::lock_guard<std::mutex> lock(m_overrideMutex);
             m_pendingOverrides.push_back(std::move(cmd));
         }
     }
     ```

  9. Rewrite setRapidOverride() and setSpindleOverride() similarly -- build byte vector, enqueue via m_overrideMutex.

  10. Rewrite unlock() to enqueue through the override queue (it sends a string "$X\n"):
      Add a `std::mutex m_cmdStringMutex;` and `std::vector<std::string> m_pendingStringCmds;`
      ```cpp
      void CncController::unlock() {
          std::lock_guard<std::mutex> lock(m_cmdStringMutex);
          m_pendingStringCmds.push_back("$X\n");
      }
      ```

  11. Implement dispatchPendingCommands() -- called by IO thread each loop:
      ```cpp
      void CncController::dispatchPendingCommands() {
          // 1. Dispatch single-byte real-time commands (atomic, no lock needed)
          uint32_t pending = m_pendingRtCommands.exchange(0, std::memory_order_acquire);
          // Soft reset first (highest priority safety command)
          if (pending & RT_SOFT_RESET) {
              m_port.writeByte(cnc::CMD_SOFT_RESET);
              m_port.drain();
              return; // After soft reset, don't send anything else this cycle
          }
          if (pending & RT_FEED_HOLD)   m_port.writeByte(cnc::CMD_FEED_HOLD);
          if (pending & RT_CYCLE_START) m_port.writeByte(cnc::CMD_CYCLE_START);
          if (pending & RT_JOG_CANCEL)  m_port.writeByte(0x85);

          // 2. Dispatch override byte sequences
          {
              std::lock_guard<std::mutex> lock(m_overrideMutex);
              for (const auto& cmd : m_pendingOverrides) {
                  for (u8 b : cmd.bytes)
                      m_port.writeByte(b);
              }
              m_pendingOverrides.clear();
          }

          // 3. Dispatch string commands (e.g., $X unlock)
          {
              std::lock_guard<std::mutex> lock(m_cmdStringMutex);
              for (const auto& s : m_pendingStringCmds)
                  m_port.write(s);
              m_pendingStringCmds.clear();
          }
      }
      ```

  12. In ioThreadFunc(), call dispatchPendingCommands() at the TOP of the while(m_running) loop, BEFORE readLine(). This ensures real-time commands are dispatched with minimal latency:
      ```cpp
      while (m_running) {
          // Dispatch any pending commands from UI thread
          dispatchPendingCommands();

          // Read responses
          auto line = m_port.readLine(20);
          // ... rest of existing loop
      }
      ```

  13. In connect(), the initial soft reset + drain that happens before the IO thread starts is fine to keep as direct m_port calls since the IO thread hasn't started yet. Keep that as-is.

  14. In requestStatus(), this is ALREADY called from the IO thread (inside ioThreadFunc), so the existing `m_port.writeByte(cnc::CMD_STATUS_QUERY)` call is safe. Keep it as-is.

  15. In sendNextLines(), already called from IO thread, m_port.write() is safe. Keep as-is.
  </action>
  <verify>
  - Project compiles: `cmake --build build --target dw 2>&1 | tail -5`
  - Confirm no direct port writes in UI-callable methods:
    `grep -n "m_port\.\(write\|writeByte\)" src/core/cnc/cnc_controller.cpp`
    -- should only appear in dispatchPendingCommands(), sendNextLines(), requestStatus(), connect(), and the initial banner detection in ioThreadFunc()
  - Confirm dispatchPendingCommands is called in IO loop:
    `grep -n "dispatchPendingCommands" src/core/cnc/cnc_controller.cpp`
  </verify>
  <done>
  - feedHold(), cycleStart(), softReset(), jogCancel() post to atomic bitmask, never touch m_port directly
  - setFeedOverride(), setRapidOverride(), setSpindleOverride() enqueue byte sequences via mutex
  - unlock() enqueues string command via mutex
  - dispatchPendingCommands() called at top of IO loop dispatches all pending commands
  - Soft reset has highest priority and causes early return (no other commands sent that cycle)
  - No data races on m_port: all writes happen on the IO thread only
  - Project compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add controller-level USB disconnect detection and reporting</name>
  <files>src/core/cnc/cnc_controller.cpp, src/core/cnc/cnc_controller.h</files>
  <action>
  1. Add private members to cnc_controller.h for disconnect tracking:
     ```cpp
     int m_consecutiveTimeouts = 0;
     static constexpr int MAX_CONSECUTIVE_TIMEOUTS = 10; // 10 * 20ms readLine timeout = 200ms, but accounting for status poll interval: ~2 seconds of no response
     bool m_statusPending = false; // True after sending '?', false after receiving '<...>'
     ```

  2. In ioThreadFunc(), after the `auto line = m_port.readLine(20);` call, add disconnect detection:
     ```cpp
     // Check SerialPort connection state for hardware-level disconnect
     if (m_port.connectionState() == ConnectionState::Disconnected ||
         m_port.connectionState() == ConnectionState::Error) {
         log::error("CNC", "Serial port reports disconnected");
         handleDisconnect();
         break; // Exit IO thread
     }

     if (line) {
         m_consecutiveTimeouts = 0; // Got data, reset counter
         // ... existing processing
     } else {
         // No data -- possible timeout or disconnect
         if (m_statusPending) {
             m_consecutiveTimeouts++;
             if (m_consecutiveTimeouts >= MAX_CONSECUTIVE_TIMEOUTS) {
                 log::error("CNC", "No response to status queries -- connection lost");
                 handleDisconnect();
                 break;
             }
         }
     }
     ```

  3. In requestStatus(), set `m_statusPending = true;` after sending the query.

  4. In processResponse(), when a status report is received (line starts with '<'), set `m_statusPending = false;` and `m_consecutiveTimeouts = 0;`.

  5. Add private method handleDisconnect():
     ```cpp
     void CncController::handleDisconnect() {
         m_connected = false;
         bool wasStreaming = m_streaming.exchange(false);
         m_held = false;

         // Clear streaming state
         {
             std::lock_guard<std::mutex> lock(m_streamMutex);
             m_sentLengths.clear();
             m_bufferUsed = 0;
         }

         // Notify UI
         if (m_mtq && m_callbacks.onConnectionChanged)
             m_mtq->enqueue([cb = m_callbacks.onConnectionChanged]() {
                 cb(false, "");
             });

         if (wasStreaming && m_mtq && m_callbacks.onError)
             m_mtq->enqueue([cb = m_callbacks.onError]() {
                 cb("Connection lost during streaming -- job aborted. Manual reconnect required.");
             });
     }
     ```

  6. Add handleDisconnect() declaration to the private section of cnc_controller.h.

  7. Reset m_consecutiveTimeouts and m_statusPending in connect() (before starting IO thread) and in disconnect().
  </action>
  <verify>
  - Project compiles: `cmake --build build --target dw 2>&1 | tail -5`
  - Grep confirms disconnect detection: `grep -n "handleDisconnect\|consecutiveTimeouts\|connectionState" src/core/cnc/cnc_controller.cpp`
  - Grep confirms status pending tracking: `grep -n "m_statusPending" src/core/cnc/cnc_controller.cpp`
  </verify>
  <done>
  - IO thread checks SerialPort::connectionState() each iteration and calls handleDisconnect() on Disconnected/Error
  - Consecutive timeout counter triggers disconnect if status queries go unanswered for ~2 seconds
  - handleDisconnect() clears all state, stops streaming, and notifies UI via callbacks
  - Connection loss during streaming produces a clear error message via onError callback
  - No auto-reconnect -- user must manually reconnect (per user decision)
  - Project compiles without errors
  </done>
</task>

</tasks>

<verification>
- `grep -c "m_port\.writeByte\|m_port\.write" src/core/cnc/cnc_controller.cpp` -- count should be significantly fewer than before in non-IO-thread methods
- `grep "dispatchPendingCommands" src/core/cnc/cnc_controller.cpp | wc -l` -- at least 2 (declaration + call in loop)
- `grep "handleDisconnect" src/core/cnc/cnc_controller.cpp | wc -l` -- at least 3 (definition + call sites)
- `grep "m_pendingRtCommands" src/core/cnc/cnc_controller.cpp | wc -l` -- at least 5 (one per command + exchange in dispatch)
- Project builds successfully
</verification>

<success_criteria>
- Zero direct m_port.write/writeByte calls from UI-callable methods (feedHold, cycleStart, softReset, overrides, jogCancel, unlock)
- All serial writes happen on the IO thread only
- USB disconnect detected within ~2 seconds via connectionState() check AND consecutive timeout counter
- Disconnect during streaming produces clear error message to UI
- No auto-reconnect behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-fix-foundation/01-02-SUMMARY.md`
</output>
