---
phase: 01-fix-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/cnc/serial_port.h
  - src/core/cnc/serial_port.cpp
autonomous: true
requirements:
  - FND-03
  - FND-04

must_haves:
  truths:
    - "SerialPort::open() does not toggle DTR, so connecting to an Arduino GRBL board does not reset it"
    - "SerialPort::readLine() detects USB disconnect via POLLHUP/POLLERR and reports it distinctly from a timeout"
    - "SerialPort::write() retries on partial writes instead of returning failure"
    - "SerialPort exposes connection state (connected, disconnected, error) that consumers can query"
  artifacts:
    - path: "src/core/cnc/serial_port.h"
      provides: "ConnectionState enum and connectionState() getter"
      contains: "ConnectionState"
    - path: "src/core/cnc/serial_port.cpp"
      provides: "DTR suppression via HUPCL clear and TIOCMBIC ioctl, POLLHUP/POLLERR detection, partial write retry loop"
      contains: "TIOCMBIC"
  key_links:
    - from: "serial_port.cpp::open()"
      to: "termios HUPCL flag"
      via: "tty.c_cflag &= ~HUPCL and ioctl TIOCMBIC"
      pattern: "TIOCMBIC"
    - from: "serial_port.cpp::readLine()"
      to: "poll revents"
      via: "POLLHUP | POLLERR check before POLLIN"
      pattern: "POLLHUP"
---

<objective>
Harden SerialPort for CNC safety: suppress DTR on open (FND-04), detect USB disconnect at the port level (FND-03), and fix partial write handling.

Purpose: SerialPort is the foundation all controller operations build on. DTR suppression prevents dangerous Arduino resets on connect. Disconnect detection enables the controller to react to cable pulls. Partial write handling prevents truncated commands.

Output: Updated serial_port.h and serial_port.cpp with DTR suppression, connection state tracking, POLLHUP/POLLERR detection, and write retry loop.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fix-foundation/01-CONTEXT.md
@.planning/phases/01-fix-foundation/01-RESEARCH.md
@src/core/cnc/serial_port.h
@src/core/cnc/serial_port.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ConnectionState enum and DTR suppression to SerialPort</name>
  <files>src/core/cnc/serial_port.h, src/core/cnc/serial_port.cpp</files>
  <action>
  1. In serial_port.h, add a ConnectionState enum before the SerialPort class:
     ```cpp
     enum class ConnectionState {
         Closed,        // Port not open
         Connected,     // Port open and healthy
         Disconnected,  // Device removed (POLLHUP/POLLERR or consecutive timeouts)
         Error          // Unrecoverable error
     };
     ```

  2. Add to SerialPort class:
     - Private member: `ConnectionState m_connectionState = ConnectionState::Closed;`
     - Public getter: `ConnectionState connectionState() const { return m_connectionState; }`

  3. In serial_port.cpp open(), add DTR suppression:
     - Add `#include <sys/ioctl.h>` at the top (needed for TIOCMBIC)
     - Before the existing `tty.c_cflag |= (CLOCAL | CREAD);` line, add: `tty.c_cflag &= ~HUPCL;`
       (HUPCL must be cleared BEFORE tcsetattr to prevent DTR toggle on close)
     - After `tcflush(m_fd, TCIOFLUSH);` succeeds, add:
       ```cpp
       // Explicitly lower DTR to prevent Arduino auto-reset
       int modemBits = TIOCM_DTR;
       ioctl(m_fd, TIOCMBIC, &modemBits);
       ```
     - Set `m_connectionState = ConnectionState::Connected;` before the return true

  4. In close(), set `m_connectionState = ConnectionState::Closed;`

  5. In the Windows stub open(), keep returning false but also set m_connectionState appropriately.
  </action>
  <verify>
  - Project compiles: `cmake --build build --target dw 2>&1 | tail -5` (check for errors)
  - Grep confirms DTR suppression: `grep -n "TIOCMBIC\|HUPCL" src/core/cnc/serial_port.cpp`
  - Grep confirms ConnectionState: `grep -n "ConnectionState" src/core/cnc/serial_port.h`
  </verify>
  <done>
  - SerialPort::open() clears HUPCL and uses TIOCMBIC to lower DTR after opening
  - ConnectionState enum exists with Closed/Connected/Disconnected/Error values
  - connectionState() getter returns current state
  - Project compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add POLLHUP/POLLERR disconnect detection and partial write retry</name>
  <files>src/core/cnc/serial_port.cpp</files>
  <action>
  1. In readLine(), after `poll()` returns and before checking `POLLIN`, add disconnect detection:
     ```cpp
     // Check for device disconnect/error BEFORE checking for data
     if (pfd.revents & (POLLHUP | POLLERR)) {
         log::error("Serial", "Device disconnected (POLLHUP/POLLERR)");
         m_connectionState = ConnectionState::Disconnected;
         return std::nullopt;
     }
     ```

  2. Also in readLine(), when `::read()` returns 0 or negative (line `if (n <= 0)`), set `m_connectionState = ConnectionState::Disconnected` before returning nullopt. A zero-length read on a serial port typically means the device is gone.

  3. In readLine(), after `poll()` returns a negative value (the `if (ret < 0)` block), set `m_connectionState = ConnectionState::Error` if errno is not EINTR.

  4. In write(), replace the single `::write()` call with a retry loop for partial writes:
     ```cpp
     bool SerialPort::write(const std::string& data) {
         if (m_fd < 0) return false;

         size_t totalWritten = 0;
         while (totalWritten < data.size()) {
             ssize_t written = ::write(m_fd, data.c_str() + totalWritten,
                                       data.size() - totalWritten);
             if (written < 0) {
                 if (errno == EINTR) continue;
                 if (errno == EIO || errno == ENXIO || errno == ENODEV) {
                     m_connectionState = ConnectionState::Disconnected;
                 }
                 log::errorf("Serial", "Write failed: %s", strerror(errno));
                 return false;
             }
             totalWritten += static_cast<size_t>(written);
         }
         return true;
     }
     ```

  5. In writeByte(), add disconnect detection on write failure:
     ```cpp
     if (written != 1) {
         if (errno == EIO || errno == ENXIO || errno == ENODEV) {
             m_connectionState = ConnectionState::Disconnected;
         }
         return false;
     }
     ```

  6. Fix the readLine() timing: replace `remaining -= 10;` with monotonic clock timing:
     ```cpp
     auto startTime = std::chrono::steady_clock::now();
     // ... in the loop, compute remaining:
     auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
         std::chrono::steady_clock::now() - startTime).count();
     remaining = timeoutMs - static_cast<int>(elapsed);
     ```

  7. In the move constructor and move assignment operator, also transfer m_connectionState and reset the source to Closed.
  </action>
  <verify>
  - Project compiles: `cmake --build build --target dw 2>&1 | tail -5`
  - Grep confirms POLLHUP detection: `grep -n "POLLHUP" src/core/cnc/serial_port.cpp`
  - Grep confirms write retry loop: `grep -n "totalWritten" src/core/cnc/serial_port.cpp`
  - Grep confirms monotonic clock in readLine: `grep -n "steady_clock" src/core/cnc/serial_port.cpp`
  </verify>
  <done>
  - readLine() checks POLLHUP and POLLERR flags and sets ConnectionState::Disconnected
  - write() retries on partial writes and detects device removal via errno
  - writeByte() detects device removal via errno
  - readLine() uses monotonic clock for accurate timeout tracking instead of `remaining -= 10`
  - All state transitions set m_connectionState appropriately
  - Project compiles without errors
  </done>
</task>

</tasks>

<verification>
- `grep -c "TIOCMBIC" src/core/cnc/serial_port.cpp` returns 1 (DTR suppression)
- `grep -c "HUPCL" src/core/cnc/serial_port.cpp` returns 1 (HUPCL cleared)
- `grep -c "POLLHUP" src/core/cnc/serial_port.cpp` returns at least 1
- `grep -c "ConnectionState" src/core/cnc/serial_port.h` returns at least 4 (enum + members)
- `grep -c "totalWritten" src/core/cnc/serial_port.cpp` returns at least 1 (partial write retry)
- Project builds successfully
</verification>

<success_criteria>
- DTR is suppressed on every serial port open (HUPCL cleared, TIOCMBIC ioctl called)
- USB disconnect is detectable through ConnectionState after readLine/write calls
- Partial writes are retried until complete or error
- readLine timeout tracking uses monotonic clock
</success_criteria>

<output>
After completion, create `.planning/phases/01-fix-foundation/01-01-SUMMARY.md`
</output>
