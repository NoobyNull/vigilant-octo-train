---
phase: 01-fix-foundation
plan: 03
type: execute
wave: 3
depends_on: [02]
files_modified:
  - src/core/cnc/cnc_controller.h
  - src/core/cnc/cnc_controller.cpp
  - src/core/cnc/cnc_types.h
autonomous: true
requirements:
  - FND-02

must_haves:
  truths:
    - "When GRBL returns error:N during streaming, a soft reset (0x18) is issued immediately to flush GRBL's RX buffer"
    - "After error-triggered soft reset, the UI receives an error callback with the failing line number and error description"
    - "After error-triggered soft reset, m_streaming is false and buffer accounting is cleared"
    - "The controller enters an error state that requires acknowledgment before new operations"
  artifacts:
    - path: "src/core/cnc/cnc_controller.cpp"
      provides: "Error-triggered soft reset in processResponse(), error state management"
      contains: "CMD_SOFT_RESET.*error"
    - path: "src/core/cnc/cnc_controller.h"
      provides: "Error state flag and acknowledgment method"
      contains: "m_errorState"
    - path: "src/core/cnc/cnc_types.h"
      provides: "onStreamingError callback for error-with-context reporting"
      contains: "onStreamingError"
  key_links:
    - from: "cnc_controller.cpp::processResponse()"
      to: "soft reset dispatch"
      via: "When error: received during streaming, posts RT_SOFT_RESET via atomic bitmask"
      pattern: "RT_SOFT_RESET.*error"
    - from: "cnc_controller.cpp::processResponse()"
      to: "onStreamingError callback"
      via: "Enqueues error details to MainThreadQueue"
      pattern: "onStreamingError"
---

<objective>
Implement error-triggered soft reset during streaming (FND-02): when GRBL returns an error during active streaming, immediately issue a soft reset to prevent buffered commands from executing in an incorrect machine state.

Purpose: In character-counting mode, GRBL may have multiple commands buffered in its RX buffer. When one command errors, the remaining buffered commands continue executing blindly. This can cause the machine to move to wrong positions or cut at incorrect parameters. The soft reset flushes GRBL's buffer and stops all motion.

Output: Updated processResponse() with error-triggered soft reset, error state management, and a new onStreamingError callback for rich error reporting.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fix-foundation/01-CONTEXT.md
@.planning/phases/01-fix-foundation/01-RESEARCH.md
@.planning/phases/01-fix-foundation/01-02-SUMMARY.md
@src/core/cnc/cnc_controller.h
@src/core/cnc/cnc_controller.cpp
@src/core/cnc/cnc_types.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add streaming error callback and error state to CncController</name>
  <files>src/core/cnc/cnc_types.h, src/core/cnc/cnc_controller.h</files>
  <action>
  1. In cnc_types.h, add a StreamingError struct after StreamProgress:
     ```cpp
     // Detailed streaming error report
     struct StreamingError {
         int lineIndex = -1;           // Which program line failed
         int errorCode = 0;            // GRBL error code
         std::string errorMessage;     // Human-readable description
         std::string failedLine;       // The actual G-code line that failed
         int linesInFlight = 0;        // How many lines were buffered in GRBL when error occurred
     };
     ```

  2. In cnc_types.h CncCallbacks struct, add a new callback:
     ```cpp
     std::function<void(const StreamingError& error)> onStreamingError;
     ```

  3. In cnc_controller.h, add private members:
     ```cpp
     std::atomic<bool> m_errorState{false};  // True after streaming error, requires acknowledgment
     ```

  4. Add public method to acknowledge error and allow new operations:
     ```cpp
     // Acknowledge streaming error -- must be called before starting new operations
     void acknowledgeError();
     bool isInErrorState() const { return m_errorState.load(); }
     ```

  5. In startStream(), add a guard: if m_errorState is true, refuse to start and log a warning. Return early without starting the stream.
  </action>
  <verify>
  - Project compiles: `cmake --build build --target dw 2>&1 | tail -5`
  - Grep confirms StreamingError struct: `grep -n "StreamingError" src/core/cnc/cnc_types.h`
  - Grep confirms error state: `grep -n "m_errorState" src/core/cnc/cnc_controller.h`
  </verify>
  <done>
  - StreamingError struct defined with line index, error code, message, failed line, and in-flight count
  - onStreamingError callback added to CncCallbacks
  - m_errorState atomic bool tracks whether controller is in error state
  - acknowledgeError() method clears the error state
  - isInErrorState() getter available for UI to query
  - startStream() refuses to start if error state is active
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement error-triggered soft reset in processResponse</name>
  <files>src/core/cnc/cnc_controller.cpp</files>
  <action>
  1. In processResponse(), modify the `error:` handling inside the `if (line == "ok" || line.find("error:") == 0)` block.

  Currently, on error the code just increments m_errorCount and continues. Change it to:

  ```cpp
  if (!ack.ok) {
      try {
          ack.errorCode = std::stoi(line.substr(6));
      } catch (...) {}
      ack.errorMessage = errorDescription(ack.errorCode);
      m_errorCount++;

      if (m_streaming) {
          // CRITICAL SAFETY: Issue soft reset to flush GRBL's RX buffer.
          // Without this, buffered commands continue executing in potentially
          // incorrect machine state after the error.
          m_pendingRtCommands.fetch_or(RT_SOFT_RESET, std::memory_order_release);

          // Capture error details before clearing state
          StreamingError streamErr;
          streamErr.lineIndex = ack.lineIndex;
          streamErr.errorCode = ack.errorCode;
          streamErr.errorMessage = ack.errorMessage;
          if (ack.lineIndex >= 0 && ack.lineIndex < static_cast<int>(m_program.size()))
              streamErr.failedLine = m_program[ack.lineIndex];
          streamErr.linesInFlight = static_cast<int>(m_sentLengths.size());

          // Stop streaming and clear buffer accounting
          m_streaming = false;
          m_held = false;
          m_sentLengths.clear();
          m_bufferUsed = 0;

          // Enter error state -- requires acknowledgment before new operations
          m_errorState = true;

          // Notify UI with detailed error report
          if (m_mtq && m_callbacks.onStreamingError) {
              m_mtq->enqueue([cb = m_callbacks.onStreamingError, streamErr]() {
                  cb(streamErr);
              });
          }

          // Also fire the line ack callback so UI can track the specific line
          if (m_mtq && m_callbacks.onLineAcked) {
              m_mtq->enqueue([cb = m_callbacks.onLineAcked, ack]() { cb(ack); });
          }
          return; // Don't process further -- stream is terminated
      }
  }
  ```

  2. Implement acknowledgeError():
     ```cpp
     void CncController::acknowledgeError() {
         m_errorState = false;
         log::info("CNC", "Streaming error acknowledged by operator");
     }
     ```

  3. In startStream(), add the error state guard at the beginning:
     ```cpp
     void CncController::startStream(const std::vector<std::string>& lines) {
         if (m_errorState) {
             log::error("CNC", "Cannot start stream while in error state -- call acknowledgeError() first");
             if (m_mtq && m_callbacks.onError) {
                 m_mtq->enqueue([cb = m_callbacks.onError]() {
                     cb("Cannot start new job: previous streaming error must be acknowledged first");
                 });
             }
             return;
         }
         // ... existing startStream logic
     }
     ```

  4. In disconnect(), clear the error state: `m_errorState = false;`

  5. In softReset() (the public method), also clear the error state since the user is explicitly resetting: `m_errorState = false;`

  6. Make sure the dispatchPendingCommands() soft reset handling (from Plan 02) calls m_port.drain() after sending the reset byte. The IO thread will pick up the RT_SOFT_RESET bit on the next iteration and dispatch it.
  </action>
  <verify>
  - Project compiles: `cmake --build build --target dw 2>&1 | tail -5`
  - Grep confirms soft reset on streaming error: `grep -n "RT_SOFT_RESET" src/core/cnc/cnc_controller.cpp`
  - Grep confirms error state management: `grep -n "m_errorState" src/core/cnc/cnc_controller.cpp`
  - Grep confirms acknowledgeError: `grep -n "acknowledgeError" src/core/cnc/cnc_controller.cpp`
  - Grep confirms startStream guard: `grep -n "errorState\|Cannot start" src/core/cnc/cnc_controller.cpp`
  </verify>
  <done>
  - processResponse() issues soft reset (via RT_SOFT_RESET bitmask) when error: received during streaming
  - Streaming state cleared immediately: m_streaming=false, buffer accounting zeroed
  - StreamingError with full context (line number, error code, failed G-code, in-flight count) sent to UI via onStreamingError callback
  - Controller enters error state requiring acknowledgeError() before new streams
  - startStream() refuses to start in error state and notifies UI why
  - softReset() and disconnect() clear the error state
  - Project compiles without errors
  </done>
</task>

</tasks>

<verification>
- `grep "RT_SOFT_RESET" src/core/cnc/cnc_controller.cpp | wc -l` -- at least 2 (processResponse error path + dispatchPendingCommands)
- `grep "m_errorState" src/core/cnc/cnc_controller.cpp | wc -l` -- at least 4 (set in processResponse, check in startStream, clear in acknowledgeError, clear in disconnect)
- `grep "StreamingError" src/core/cnc/cnc_types.h | wc -l` -- at least 2 (struct definition + callback)
- `grep "acknowledgeError" src/core/cnc/cnc_controller.h | wc -l` -- at least 1
- Project builds successfully
</verification>

<success_criteria>
- Error during streaming triggers immediate soft reset to stop GRBL from executing remaining buffered commands
- UI receives detailed StreamingError with line number, error code, the actual G-code that failed, and how many lines were in-flight
- Error state blocks new streaming until operator acknowledges
- No silent recovery -- error is always visible to operator
</success_criteria>

<output>
After completion, create `.planning/phases/01-fix-foundation/01-03-SUMMARY.md`
</output>
