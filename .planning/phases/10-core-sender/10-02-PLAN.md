---
phase: 10-core-sender
plan: 02
type: execute
wave: 2
depends_on:
  - 10-01
files_modified:
  - src/core/config/config.h
  - src/core/config/config.cpp
  - src/ui/panels/cnc_jog_panel.h
  - src/ui/panels/cnc_jog_panel.cpp
  - src/ui/panels/cnc_status_panel.h
  - src/ui/panels/cnc_status_panel.cpp
autonomous: true
requirements:
  - SND-06
  - SND-07
  - SND-08

must_haves:
  truths:
    - "Operator can jog in 0.01mm increments for precision zeroing"
    - "Small step sizes (0.01-0.1mm) use a separate slower feedrate than medium (1mm) and large (10-100mm) step groups"
    - "Per-step-group feedrates are configurable via Config settings"
    - "WCS selector (G54-G59) is visible in the CNC status panel header for quick switching without opening the full WCS panel"
  artifacts:
    - path: "src/ui/panels/cnc_jog_panel.h"
      provides: "0.01mm step size in STEP_SIZES array, 5 step sizes total"
      contains: "0.01f"
    - path: "src/core/config/config.h"
      provides: "Per-group jog feedrate config keys"
      contains: "getJogFeedSmall"
    - path: "src/ui/panels/cnc_status_panel.cpp"
      provides: "WCS quick-switch combo/buttons"
      contains: "G54"
  key_links:
    - from: "src/ui/panels/cnc_jog_panel.cpp"
      to: "src/core/config/config.h"
      via: "Config::instance().getJogFeedSmall/Medium/Large() for per-group feedrates"
      pattern: "getJogFeed"
    - from: "src/ui/panels/cnc_status_panel.cpp"
      to: "src/core/cnc/cnc_controller.h"
      via: "CncController::sendCommand() for WCS switch commands (G54-G59)"
      pattern: "sendCommand.*G5"
---

<objective>
Add 0.01mm precision jog step, per-step-group configurable feedrates, and WCS quick-switch selector to the status panel header.

Purpose: Enable precision zeroing with fine jog steps at appropriate slow feedrates, and allow quick WCS switching without opening the full coordinate system panel.
Output: 0.01mm step in jog panel, 3 configurable feedrate groups, WCS combo in status panel.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-core-sender/10-01-SUMMARY.md
@src/core/config/config.h
@src/core/config/config.cpp
@src/ui/panels/cnc_jog_panel.h
@src/ui/panels/cnc_jog_panel.cpp
@src/ui/panels/cnc_status_panel.h
@src/ui/panels/cnc_status_panel.cpp
@src/ui/panels/cnc_wcs_panel.h

<interfaces>
From Plan 01 (will exist when this runs):
```cpp
// CncStatusPanel now has:
void setCncController(CncController* cnc);
void onAlarm(int alarmCode, const std::string& desc);
void renderOverrideControls();
void renderCoolantControls();
void renderAlarmBanner();
CncController* m_cnc;
```

From src/ui/panels/cnc_jog_panel.h (current):
```cpp
class CncJogPanel : public Panel {
    // Current step sizes: 0.1, 1, 10, 100
    static constexpr float STEP_SIZES[] = {0.1f, 1.0f, 10.0f, 100.0f};
    static constexpr const char* STEP_LABELS[] = {"0.1", "1", "10", "100"};
    static constexpr int NUM_STEPS = 4;
    int m_selectedStep = 1; // Default to 1mm

    // Current feedrates matched 1:1 to step sizes
    static constexpr float JOG_FEEDS[] = {500.0f, 1000.0f, 2000.0f, 3000.0f};

    void jogAxis(int axis, float direction); // Uses STEP_SIZES[m_selectedStep] and JOG_FEEDS[m_selectedStep]
};
```

From src/ui/panels/cnc_wcs_panel.h:
```cpp
class CncWcsPanel : public Panel {
    int m_activeWcs = 0; // 0=G54, 1=G55, ..., 5=G59
    static constexpr const char* WCS_NAMES[] = {"G54", "G55", "G56", "G57", "G58", "G59"};
    static constexpr int NUM_WCS = 6;
};
```

From src/core/cnc/cnc_controller.h:
```cpp
void sendCommand(const std::string& cmd); // For sending G54-G59 WCS switch commands
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 0.01mm jog step and per-step-group configurable feedrates</name>
  <files>
    src/core/config/config.h
    src/core/config/config.cpp
    src/ui/panels/cnc_jog_panel.h
    src/ui/panels/cnc_jog_panel.cpp
  </files>
  <action>
**Config — per-step-group feedrate settings (SND-07):**

Add 3 getter/setter pairs to Config following existing pattern:
- `getJogFeedSmall()` / `setJogFeedSmall(int)` — default: 200. For 0.01mm and 0.1mm steps. Range: 10-2000 mm/min.
- `getJogFeedMedium()` / `setJogFeedMedium(int)` — default: 1000. For 1mm step. Range: 100-5000 mm/min.
- `getJogFeedLarge()` / `setJogFeedLarge(int)` — default: 3000. For 10mm and 100mm steps. Range: 500-10000 mm/min.

Add private members: `int m_jogFeedSmall = 200;`, `int m_jogFeedMedium = 1000;`, `int m_jogFeedLarge = 3000;`

In config.cpp, add to the INI [CNC] section:
- Keys: `jog_feed_small`, `jog_feed_medium`, `jog_feed_large`
- Load: read int, clamp to valid range
- Save: write int

**CncJogPanel — add 0.01mm step (SND-06) and use per-group feedrates (SND-07):**

1. In cnc_jog_panel.h: Update the step size arrays to include 0.01mm:
```cpp
// Step sizes in mm: 0.01, 0.1, 1, 10, 100
static constexpr float STEP_SIZES[] = {0.01f, 0.1f, 1.0f, 10.0f, 100.0f};
static constexpr const char* STEP_LABELS[] = {"0.01", "0.1", "1", "10", "100"};
static constexpr int NUM_STEPS = 5;
int m_selectedStep = 2; // Default to 1mm (index shifted by 1)
```

2. Remove the hardcoded `JOG_FEEDS[]` array from the header — feedrates will now be looked up dynamically from Config based on step group.

3. In cnc_jog_panel.cpp, update `jogAxis()` to use per-group feedrates from Config:
```cpp
void CncJogPanel::jogAxis(int axis, float direction) {
    if (!m_cnc) return;
    static const char axisLetters[] = {'X', 'Y', 'Z'};
    if (axis < 0 || axis > 2) return;

    float step = STEP_SIZES[m_selectedStep] * direction;

    // Per-step-group feedrate from Config
    auto& cfg = Config::instance();
    float feed;
    if (m_selectedStep <= 1) {
        // Small group: 0.01mm, 0.1mm
        feed = static_cast<float>(cfg.getJogFeedSmall());
    } else if (m_selectedStep == 2) {
        // Medium group: 1mm
        feed = static_cast<float>(cfg.getJogFeedMedium());
    } else {
        // Large group: 10mm, 100mm
        feed = static_cast<float>(cfg.getJogFeedLarge());
    }

    char cmd[128];
    std::snprintf(cmd, sizeof(cmd), "$J=G91 G21 %c%.3f F%.0f",
                  axisLetters[axis], static_cast<double>(step), static_cast<double>(feed));
    m_cnc->sendCommand(cmd);
}
```

4. Update the step size selector rendering in `renderStepSizeSelector()`. The loop already iterates NUM_STEPS radio buttons — it will automatically show 5 buttons now. But with 5 buttons on one line it may be too wide. Add a line break after 3 buttons if the available width is less than 350px:

```cpp
void CncJogPanel::renderStepSizeSelector() {
    ImGui::SeparatorText("Step Size");

    for (int i = 0; i < NUM_STEPS; ++i) {
        if (i > 0) ImGui::SameLine();
        if (ImGui::RadioButton(STEP_LABELS[i], m_selectedStep == i))
            m_selectedStep = i;
    }
    ImGui::SameLine();
    ImGui::TextDisabled("mm");

    // Show active feedrate for the selected step group
    auto& cfg = Config::instance();
    int feed;
    const char* group;
    if (m_selectedStep <= 1) {
        feed = cfg.getJogFeedSmall(); group = "small";
    } else if (m_selectedStep == 2) {
        feed = cfg.getJogFeedMedium(); group = "medium";
    } else {
        feed = cfg.getJogFeedLarge(); group = "large";
    }
    ImGui::TextDisabled("Feed: %d mm/min (%s)", feed, group);
}
```
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- 0.01mm step size available in jog panel for precision zeroing
- 5 step sizes total: 0.01, 0.1, 1, 10, 100mm
- Small group (0.01-0.1mm) uses configurable slow feedrate (default 200 mm/min)
- Medium group (1mm) uses configurable feedrate (default 1000 mm/min)
- Large group (10-100mm) uses configurable fast feedrate (default 3000 mm/min)
- Active feedrate displayed below step selector
  </done>
</task>

<task type="auto">
  <name>Task 2: WCS quick-switch selector in CNC status panel header</name>
  <files>
    src/ui/panels/cnc_status_panel.h
    src/ui/panels/cnc_status_panel.cpp
  </files>
  <action>
**WCS quick-switch (SND-08):**

Add a WCS selector to the CncStatusPanel that allows switching between G54-G59 without opening the full WCS panel.

1. In cnc_status_panel.h, add:
```cpp
private:
    void renderWcsSelector();
    int m_activeWcs = 0; // 0=G54, 1=G55, ..., 5=G59
    static constexpr const char* WCS_NAMES[] = {"G54", "G55", "G56", "G57", "G58", "G59"};
    static constexpr int NUM_WCS = 6;
```

2. In cnc_status_panel.cpp, implement `renderWcsSelector()`:

Place it in the state indicator area, on the same line as the firmware version, right-aligned. This puts it in the "header" area of the status panel where it's always visible.

```cpp
void CncStatusPanel::renderWcsSelector() {
    // WCS combo — compact, right-aligned next to firmware version
    bool canSwitch = m_cnc && m_connected &&
                     (m_status.state == MachineState::Idle ||
                      m_status.state == MachineState::Jog);

    if (!canSwitch) ImGui::BeginDisabled();

    ImGui::SameLine(ImGui::GetContentRegionAvail().x - 70);
    ImGui::SetNextItemWidth(70);
    if (ImGui::BeginCombo("##WCS", WCS_NAMES[m_activeWcs], ImGuiComboFlags_NoArrowButton)) {
        for (int i = 0; i < NUM_WCS; ++i) {
            bool selected = (m_activeWcs == i);
            if (ImGui::Selectable(WCS_NAMES[i], selected)) {
                m_activeWcs = i;
                if (m_cnc) {
                    // Send the WCS selection command (G54 = "G54", etc.)
                    m_cnc->sendCommand(WCS_NAMES[i]);
                }
            }
            if (selected) ImGui::SetItemDefaultFocus();
        }
        ImGui::EndCombo();
    }
    if (ImGui::IsItemHovered(ImGuiHoveredFlags_AllowWhenDisabled)) {
        ImGui::SetTooltip("Work Coordinate System");
    }

    if (!canSwitch) ImGui::EndDisabled();
}
```

3. In `renderStateIndicator()`: After the firmware version line, call `renderWcsSelector()`. The placement should be on the same line as the firmware version text (using SameLine to right-align the WCS combo):

After the existing code:
```cpp
if (!m_version.empty()) {
    ImGui::TextDisabled("GRBL %s", m_version.c_str());
}
```

Add:
```cpp
renderWcsSelector();
```

The `renderWcsSelector()` uses `ImGui::SameLine(...)` internally to position itself on the same line as the firmware version, right-aligned.

4. Note: The WCS panel (CncWcsPanel) tracks `m_activeWcs` independently. The status panel's WCS selector is a convenience shortcut — it sends the G54-G59 command directly. If the WCS panel is also open, both will show the active WCS, but they track independently. This is acceptable — the status panel's selector is a quick-switch, not a synchronized state display.
  </action>
  <verify>cmake --build build -j$(nproc) 2>&1 | tail -5</verify>
  <done>
- WCS selector (G54-G59) visible in status panel header next to firmware version
- Clicking a WCS sends the corresponding G-code command (G54, G55, etc.)
- Selector is disabled during alarm or when not connected
- Compact combo takes minimal header space
  </done>
</task>

</tasks>

<verification>
- cmake --build build -j$(nproc) — builds without errors
- ctest --test-dir build --output-on-failure — all existing tests pass
</verification>

<success_criteria>
- 0.01mm jog step available for precision zeroing
- Per-step-group feedrates configurable: small (0.01-0.1mm), medium (1mm), large (10-100mm)
- Active feedrate displayed below step size selector
- WCS selector (G54-G59) visible in status panel header
- WCS switch sends corresponding G-code command immediately
- All new Config keys persist to INI file
</success_criteria>

<output>
After completion, create `.planning/phases/10-core-sender/10-02-SUMMARY.md`
</output>
