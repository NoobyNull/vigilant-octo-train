# Plan 09-01: Cut List Optimizer — Model Integration & Cost Calculation

## Goal
Connect the CutOptimizerPanel to project models so parts can be auto-populated from model bounding boxes. Add material cost calculation that integrates with the sheet cost and shows per-part and total costs. Add "Import from Project" workflow.

## Context

**Existing optimizer:** Fully functional 2D rectangle packing with BinPacker and Guillotine algorithms, Canvas2D visualization, save/load to database, project association. BUT: all parts must be entered manually — no connection to project models.

**ModelRecord has:** `boundsMin` (Vec3) and `boundsMax` (Vec3) — 3D bounding box. We can derive a 2D footprint for cutting:
- XY plane: `width = boundsMax.x - boundsMin.x`, `height = boundsMax.y - boundsMin.y`
- XZ plane: `width = boundsMax.x - boundsMin.x`, `height = boundsMax.z - boundsMin.z` (more useful for CNC — top-down view)

**CutOptimizerPanel already has:** `ProjectManager*` and `CutPlanRepository*` injected (from v1.5).

**Files to read before implementing:**
- `src/ui/panels/cut_optimizer_panel.h` — current panel state
- `src/ui/panels/cut_optimizer_panel.cpp` — renderPartsEditor(), renderResults()
- `src/core/database/model_repository.h` — ModelRecord with boundsMin/boundsMax
- `src/core/database/project_repository.h` — project model associations
- `src/core/optimizer/sheet.h` — Part struct (id, name, width, height, quantity)
- `src/ui/panels/project_panel.h` — how project models are accessed
- `src/core/database/cost_repository.h` — CostEstimate, CostItem structs

## Tasks

### Task 1: Inject ModelRepository into CutOptimizerPanel

**cut_optimizer_panel.h:**
```cpp
// Forward declaration
class ModelRepository;

// Add setter and member
void setModelRepository(ModelRepository* repo) { m_modelRepo = repo; }
ModelRepository* m_modelRepo = nullptr;
```

**application_wiring.cpp:**
Wire `m_modelRepo` into the panel alongside existing deps.

### Task 2: Add "Import from Project" button in parts editor

**cut_optimizer_panel.cpp — renderPartsEditor():**
Before the manual part entry fields, add an "Import from Project" button:

```cpp
// Import from Project button
if (m_projectManager && m_projectManager->currentProject() && m_modelRepo) {
    if (ImGui::Button("Import from Project")) {
        ImGui::OpenPopup("Import Parts");
    }
    ImGui::SameLine();
    ImGui::TextDisabled("(?)");
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Populate parts from model dimensions in the current project");
    }
    ImGui::Separator();
}
```

### Task 3: Implement "Import Parts" popup

Shows project models with their dimensions, lets user select which to import:

```cpp
if (ImGui::BeginPopupModal("Import Parts", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
    auto project = m_projectManager->currentProject();
    const auto& modelIds = project->modelIds();

    ImGui::Text("Select models to add as cut parts:");
    ImGui::Separator();

    // Projection axis selector
    static int projAxis = 1; // 0=XY, 1=XZ (top-down, default for CNC)
    ImGui::RadioButton("Top-down (XZ)", &projAxis, 1);
    ImGui::SameLine();
    ImGui::RadioButton("Front (XY)", &projAxis, 0);
    ImGui::Spacing();

    // Checkboxes for each model
    static std::vector<bool> selected;
    if (selected.size() != modelIds.size()) {
        selected.assign(modelIds.size(), true);
    }

    for (size_t i = 0; i < modelIds.size(); i++) {
        auto record = m_modelRepo->findById(modelIds[i]);
        if (!record) continue;

        Vec3 size = record->boundsMax - record->boundsMin;
        f32 w, h;
        if (projAxis == 1) { // XZ (top-down)
            w = size.x;
            h = size.z;
        } else { // XY (front)
            w = size.x;
            h = size.y;
        }

        ImGui::PushID(static_cast<int>(i));
        ImGui::Checkbox("", &selected[i]);
        ImGui::SameLine();
        ImGui::Text("%s  (%.1f x %.1f mm)", record->name.c_str(), w, h);
        ImGui::PopID();
    }

    ImGui::Separator();
    ImGui::Spacing();

    if (ImGui::Button("Import Selected", ImVec2(150, 0))) {
        for (size_t i = 0; i < modelIds.size(); i++) {
            if (!selected[i]) continue;
            auto record = m_modelRepo->findById(modelIds[i]);
            if (!record) continue;

            Vec3 size = record->boundsMax - record->boundsMin;
            optimizer::Part part;
            part.id = record->id;
            part.name = record->name;
            if (projAxis == 1) {
                part.width = size.x;
                part.height = size.z;
            } else {
                part.width = size.x;
                part.height = size.y;
            }
            part.quantity = 1;
            m_parts.push_back(part);
        }
        m_hasResults = false; // Invalidate previous results
        selected.clear();
        ImGui::CloseCurrentPopup();
        ToastManager::instance().show(ToastType::Success,
            "Imported", "Parts imported from project models");
    }
    ImGui::SameLine();
    if (ImGui::Button("Cancel", ImVec2(100, 0))) {
        selected.clear();
        ImGui::CloseCurrentPopup();
    }

    ImGui::EndPopup();
}
```

### Task 4: Add cost summary to results display

**cut_optimizer_panel.cpp — renderResults():**
After the existing efficiency stats, add cost breakdown:

```cpp
// Cost summary
if (m_hasResults && m_sheet.cost > 0.0f) {
    ImGui::Separator();
    ImGui::Text("Cost Estimate:");

    f32 sheetCost = m_sheet.cost * static_cast<f32>(m_result.sheetsUsed);
    ImGui::BulletText("Sheets: %d x $%.2f = $%.2f",
        m_result.sheetsUsed, m_sheet.cost, sheetCost);

    // Per-part cost (proportional to area used)
    if (m_result.totalUsedArea > 0.0f) {
        f32 costPerMm2 = sheetCost / (m_result.totalUsedArea + m_result.totalWasteArea);
        ImGui::BulletText("Cost per mm²: $%.6f", costPerMm2);

        // Show per-part costs in a simple table
        if (ImGui::TreeNode("Per-Part Costs")) {
            for (const auto& part : m_parts) {
                f32 partArea = part.width * part.height * static_cast<f32>(part.quantity);
                f32 partCost = partArea * costPerMm2;
                ImGui::Text("  %s: $%.2f (%d pcs)", part.name.c_str(), partCost, part.quantity);
            }
            ImGui::TreePop();
        }
    }

    m_result.totalCost = sheetCost;
}
```

### Task 5: Add sheet cost input to sheet config

**cut_optimizer_panel.cpp — renderSheetConfig():**
After the existing Width/Height/Kerf/Margin fields, add:

```cpp
ImGui::InputFloat("Sheet Cost ($)", &m_sheet.cost, 1.0f, 10.0f, "%.2f");
```

Update the presets to include typical costs:
```cpp
if (ImGui::Button("4x8 Plywood")) {
    m_sheet = {2440.0f, 1220.0f, 45.0f, 0, "4x8 Plywood"};
}
ImGui::SameLine();
if (ImGui::Button("4x8 MDF")) {
    m_sheet = {2440.0f, 1220.0f, 35.0f, 0, "4x8 MDF"};
}
ImGui::SameLine();
if (ImGui::Button("5x5 Baltic Birch")) {
    m_sheet = {1524.0f, 1524.0f, 85.0f, 0, "5x5 Baltic Birch"};
}
```

### Task 6: Add "Send to Cost Panel" button

After the cost summary in renderResults(), add a button to create a CostEstimate:

```cpp
if (m_hasResults && m_sheet.cost > 0.0f) {
    ImGui::Spacing();
    if (ImGui::Button("Add to Cost Estimate")) {
        if (m_onAddToCost) {
            m_onAddToCost(m_result, m_sheet, m_parts);
        }
    }
    if (ImGui::IsItemHovered()) {
        ImGui::SetTooltip("Create a material cost line item in the Cost panel");
    }
}
```

**cut_optimizer_panel.h — add callback:**
```cpp
using AddToCostCallback = std::function<void(
    const optimizer::CutPlan& plan,
    const optimizer::Sheet& sheet,
    const std::vector<optimizer::Part>& parts)>;
void setOnAddToCost(AddToCostCallback cb) { m_onAddToCost = std::move(cb); }

// Member
AddToCostCallback m_onAddToCost;
```

**application_wiring.cpp — wire the callback:**
```cpp
cutOptimizerPanel->setOnAddToCost([this](
        const optimizer::CutPlan& plan,
        const optimizer::Sheet& sheet,
        const std::vector<optimizer::Part>& parts) {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    CostEstimate estimate;
    estimate.name = "Cut Plan - " + sheet.name;
    estimate.projectId = project->id();

    // Material cost item
    CostItem sheetItem;
    sheetItem.name = sheet.name + " sheets";
    sheetItem.category = CostCategory::Material;
    sheetItem.quantity = static_cast<f64>(plan.sheetsUsed);
    sheetItem.rate = static_cast<f64>(sheet.cost);
    sheetItem.total = sheetItem.quantity * sheetItem.rate;
    estimate.items.push_back(sheetItem);

    estimate.recalculate();
    m_costRepo->insert(estimate);

    ToastManager::instance().show(ToastType::Success,
        "Added", "Cost estimate created from cut plan");
});
```

## Verification

1. `cmake --build build -j$(nproc)` — compiles cleanly
2. `build/tests/dw_tests` — all tests pass
3. Open project with models → open Cut Optimizer → "Import from Project" button visible
4. Click Import → see models with dimensions → select → parts populated
5. Set sheet cost → run optimization → cost breakdown shown in results
6. Click "Add to Cost Estimate" → cost item created → appears in Cost panel

## Files Modified

| File | Change |
|------|--------|
| `src/ui/panels/cut_optimizer_panel.h` | Add ModelRepository*, AddToCostCallback, imports |
| `src/ui/panels/cut_optimizer_panel.cpp` | Import popup, cost summary, sheet cost presets |
| `src/app/application_wiring.cpp` | Wire ModelRepository and AddToCost callback |
