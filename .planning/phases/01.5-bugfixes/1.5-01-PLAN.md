---
phase: 01.5-bugfixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/render/shader.h
  - src/render/shader.cpp
  - src/render/renderer.cpp
  - src/render/shader_sources.h
autonomous: true

must_haves:
  truths:
    - "Shader uniform cache caches not-found (-1) locations and does not re-query glGetUniformLocation every frame"
    - "Normal matrix is computed as transpose(inverse(mat3(modelMatrix))) for correct lighting under non-uniform scaling"
    - "Shader class supports setMat3 uniform setter"
  artifacts:
    - path: "src/render/shader.h"
      provides: "Shader class with std::optional uniform cache and setMat3 method"
      contains: "std::optional"
    - path: "src/render/shader.cpp"
      provides: "getUniformLocation caching all lookups including -1, and setMat3 implementation"
      contains: "std::optional"
    - path: "src/render/renderer.cpp"
      provides: "Proper normal matrix computation using glm::transpose(glm::inverse())"
      contains: "glm::transpose"
    - path: "src/render/shader_sources.h"
      provides: "Mesh vertex shader using mat3 uNormalMatrix"
      contains: "uniform mat3 uNormalMatrix"
  key_links:
    - from: "src/render/renderer.cpp"
      to: "src/render/shader.cpp"
      via: "setMat3 call for normal matrix"
      pattern: "setMat3.*uNormalMatrix"
    - from: "src/render/shader_sources.h"
      to: "src/render/renderer.cpp"
      via: "uNormalMatrix uniform type agreement (mat3)"
      pattern: "uniform mat3 uNormalMatrix"
---

<objective>
Fix BUG-04 (shader uniform cache semantics) and BUG-07 (normal matrix for non-uniform scaling).

Purpose: BUG-04 causes glGetUniformLocation to be called every frame for any uniform that doesn't exist in the shader (e.g., debug uniforms), wasting GPU driver time. BUG-07 causes incorrect lighting when models have non-uniform scaling because the normal matrix is just the model matrix instead of transpose(inverse(mat3(model))).

Output: Correct shader uniform caching with std::optional, new setMat3 method, and proper normal matrix computation in the renderer.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01.5-bugfixes/1.5-RESEARCH.md
@src/render/shader.h
@src/render/shader.cpp
@src/render/renderer.cpp
@src/render/renderer.h
@src/render/shader_sources.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix shader uniform cache with std::optional and add setMat3</name>
  <files>src/render/shader.h, src/render/shader.cpp</files>
  <action>
BUG-04: The current uniform cache (`std::unordered_map<std::string, GLint>`) only caches valid locations. When a uniform doesn't exist (returns -1), it is NOT cached, causing glGetUniformLocation to be called every frame for that name.

Fix `shader.h`:
1. Add `#include <optional>` to includes.
2. Change the cache type from `std::unordered_map<std::string, GLint>` to `std::unordered_map<std::string, std::optional<GLint>>`.
3. Add a new public method: `void setMat3(const std::string& name, const Mat3& value);` — this requires adding `using Mat3 = glm::mat3;` to `core/types.h` if not already present, OR use `glm::mat3` directly in the signature. Check `core/types.h` first for existing Mat3 alias.
4. Add `#include <glm/gtc/type_ptr.hpp>` if not already included (needed for glm::value_ptr with mat3).

Fix `shader.cpp`:
1. Update `getUniformLocation()`:
   - When cache hit: return `it->second.value_or(-1)` (this handles both cached valid and cached not-found).
   - When cache miss: query `glGetUniformLocation`, then ALWAYS cache the result: use `std::optional<GLint>{location}` for valid locations, `std::nullopt` for -1.
   - Remove the `if (location != -1)` guard — cache ALL results.
2. Add `setMat3` implementation:
   ```cpp
   void Shader::setMat3(const std::string& name, const glm::mat3& value) {
       glUniformMatrix3fv(getUniformLocation(name), 1, GL_FALSE, glm::value_ptr(value));
   }
   ```

The existing comment "Only cache valid locations; -1 means not found, allow re-lookup" should be removed or updated to reflect the new behavior: "Cache all lookups including not-found to avoid repeated glGetUniformLocation calls."
  </action>
  <verify>
The project must compile: `cmake --build /data/DW/build --target dw 2>&1 | tail -20`

Verify the cache type changed: grep for `std::optional` in shader.h
Verify setMat3 exists: grep for `setMat3` in shader.h and shader.cpp
Verify getUniformLocation caches all results: grep for `value_or` in shader.cpp
  </verify>
  <done>
- shader.h declares uniform cache as `std::unordered_map<std::string, std::optional<GLint>>`
- shader.h declares `setMat3` public method
- shader.cpp getUniformLocation caches ALL lookups (valid and -1)
- shader.cpp implements setMat3 using glUniformMatrix3fv
- Project compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix normal matrix computation in renderer and shader</name>
  <files>src/render/renderer.cpp, src/render/shader_sources.h</files>
  <action>
BUG-07: The renderer currently passes the full model matrix as the normal matrix (`m_meshShader.setMat4("uNormalMatrix", modelMatrix)`), which is incorrect for non-uniform scaling. The shader extracts mat3 from it (`mat3(uNormalMatrix)`) but this still carries the wrong values.

Fix `renderer.cpp` (around line 107-109):
1. Replace the existing lines:
   ```cpp
   // Calculate normal matrix (inverse transpose of model matrix for lighting)
   // For simplicity, assuming uniform scaling
   m_meshShader.setMat4("uNormalMatrix", modelMatrix);
   ```
   With:
   ```cpp
   // Calculate normal matrix: transpose(inverse(mat3(model))) for correct lighting
   // under non-uniform scaling
   glm::mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));
   m_meshShader.setMat3("uNormalMatrix", normalMatrix);
   ```
2. Ensure `#include <glm/gtc/matrix_inverse.hpp>` is present (or that glm::inverse works on mat3 — it does via the core header `<glm/glm.hpp>` which is already included via types.h).

Fix `shader_sources.h`:
1. In `MESH_VERTEX`, change `uniform mat4 uNormalMatrix;` to `uniform mat3 uNormalMatrix;`
2. In `MESH_VERTEX`, change `vNormal = mat3(uNormalMatrix) * aNormal;` to `vNormal = uNormalMatrix * aNormal;` (since it's already mat3, no conversion needed).

The fragment shader does NOT need changes — it already uses `normalize(vNormal)` which is correct.
  </action>
  <verify>
The project must compile: `cmake --build /data/DW/build --target dw 2>&1 | tail -20`

Verify normal matrix computation: grep for `glm::transpose.*glm::inverse` in renderer.cpp
Verify shader uniform type: grep for `uniform mat3 uNormalMatrix` in shader_sources.h
Verify setMat3 is used: grep for `setMat3` in renderer.cpp
  </verify>
  <done>
- renderer.cpp computes normal matrix as glm::transpose(glm::inverse(glm::mat3(modelMatrix)))
- renderer.cpp uses setMat3 (not setMat4) for uNormalMatrix
- shader_sources.h MESH_VERTEX declares uNormalMatrix as mat3
- shader_sources.h MESH_VERTEX uses uNormalMatrix directly (not mat3(uNormalMatrix))
- Project compiles without errors
  </done>
</task>

</tasks>

<verification>
1. Full project build succeeds: `cmake --build /data/DW/build --target dw`
2. All existing tests pass: `cmake --build /data/DW/build --target dw_tests && /data/DW/build/dw_tests`
3. Shader uniform cache uses std::optional pattern
4. Normal matrix computed correctly for non-uniform scaling
5. Shader and renderer agree on mat3 type for uNormalMatrix
</verification>

<success_criteria>
- BUG-04 fixed: uniform cache stores all lookups (valid and not-found) using std::optional
- BUG-07 fixed: normal matrix is transpose(inverse(mat3(model))), shader declares uniform mat3
- Shader class has setMat3 method for mat3 uniforms
- Project compiles, all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01.5-bugfixes/1.5-01-SUMMARY.md`
</output>
