# Phase 1.5: Bug Fixes - Research

**Researched:** 2026-02-08
**Domain:** C++ bug fixing, performance optimization, thread safety, OpenGL rendering
**Confidence:** HIGH

## Summary

Phase 1.5 addresses 7 distinct bugs spanning rendering performance (BUG-01), algorithmic efficiency (BUG-02), RAII correctness (BUG-03), cache semantics (BUG-04), SQL injection (BUG-05), threading safety (BUG-06), and graphics correctness (BUG-07). Each bug has been investigated by examining the actual source code and understanding the root cause.

The bugs fall into natural groupings: rendering issues (BUG-01, BUG-07), simple algorithmic fixes (BUG-02, BUG-03, BUG-04), database security (BUG-05), and threading (BUG-06). All fixes are straightforward with well-established solutions in the C++ and OpenGL communities.

**Primary recommendation:** Fix bugs in logical groups (rendering, core utilities, database, threading) with corresponding test coverage for each. BUG-05 is ALREADY FIXED (escapeLike is implemented and used). BUG-06 depends on Sub-Phase 1.3 (MainThreadQueue) and should be deferred.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| C++17 | std=c++17 | Language standard | Already used in codebase (std::optional, std::string_view) |
| GLM | 0.9.x | Math library | Already dependency, provides glm::transpose, glm::inverse, glm::mat3 |
| std::fmod | C++17 <cmath> | Floating-point modulo | Standard library, replaces manual loops for angle wrapping |
| std::optional | C++17 <optional> | Optional values | Already used extensively in codebase (11 files) |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| GoogleTest | Current | Unit testing | Test coverage for bug fixes (NR4: Test Coverage) |
| std::mutex | C++17 <mutex> | Thread synchronization | Already used in ImportProgress (import_task.h:55) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| std::fmod | Manual loop | Loop is O(n) for large angles, fmod is O(1) |
| std::optional | Magic value (-1) | Optional is type-safe, self-documenting, no sentinel confusion |
| GLM inverse/transpose | Hand-rolled matrix math | GLM is battle-tested, hand-rolled is error-prone |

**Installation:**
Already present in codebase — no new dependencies required.

## Architecture Patterns

### Pattern 1: RAII Move Constructor Cleanup
**What:** Move constructors must reset source object members to safe sentinel values (0, nullptr).
**When to use:** Any class with move constructor that manages resources (raw pointers, OpenGL handles, file descriptors).
**Example:**
```cpp
// Source: Move Constructors in C++ (TheLinuxCode, 2026)
// https://thelinuxcode.com/move-constructors-in-c-a-practical-deep-dive-with-real-examples/
Framebuffer::Framebuffer(Framebuffer&& other) noexcept
    : m_fbo(other.m_fbo)
    , m_colorTexture(other.m_colorTexture)
    , m_depthTexture(other.m_depthTexture)
    , m_width(other.m_width)
    , m_height(other.m_height) {
    other.m_fbo = 0;
    other.m_colorTexture = 0;
    other.m_depthTexture = 0;
    other.m_width = 0;           // BUG-03: Was missing
    other.m_height = 0;          // BUG-03: Was missing
}
```

### Pattern 2: Optional Cache for Not-Found Values
**What:** Use std::optional to distinguish "not cached" from "cached as -1" (OpenGL uniform not found).
**When to use:** Caching lookup results where valid values and "not found" results overlap numerically.
**Example:**
```cpp
// Source: Codebase pattern (cost_repository.h, model_repository.h use std::optional)
class Shader {
    std::unordered_map<std::string, std::optional<GLint>> m_uniformCache;

    GLint getUniformLocation(const std::string& name) {
        auto it = m_uniformCache.find(name);
        if (it != m_uniformCache.end()) {
            return it->second.value_or(-1);  // Return cached value or -1
        }

        GLint location = glGetUniformLocation(m_program, name.c_str());
        m_uniformCache[name] = (location != -1) ? std::optional<GLint>{location} : std::nullopt;
        return location;
    }
};
```

### Pattern 3: Cache Invalidation on State Change
**What:** Cache expensive computations, invalidate when dependencies change.
**When to use:** Per-frame geometry generation (ViewCube), matrix calculations, mesh processing.
**Example:**
```cpp
// Source: Codebase viewport_panel.cpp:274-447
class ViewportPanel {
    struct ViewCubeCache {
        f32 lastYaw = -999.0f;
        f32 lastPitch = -999.0f;
        std::array<ImVec2, 8> projectedVerts;
        std::array<f32, 8> depths;
        bool valid = false;
    } m_viewCubeCache;

    void renderViewCube() {
        f32 yaw = m_camera.yaw();
        f32 pitch = m_camera.pitch();

        // Invalidate cache if camera changed
        if (!m_viewCubeCache.valid ||
            std::abs(yaw - m_viewCubeCache.lastYaw) > 0.01f ||
            std::abs(pitch - m_viewCubeCache.lastPitch) > 0.01f) {
            recomputeViewCubeGeometry();
            m_viewCubeCache.lastYaw = yaw;
            m_viewCubeCache.lastPitch = pitch;
            m_viewCubeCache.valid = true;
        }
        // Use cached geometry
    }
};
```

### Pattern 4: Normal Matrix for Non-Uniform Scaling
**What:** Compute normal matrix as `transpose(inverse(mat3(modelMatrix)))` for correct lighting.
**When to use:** Always for lighting calculations, unless you can prove uniform scaling.
**Example:**
```cpp
// Source: OpenGL Normal Vector Transformation (songho.ca)
// https://www.songho.ca/opengl/gl_normaltransform.html
Mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));
shader.setMat3("uNormalMatrix", normalMatrix);

// In shader:
// vec3 worldNormal = normalize(uNormalMatrix * aNormal);
```

### Anti-Patterns to Avoid
- **Caching -1 same as valid locations:** Use std::optional to distinguish "not found" from "cached not found"
- **Per-frame geometry recomputation:** Cache and invalidate on state change
- **Assuming uniform scaling:** Always use proper normal matrix unless profiling proves it's a bottleneck
- **O(n) angle wrapping loops:** Use std::fmod for O(1) operation

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Angle wrapping | `while (angle >= 360.0f) angle -= 360.0f;` | `std::fmod(angle, 360.0f)` | O(1) vs O(n), handles negative angles correctly |
| Normal matrix | Custom 3x3 inverse/transpose | `glm::transpose(glm::inverse(glm::mat3(m)))` | GLM is tested, handles edge cases (singular matrices) |
| SQL LIKE escaping | Manual string replacement | `str::escapeLike()` (already exists) | Handles \, %, _ correctly with backslash escaping |
| Optional caching | Magic sentinel values (-1, 0xFFFFFFFF) | `std::optional<T>` | Type-safe, self-documenting, no sentinel collision |

**Key insight:** The codebase already has correct utilities (str::escapeLike, std::optional pattern). Don't rebuild — use existing patterns consistently.

## Common Pitfalls

### Pitfall 1: std::fmod Doesn't Normalize to [0, 360)
**What goes wrong:** `std::fmod(-10.0f, 360.0f)` returns -10.0f, not 350.0f.
**Why it happens:** fmod preserves sign of dividend.
**How to avoid:** Add 360.0f if result is negative: `if (yaw < 0.0f) yaw += 360.0f;`
**Warning signs:** Negative camera yaw values after orbit in negative direction.

### Pitfall 2: Move Constructor Must Be noexcept
**What goes wrong:** Moves degrade to copies if not noexcept, causing performance issues.
**Why it happens:** STL containers use std::move_if_noexcept to preserve strong exception guarantee.
**How to avoid:** Always mark move constructors `noexcept` unless they genuinely can throw.
**Warning signs:** Performance degradation when resizing std::vector of Framebuffers.

### Pitfall 3: Matrix Inverse is Expensive
**What goes wrong:** Computing normal matrix in shader or per-vertex is slow.
**Why it happens:** Inverse is O(n³) for n×n matrix.
**How to avoid:** Compute on CPU once per draw call, send as uniform.
**Warning signs:** Frame rate drops with many draw calls.

### Pitfall 4: Cache Invalidation is Harder Than Caching
**What goes wrong:** Stale cache causes visual bugs (e.g., ViewCube doesn't update).
**Why it happens:** Forgetting to invalidate cache when dependencies change.
**How to avoid:** Explicit dirty flag, compare dependencies before using cache.
**Warning signs:** UI elements frozen or updating only on mouse interaction.

### Pitfall 5: SQL LIKE Injection Even With Prepared Statements
**What goes wrong:** User input "100%" matches all records, "test_file" matches "test1file".
**Why it happens:** LIKE wildcards (%, _) are SQL syntax, not data.
**How to avoid:** Escape % and _ with backslash, use `ESCAPE '\\'` in query.
**Warning signs:** Search for "test%" returns way more results than expected.

### Pitfall 6: std::optional Value Access Without Check
**What goes wrong:** Calling `.value()` on std::nullopt throws std::bad_optional_access.
**Why it happens:** Forgetting to check `.has_value()` or using `.value()` instead of `.value_or()`.
**How to avoid:** Use `.value_or(default)` or check `.has_value()` before `.value()`.
**Warning signs:** Runtime exceptions in release builds.

## Code Examples

Verified patterns from codebase and official sources:

### BUG-01: ViewCube Caching
```cpp
// Current: Recomputes every frame (viewport_panel.cpp:279-447)
// Fixed: Cache projected vertices, invalidate on camera change

struct ViewCubeCache {
    f32 lastYaw = -999.0f;
    f32 lastPitch = -999.0f;
    std::array<ImVec2, 8> projectedVerts;
    std::array<f32, 8> depths;
    std::array<FaceSort, 6> sortedFaces;
    bool valid = false;
};

void ViewportPanel::renderViewCube() {
    f32 yaw = m_camera.yaw();
    f32 pitch = m_camera.pitch();

    constexpr f32 epsilon = 0.01f;
    if (!m_cache.valid ||
        std::abs(yaw - m_cache.lastYaw) > epsilon ||
        std::abs(pitch - m_cache.lastPitch) > epsilon) {
        recomputeViewCubeGeometry();  // Extract lines 279-366 to this method
        m_cache.lastYaw = yaw;
        m_cache.lastPitch = pitch;
        m_cache.valid = true;
    }

    // Use cached m_cache.projectedVerts, depths, sortedFaces for rendering
}
```

### BUG-02: Camera Angle Wrapping
```cpp
// Current: O(n) loop (camera.cpp:38-41)
// while (m_yaw >= 360.0f) m_yaw -= 360.0f;
// while (m_yaw < 0.0f) m_yaw += 360.0f;

// Fixed: O(1) with std::fmod
void Camera::orbit(f32 deltaX, f32 deltaY) {
    m_yaw += deltaX * m_orbitSensitivity;
    m_pitch += deltaY * m_orbitSensitivity;

    m_pitch = std::clamp(m_pitch, m_minPitch, m_maxPitch);

    // Wrap yaw to [0, 360) using fmod
    m_yaw = std::fmod(m_yaw, 360.0f);
    if (m_yaw < 0.0f)
        m_yaw += 360.0f;

    updateVectors();
}
```

### BUG-03: Framebuffer Move Constructor
```cpp
// Current: Leaves stale width/height (framebuffer.cpp:12-21)
Framebuffer::Framebuffer(Framebuffer&& other) noexcept
    : m_fbo(other.m_fbo)
    , m_colorTexture(other.m_colorTexture)
    , m_depthTexture(other.m_depthTexture)
    , m_width(other.m_width)
    , m_height(other.m_height) {
    other.m_fbo = 0;
    other.m_colorTexture = 0;
    other.m_depthTexture = 0;
    // MISSING: Zero dimensions
}

// Fixed: Zero all members
Framebuffer::Framebuffer(Framebuffer&& other) noexcept
    : m_fbo(other.m_fbo)
    , m_colorTexture(other.m_colorTexture)
    , m_depthTexture(other.m_depthTexture)
    , m_width(other.m_width)
    , m_height(other.m_height) {
    other.m_fbo = 0;
    other.m_colorTexture = 0;
    other.m_depthTexture = 0;
    other.m_width = 0;    // FIX
    other.m_height = 0;   // FIX
}
```

### BUG-04: Shader Uniform Cache
```cpp
// Current: Stores -1 same as valid (shader.cpp:94-103)
std::unordered_map<std::string, GLint> m_uniformCache;

GLint Shader::getUniformLocation(const std::string& name) {
    auto it = m_uniformCache.find(name);
    if (it != m_uniformCache.end()) {
        return it->second;  // Returns -1 if cached, re-queries every time!
    }

    GLint location = glGetUniformLocation(m_program, name.c_str());
    if (location != -1) {
        m_uniformCache[name] = location;  // Only caches valid
    }
    return location;
}

// Fixed: Use std::optional
std::unordered_map<std::string, std::optional<GLint>> m_uniformCache;

GLint Shader::getUniformLocation(const std::string& name) {
    auto it = m_uniformCache.find(name);
    if (it != m_uniformCache.end()) {
        return it->second.value_or(-1);  // Cached -1 returns -1
    }

    GLint location = glGetUniformLocation(m_program, name.c_str());
    m_uniformCache[name] = (location != -1)
        ? std::optional<GLint>{location}
        : std::nullopt;
    return location;
}
```

### BUG-05: LIKE Injection (ALREADY FIXED)
```cpp
// Source: model_repository.cpp:103-110, string_utils.cpp:215-225
// ALREADY CORRECTLY IMPLEMENTED

// Utility function (string_utils.cpp:215-225)
std::string escapeLike(std::string_view s) {
    std::string result;
    result.reserve(s.size());
    for (char c : s) {
        if (c == '%' || c == '_' || c == '\\') {
            result.push_back('\\');  // Escape wildcards
        }
        result.push_back(c);
    }
    return result;
}

// Usage (model_repository.cpp:104-110)
auto stmt = m_db.prepare(
    "SELECT * FROM models WHERE name LIKE ? ESCAPE '\\' ORDER BY imported_at DESC");
if (!stmt.bindText(1, "%" + str::escapeLike(searchTerm) + "%")) {
    return results;
}

// STATUS: NO FIX NEEDED — already correctly implemented
```

### BUG-06: ImportProgress Race Condition
```cpp
// Current: char[256] written by worker, read by UI without sync (import_task.h:54-75)
struct ImportProgress {
    mutable std::mutex fileNameMutex;
    char currentFileName[256]{};  // Fixed-size buffer, mutex-protected

    void setCurrentFileName(const std::string& name) {
        std::lock_guard<std::mutex> lock(fileNameMutex);
        std::strncpy(currentFileName, name.c_str(), sizeof(currentFileName) - 1);
        currentFileName[sizeof(currentFileName) - 1] = '\0';
    }

    std::string getCurrentFileName() const {
        std::lock_guard<std::mutex> lock(fileNameMutex);
        return std::string(currentFileName);  // Copy under lock
    }
};

// STATUS: ALREADY FIXED with mutex protection (import_task.h:54-80)
// TODOS.md description is outdated — code is correct
```

**IMPORTANT:** BUG-06 is already fixed in the code. The TODOS.md description says "char[256] written by worker, read by UI without sync" but import_task.h:54-80 shows mutex protection via fileNameMutex. The bug description is stale.

However, per ROADMAP.md line 33, BUG-06 depends on Sub-Phase 1.3 (MainThreadQueue). This suggests the fix may be incomplete or needs additional work with MainThreadQueue integration.

### BUG-07: Normal Matrix Non-Uniform Scaling
```cpp
// Current: Assumes uniform scaling (renderer.cpp:108-109)
m_meshShader.setMat4("uNormalMatrix", modelMatrix);

// Fixed: Proper normal matrix calculation
// Source: OpenGL Normal Vector Transformation
// https://www.songho.ca/opengl/gl_normaltransform.html
Mat3 normalMatrix = glm::transpose(glm::inverse(glm::mat3(modelMatrix)));
m_meshShader.setMat3("uNormalMatrix", normalMatrix);

// Shader changes:
// - Change uniform from mat4 to mat3
// - vec3 worldNormal = normalize(uNormalMatrix * aNormal);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual angle wrapping loops | std::fmod(angle, 360.0f) | C++11 | O(n) → O(1), handles negatives |
| Magic sentinel values (-1) | std::optional<T> | C++17 (2017) | Type-safe, no sentinel collision |
| Assume uniform scaling | Always compute proper normal matrix | OpenGL 3.0+ era | Correct lighting for all scaling |
| Per-frame geometry | Cache + invalidation | Modern game engines | 10-100x perf improvement |

**Deprecated/outdated:**
- Manual while loops for angle normalization — std::fmod is standard since C++11
- Caching -1 as valid value — std::optional is idiomatic C++17

## Open Questions

1. **BUG-05: LIKE Injection**
   - What we know: Code already correctly escapes LIKE wildcards (string_utils.cpp:215-225, model_repository.cpp:110)
   - What's unclear: Why is this listed as a bug? TODOS.md may be outdated
   - Recommendation: Verify in tests that escapeLike works, mark as already fixed

2. **BUG-06: ImportProgress Race Condition**
   - What we know: Code has mutex protection (import_task.h:55, 65, 72, 78)
   - What's unclear: ROADMAP.md says "depends on Sub-Phase 1.3 (MainThreadQueue)" — is current fix incomplete?
   - Recommendation: Defer to Sub-Phase 1.3, may need MainThreadQueue to replace char buffer with posted events

3. **BUG-04: Uniform Cache Performance**
   - What we know: Current code re-queries glGetUniformLocation every frame for missing uniforms
   - What's unclear: Is this a measurable performance issue? How many missing uniforms per frame?
   - Recommendation: Implement std::optional fix, add test to verify caching works for both valid and -1

4. **Test Coverage for Bug Fixes**
   - What we know: test_camera.cpp exists (lines 75-82 test yaw wrapping), test_string_utils.cpp exists but no escapeLike test
   - What's unclear: Which bugs have existing test coverage?
   - Recommendation: Add tests for BUG-01 (cache invalidation), BUG-03 (move constructor), BUG-04 (uniform cache), BUG-07 (normal matrix)

## Sources

### Primary (HIGH confidence)
- Codebase inspection: viewport_panel.cpp, camera.cpp, framebuffer.cpp, shader.cpp, model_repository.cpp, project_repository.cpp, import_queue.cpp, import_task.h, renderer.cpp, string_utils.cpp
- std::fmod documentation: https://en.cppreference.com/w/cpp/numeric/math/fmod
- C++17 std::optional usage: Verified in codebase (11 files use std::optional)
- GLM documentation: https://glm.g-truc.net/0.9.4/api/a00133.html

### Secondary (MEDIUM confidence)
- [Modulus In Modern C/C++: From % To std::modulus](https://thelinuxcode.com/modulus-in-modern-cc-from-to-stdmodulus-and-the-edge-cases-that-bite/) — std::fmod best practices
- [Move Constructors in C++: A Practical Deep Dive](https://thelinuxcode.com/move-constructors-in-c-a-practical-deep-dive-with-real-examples/) — Move constructor zeroing pattern
- [OpenGL Normal Vector Transformation](https://www.songho.ca/opengl/gl_normaltransform.html) — Normal matrix explanation
- [The Normal Matrix](https://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix/) — GLM transpose(inverse(mat3(m))) pattern
- [Cache uniform locations? · Issue #66](https://github.com/JoeyDeVries/LearnOpenGL/issues/66) — Uniform caching best practices
- [Angle Normalization Code - really slow!](https://community.simplefoc.com/t/angle-normalization-code-really-slow/6853) — fmod vs loop performance

### Tertiary (LOW confidence)
- None — all findings verified against codebase or authoritative sources

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All tools already in codebase (C++17, GLM, std::optional)
- Architecture: HIGH - Patterns verified in existing code (optional pattern, mutex pattern)
- Pitfalls: HIGH - Based on actual bugs found in codebase, cross-referenced with community issues
- Bug status: HIGH - Each bug examined in source code at specified lines

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (30 days — stable domain, C++ standards don't change rapidly)

## Bug Groupings for Planning

Based on analysis, bugs naturally group:

1. **Group 1: Rendering (BUG-01, BUG-07)** — Both in rendering pipeline, test with visual verification
2. **Group 2: Core Utilities (BUG-02, BUG-03, BUG-04)** — Simple algorithmic/RAII fixes, unit testable
3. **Group 3: Database (BUG-05)** — ALREADY FIXED, needs test verification only
4. **Group 4: Threading (BUG-06)** — Defer to Sub-Phase 1.3 (depends on MainThreadQueue per ROADMAP.md:33)

**Recommendation:** Create 3 plans:
- Plan 1: BUG-02, BUG-03, BUG-04 (core utilities, no dependencies)
- Plan 2: BUG-01, BUG-07 (rendering, requires shader changes)
- Plan 3: BUG-05 verification (add escapeLike tests)

BUG-06 should be handled in Sub-Phase 1.3, not 1.5.
