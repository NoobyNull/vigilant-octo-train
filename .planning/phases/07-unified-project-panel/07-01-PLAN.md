# Plan 07-01: Refactor ProjectPanel into Asset Navigator

## Goal
Transform the existing ProjectPanel from a flat model list into a categorized asset navigator showing Models, G-code, Materials, Costs, Cut Plans, and Notes sections. Each section queries the relevant repository and displays assets with icons and summary info.

## Context

**Current ProjectPanel** (`src/ui/panels/project_panel.h/.cpp`, ~250 lines):
- Shows project info header (name, description, model count)
- Save/Close/Export buttons
- Flat list of model IDs (no names, just "Model #123")
- "No project open" state with New/Open/Recent

**Dependencies available after Phase 6:**
- `GCodeRepository::findByProject(projectId)` — returns `vector<GCodeRecord>`
- `CutPlanRepository::findByProject(projectId)` — returns `vector<CutPlanRecord>`
- `CostRepository::findByProject(projectId)` — returns `vector<CostEstimate>` (already exists)
- `ProjectRecord::notes` field — new
- `ModelRepository::findById(modelId)` — returns `ModelRecord` with name, tags, thumbnail

**Key pattern:** ProjectPanel currently only holds `ProjectManager*`. It needs access to additional repositories. Follow the existing pattern — inject via constructor or setter.

**Files to read before implementing:**
- `src/ui/panels/project_panel.h` — current class definition
- `src/ui/panels/project_panel.cpp` — current render methods
- `src/ui/panels/library_panel.h` — reference for rich item rendering with icons
- `src/ui/panels/cost_panel.h` — reference for repository injection
- `src/ui/panels/materials_panel.h` — reference for callbacks
- `src/core/database/model_repository.h` — ModelRecord struct
- `src/core/database/gcode_repository.h` — GCodeRecord struct
- `src/core/database/cut_plan_repository.h` — CutPlanRecord struct (from Phase 6)
- `src/core/database/cost_repository.h` — CostEstimate struct
- `src/ui/icons.h` — available icon constants

## Tasks

### Task 1: Expand ProjectPanel dependencies (project_panel.h)

Add repository pointers and navigation callbacks:

```cpp
// Forward declarations (add at top)
class ModelRepository;
class GCodeRepository;
class CutPlanRepository;
class CostRepository;

class ProjectPanel : public Panel {
  public:
    ProjectPanel(ProjectManager* projectManager,
                 ModelRepository* modelRepo,
                 GCodeRepository* gcodeRepo,
                 CutPlanRepository* cutPlanRepo,
                 CostRepository* costRepo);

    // Navigation callbacks
    using GCodeSelectedCallback = std::function<void(i64 gcodeId)>;
    using MaterialSelectedCallback = std::function<void(i64 materialId)>;
    using CostSelectedCallback = std::function<void(i64 estimateId)>;
    using CutPlanSelectedCallback = std::function<void(i64 planId)>;

    void setOnGCodeSelected(GCodeSelectedCallback cb);
    void setOnMaterialSelected(MaterialSelectedCallback cb);
    void setOnCostSelected(CostSelectedCallback cb);
    void setOnCutPlanSelected(CutPlanSelectedCallback cb);

  private:
    // Section renderers
    void renderModelsSection();
    void renderGCodeSection();
    void renderMaterialsSection();
    void renderCostsSection();
    void renderCutPlansSection();
    void renderNotesSection();

    // Repositories
    ModelRepository* m_modelRepo;
    GCodeRepository* m_gcodeRepo;
    CutPlanRepository* m_cutPlanRepo;
    CostRepository* m_costRepo;

    // Callbacks
    GCodeSelectedCallback m_onGCodeSelected;
    MaterialSelectedCallback m_onMaterialSelected;
    CostSelectedCallback m_onCostSelected;
    CutPlanSelectedCallback m_onCutPlanSelected;

    // Notes editing state
    char m_notesBuf[4096] = {};
    bool m_notesChanged = false;
};
```

Keep the existing callbacks (ModelSelected, Open, Save, Export, RecentProject).

### Task 2: Refactor render() into sections (project_panel.cpp)

Replace the existing `renderProjectInfo()` + `renderModelList()` with:

```cpp
void ProjectPanel::render() {
    if (!m_open) return;
    if (ImGui::Begin(m_title.c_str(), &m_open)) {
        if (m_projectManager && m_projectManager->currentProject()) {
            renderProjectInfo();    // Keep: name, save/close/export buttons
            ImGui::Separator();
            renderModelsSection();
            renderGCodeSection();
            renderMaterialsSection();
            renderCostsSection();
            renderCutPlansSection();
            ImGui::Separator();
            renderNotesSection();
        } else {
            renderNoProject();      // Keep existing
        }
    }
    ImGui::End();
}
```

### Task 3: Implement renderModelsSection()

Replace `renderModelList()` — now fetches model names from `ModelRepository`:

```cpp
void ProjectPanel::renderModelsSection() {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    bool open = ImGui::CollapsingHeader(
        (std::string(Icons::Model) + " Models (" +
         std::to_string(project->modelIds().size()) + ")").c_str(),
        ImGuiTreeNodeFlags_DefaultOpen);

    if (!open) return;
    ImGui::Indent();

    const auto& modelIds = project->modelIds();
    if (modelIds.empty()) {
        ImGui::TextDisabled("No models — add from Library panel");
    } else {
        for (i64 modelId : modelIds) {
            ImGui::PushID(static_cast<int>(modelId));
            auto record = m_modelRepo->findById(modelId);
            std::string label = record
                ? (Icons::Model + std::string(" ") + record->name)
                : (Icons::Model + std::string(" Model #") + std::to_string(modelId));

            bool selected = (modelId == m_selectedModelId);
            if (ImGui::Selectable(label.c_str(), selected)) {
                m_selectedModelId = modelId;
                if (m_onModelSelected) m_onModelSelected(modelId);
            }

            // Context menu: remove from project
            if (ImGui::BeginPopupContextItem()) {
                if (ImGui::MenuItem("Remove from Project")) {
                    project->removeModel(modelId);
                }
                ImGui::EndPopup();
            }
            ImGui::PopID();
        }
    }
    ImGui::Unindent();
}
```

### Task 4: Implement renderGCodeSection()

```cpp
void ProjectPanel::renderGCodeSection() {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    auto gcodeFiles = m_gcodeRepo->findByProject(project->id());
    bool open = ImGui::CollapsingHeader(
        (std::string(Icons::GCode) + " G-code (" +
         std::to_string(gcodeFiles.size()) + ")").c_str(),
        ImGuiTreeNodeFlags_DefaultOpen);

    if (!open) return;
    ImGui::Indent();

    if (gcodeFiles.empty()) {
        ImGui::TextDisabled("No G-code files — import from GCode panel");
    } else {
        for (const auto& gc : gcodeFiles) {
            ImGui::PushID(static_cast<int>(gc.id));
            std::string label = Icons::GCode + std::string(" ") + gc.name;
            if (ImGui::Selectable(label.c_str())) {
                if (m_onGCodeSelected) m_onGCodeSelected(gc.id);
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Time: %.1f min | Tools: %zu",
                    gc.estimatedTime / 60.0f, gc.toolNumbers.size());
            }
            if (ImGui::BeginPopupContextItem()) {
                if (ImGui::MenuItem("Remove from Project")) {
                    m_gcodeRepo->removeFromProject(project->id(), gc.id);
                }
                ImGui::EndPopup();
            }
            ImGui::PopID();
        }
    }
    ImGui::Unindent();
}
```

### Task 5: Implement renderMaterialsSection()

Query models in the project that have a material assigned, collect unique material IDs:

```cpp
void ProjectPanel::renderMaterialsSection() {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    // Collect unique materials from project models
    std::vector<std::pair<i64, std::string>> materials; // id, name
    std::unordered_set<i64> seen;
    for (i64 modelId : project->modelIds()) {
        auto record = m_modelRepo->findById(modelId);
        if (record && record->materialId > 0 && seen.insert(record->materialId).second) {
            materials.push_back({record->materialId, record->materialName});
        }
    }

    bool open = ImGui::CollapsingHeader(
        (std::string(Icons::Material) + " Materials (" +
         std::to_string(materials.size()) + ")").c_str());

    if (!open) return;
    ImGui::Indent();

    if (materials.empty()) {
        ImGui::TextDisabled("No materials assigned to project models");
    } else {
        for (const auto& [matId, matName] : materials) {
            ImGui::PushID(static_cast<int>(matId));
            std::string label = Icons::Material + std::string(" ") + matName;
            if (ImGui::Selectable(label.c_str())) {
                if (m_onMaterialSelected) m_onMaterialSelected(matId);
            }
            ImGui::PopID();
        }
    }
    ImGui::Unindent();
}
```

Note: Check if `ModelRecord` has `materialId` and `materialName` fields. If `materialName` isn't available, query `MaterialRepository` or just show the material ID. Adapt based on what's actually in the record.

### Task 6: Implement renderCostsSection()

```cpp
void ProjectPanel::renderCostsSection() {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    auto estimates = m_costRepo->findByProject(project->id());
    bool open = ImGui::CollapsingHeader(
        (std::string(Icons::Cost) + " Cost Estimates (" +
         std::to_string(estimates.size()) + ")").c_str());

    if (!open) return;
    ImGui::Indent();

    if (estimates.empty()) {
        ImGui::TextDisabled("No estimates — create in Cost panel");
    } else {
        for (const auto& est : estimates) {
            ImGui::PushID(static_cast<int>(est.id));
            std::string label = Icons::Cost + std::string(" ") + est.name;
            if (ImGui::Selectable(label.c_str())) {
                if (m_onCostSelected) m_onCostSelected(est.id);
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Total: $%.2f | Items: %zu",
                    est.total, est.items.size());
            }
            ImGui::PopID();
        }
    }
    ImGui::Unindent();
}
```

### Task 7: Implement renderCutPlansSection()

```cpp
void ProjectPanel::renderCutPlansSection() {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    auto plans = m_cutPlanRepo->findByProject(project->id());
    bool open = ImGui::CollapsingHeader(
        (std::string(Icons::Optimizer) + " Cut Plans (" +
         std::to_string(plans.size()) + ")").c_str());

    if (!open) return;
    ImGui::Indent();

    if (plans.empty()) {
        ImGui::TextDisabled("No cut plans — save from Optimizer panel");
    } else {
        for (const auto& plan : plans) {
            ImGui::PushID(static_cast<int>(plan.id));
            std::string label = Icons::Optimizer + std::string(" ") + plan.name;
            if (ImGui::Selectable(label.c_str())) {
                if (m_onCutPlanSelected) m_onCutPlanSelected(plan.id);
            }
            if (ImGui::IsItemHovered()) {
                ImGui::SetTooltip("Sheets: %d | Efficiency: %.1f%%",
                    plan.sheetsUsed, plan.efficiency * 100.0f);
            }
            if (ImGui::BeginPopupContextItem()) {
                if (ImGui::MenuItem("Remove from Project")) {
                    m_cutPlanRepo->remove(plan.id);
                }
                ImGui::EndPopup();
            }
            ImGui::PopID();
        }
    }
    ImGui::Unindent();
}
```

### Task 8: Implement renderNotesSection()

```cpp
void ProjectPanel::renderNotesSection() {
    auto project = m_projectManager->currentProject();
    if (!project) return;

    if (ImGui::CollapsingHeader("Notes")) {
        ImGui::Indent();
        // Load notes into buffer on first render or project change
        if (!m_notesChanged) {
            auto record = m_projectManager->getProjectInfo(project->id());
            if (record) {
                strncpy(m_notesBuf, record->notes.c_str(), sizeof(m_notesBuf) - 1);
            }
        }

        if (ImGui::InputTextMultiline("##notes", m_notesBuf, sizeof(m_notesBuf),
                ImVec2(-1, 120))) {
            m_notesChanged = true;
        }

        if (m_notesChanged && ImGui::IsItemDeactivatedAfterEdit()) {
            // Auto-save notes
            auto record = m_projectManager->getProjectInfo(project->id());
            if (record) {
                record->notes = m_notesBuf;
                // Update via ProjectRepository
                m_notesChanged = false;
            }
        }
        ImGui::Unindent();
    }
}
```

### Task 9: Update constructor call site (application.cpp or application_wiring.cpp)

Find where `ProjectPanel` is constructed and pass the additional repositories:

```cpp
// Before:
m_projectPanel = std::make_unique<ProjectPanel>(m_projectManager.get());

// After:
m_projectPanel = std::make_unique<ProjectPanel>(
    m_projectManager.get(),
    &m_modelRepo,       // or however ModelRepository is accessed
    m_gcodeRepo.get(),  // adapt to actual ownership
    m_cutPlanRepo.get(),
    m_costRepo.get());
```

Check `src/managers/ui_manager.h/.cpp` — panels may be constructed there. Adapt the constructor call to wherever ProjectPanel is created.

## Verification

1. `cmake --build build -j$(nproc)` — compiles cleanly
2. `build/tests/dw_tests` — all tests pass
3. Open app, create project, add models — Models section shows model names (not just IDs)
4. G-code, Materials, Costs, Cut Plans sections show "(0)" with guidance text
5. Notes section has editable multiline input

## Files Modified

| File | Change |
|------|--------|
| `src/ui/panels/project_panel.h` | Add repos, callbacks, section renderers, notes state |
| `src/ui/panels/project_panel.cpp` | Rewrite render into 6 sections |
| `src/managers/ui_manager.cpp` (or application_wiring.cpp) | Update ProjectPanel constructor |
